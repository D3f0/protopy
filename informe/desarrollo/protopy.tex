\chapter{La libreria}

%que
\section{Inicio}
La idea de diseñar y desarrollar un framework en que funcione en el hambiente
de un navegador web, como es Firefox, deja entrever muchos aspectos que no
resultan para nada triviales al momento de codificar.
\begin{itemize}
  \item Se requieren varias lineas de codigo para implementar un framework.
  \item Como llega el codigo al navegador y se inicia su ejecucion.
  \item La cara visible o vista debe ser fasilmente manipulable por la aplicacion
  de usuario.
  \item Como los datos generados en el cliente son informados al servidor.
  \item El framework debe brindar soporte a la aplicacion de usuario de una forma
  natural y transparente.
  \item Se debe promover al reuso y la extension de funcionalidad del framework.
  \item Como se ponen en marcha los mecanimos o acciones que la aplicacion de
  usuario define.
  \item ...
\end{itemize}
En este capitulo se introducen las ideas principales que motivaron la
creacion de una libreria en JavaScript, que brinde el soporte necesario al
framework y a buena parte de los items expuestos.

Si bien el desarrollo de la libreria se mantuvo en paralelo a la del
framework, existen aspectos basicos a los que esta brinda soporte y permiten
presentarla en un apartado separado como una ''Libreria JavaScript'', esta
constituye la base para posteriores construcciones y auna herramientas que
simplifican el desarrollo client-side.

\textit{proto}type + \textit{py}thon = \textit{protopy}

``La creación nace del caos'', la libreria ``Protopy'' no escapa a esta
afirmacion e inicialmente nace de la integracion de Prototype con
las primeras funciones para lograr la modularizacion; con el correr de las
lineas de codigo\footnote{Forma en que los informaticos miden el paso del
tiempo} el desarrollo del framework torna el enfoque inicial poco sustentable,
requiriendo este de funciones mas Python-compatibles se desecha la libreria
base y se continua con un enfoque más ``pythonico'', persiguiendo de esta forma
acercar la semántica de JavaScript 1.7 a la del lenguaje de programacion Python.

No es arbitrario que el navegador sobre el cual corre Protopy sea Firefox y
mas particularmente sobre la version 1.7 de JavaScript. El proyecto mozilla
esta hacercando, con cada nueva versiones del lenguaje, la semantica de JavaScript a
la de Python, incluyendo en esta version generadores e iteradores los cuales
son muy bien explotados por Protopy y el framework.

\subsection*{Protopy}
\textit{Protopy es una libreria JavaScript para el desarrollo de aplicaciones
web dinamicas. Aporta un enfoque modular para la inclusión de código,
orientación a objetos, manejo de AJAX, DOM y eventos.}

Para una referencia completa de la API de Protopy remitase al apandice
\fullref{ch:apendiceProtopy}.

%como
\section{Organizando el codigo}
Undo de los principales inconvenientes a los que Protopy da solucion es a la
inclucion dinamica de funcionalidad bajo demanda, esto se logra con los
``modulos''.
%Forma tradicional vs enfoque de protopy
Tradicionalmente la forma de incluir codigo JavaScript es mediante la
incorporation de una etiqueta ``script'' con un atributo de referencia
al archivo que contiene la funcionalidad. Mas tarde cuando el navegador descarga
el documento y comienza su lectura al encontrar esta etiqueta solicita
al servidor el archivo referenciado y lo interpreta, para continuar luego con la
lectura del resto de las etiquetas. Este enfoque resulta sustentable en el
desarrollo tradicional, en donde el lenguaje brinda mayormente soporte a la
interaccion con el usuario y los fragmentos de codigo que se trasladan al
cliente son bien conocidos por el desarrollador; para un proyecto que implica
gran cantidad de codigo, como en este caso, el enfoque resulta complejo de
sostener.
Buscando una mejor forma de organizar y obtener el codigo es que surge el
concepto de ``modulo'', similar a los modulos en python, cada unidad basica de
de codigo define un modulo, este puede ser importado por otro fragemento de
codigo y cada uno representa su propio ambito de nombres. Existen en Protopy
dos tipos de modulos, los modulos integrados y los modulos organizados en
archivos JavaScript.
%poner mas sobre los archivos js que representan modulos
%Esquema de nombrado
Para acceder a los modulos es necesario establecer un esquema de nombrado \ldots
%Completar sobre esquema de nombres.
Con los modulos y un sistema de nombrado para el acceso a los mismos, la
responsabilidad de la carga del codigo se deja en manos del cliente y del
propio codigo que requiera determinada funcionalidad provista por un modulo.

Las funciones principales para trabajar con los modulos son ``require'' para
cargar un modulo en el hambito de nombres local y ``publish'' para que los
modulos publiquen o expongan la funcionalidad.

\section{Creando tipos de objeto}
%Semántica de objetos, dentro de la cual se hace una adaptación de
En la programación basada en prototipos las ``clases'' no están presentes, y la
re-utilización de procesos se obtiene a través de la clonación de objetos ya
existentes.
Protopy agrega el concepto de clases al desarrollo, mediante un contructor de
``tipos de objeto''. De esta forma los objetos pueden ser de dos tipos, las
clases y las instancias. Las clases definen la disposición y la funcionalidad
básicas de los objetos, y las instancias son objetos ``utilizables'' basados en
los patrones de una clase particular.
...

Como ya se menciono anteriormente Protopy explota las novedades de JavaScript
1.7, para los iteradores el constructor de tipos prevee el metodo
\verb|__iter__| con la finalidad de que los objetos generados en base al tipo
sean iterables.

Los primeros tipos que surgen para la organizacion de datos dentro de la
librerias con los ``Sets'' y los ``Diccionarios'', hambos aproximan su
estructura a las estructuras homonimas en python, brindando una funcionalidad
similar. Si bien la estructura ``hasheable'' nativa a JavaScript en un objeto,
los diccionarios de Protopy permiten el uso de objetos como claves en lugar de
solo cadenas.

\section{Extendiendo el DOM}
Si bien el \DOM\ ofrece ya una \API\ muy completa para acceder, añadir y cambiar
dinámicamente el contenido estructurado en el documento HTML.

\section{Manejando los eventos}
%event.connect
%event.

\section{Envolviendo a gears}
%Almacenamiento en la base de datos local
%LocalServer para guradar codigo

\section{Auditando el codigo}
%Logger


\section{Interactuando con el servidor}
%HttpRequest


\section{Soporte para json}
%JSON REF http://www.json.org/
%Esto es algo sobre json, quiza no valla aca
\JSON\ brinda un buen soporte al intercambio de datos, resultando de fásil
lectura/escritura para las personas y de un rapido interpretacion/generacion
para las maquinas. Se basa en un subconjunto del lenguaje de programación
JavaScript, estándar ECMA-262 3ª Edición - Diciembre de 1999. Este formato de
texto es completamente independiente del lenguaje de programacion, pero utiliza
convenciones que son familiares para los programadores de lenguajes de la
familia ``C'', incluyendo C, C + +, C \#, Java, JavaScript, Perl, Python y muchos otros.

JSON se basa en dos estructuras:
\begin{itemize}
  \item Una colección de pares nombre / valor. En varios lenguajes esto se
  representa mediante un objeto, registro, estructura, diccionario, tabla hash,
  introducido lista o matriz asociativa.
  \item Una lista ordenada de valores. En la mayoría de los lenguajes esto se
  representa como un arreglo, matriz, vector, lista, o secuencia.
\end{itemize}

Estas son estructuras de datos universales. Prácticamente todos los lenguajes
de programación modernos las soportan de una forma u otra. Tiene sentido que un
formato de datos que es intercambiable con los lenguajes de programación
también se basan en estas estructuras.

Para mas informacion sobre \JSON\ http://www.json.org/

%Ahora vemos que hace protopy, la necesidad
Mientras que un cliente se encuentre sin conexion con el servidor web, es capaz
de generar y almacenar datos usando su base de datos local. Al reestablecer
la conexion con el servidor web, estos datos deben ser transimitos a la base de
datos central para su actulizacion y posterior sincronizacion del resto de los
clinetes.
La transferencia de datos involucra varios temas, uno de ellos y que compete
a este apartado, es el formato de los datos que se deben pasar por
la conexcion; este formato debe ser ``comprendido'' tanto por el cliente como
por el servidor. Desde un primer momento se penso en \JSON\ como el formato
de datos a utilizar, es por esto que Protopy incluye un modulo para trabajar con el mismo.

%Porque no xml?
No existe una razon concreta por la cual se deja de lado el soporte en Protopy
para XML como formato de datos; aunque se puede mencionar la simplicidad de
implementacion de un parser \JSON\ contra la implementacion de uno en XML.
Para el leector interesado agregar el sporte para XML en Protopy consta de
escribir un modulo que realize esa tarea y agregarlo al paquete base.

%El como
El soporte para \JSON\ se encuentra en el modulo ``json" entre los modulos
estandar de Protopy. Este brinda soporte al pasaje de estructuras de datos
JavaScript a JSON y viceversa.
Los tipos base del lenguje JavaScript estan soportados y tienen su
reprecentacion correspondiente, object, array, number, string, etc. pero este
modulo interpreta ademas de una forma particular a aquellos objetos que
implementen el metodo \verb|__json__|, dejando de este modo en manos del
desarrollador la reprecentacion en JSON de determinado objetos.
La inclusion del metodo \verb|__json__|  resulta de especial impotancia a la
hora de pasar a JSON los objetos creados en base a tipos definidos por el
desarrollador mediante el contructor ``type''.

Con el soporte de datos ya establecidos en la libreria, el framework solo
debe limitarce a hacer uso de él y asegurar la correcta sincronizacion de datos
entre el cliente y el servidor web, este tema se retomara en el capitulo de
sincronizacion.
%TODO: retomar este tema para no ser un mentiroso :)

\section{Ejecutando codigo remoto}
%JSON-RPC http://json-rpc.org/ 
%XML-RPC http://www.xmlrpc.com/
El RPC (del inglés Remote Procedure Call, Llamada a Procedimiento Remoto) es un
protocolo que permite a un programa de ordenador ejecutar código en otra máquina
remota sin tener que preocuparse por las comunicaciones entre ambos. El protocolo
es un gran avance sobre los sockets usados hasta el momento. De esta manera el
programador no tenía que estar pendiente de las comunicaciones, estando éstas
encapsuladas dentro de las RPC.

Las RPC son muy utilizadas dentro del paradigma cliente-servidor. Siendo el
cliente el que inicia el proceso solicitando al servidor que ejecute cierto
procedimiento o función y enviando éste de vuelta el resultado de dicha operación
al cliente.

Hay distintos tipos de RPC, muchos de ellos estandarizados como pueden ser el RPC
de Sun denominado ONC RPC (RFC 1057), el RPC de OSF denominado DCE/RPC y el
Modelo de Objetos de Componentes Distribuidos de Microsoft DCOM, aunque ninguno
de estos es compatible entre sí. La mayoría de ellos utilizan un lenguaje de
descripción de interfaz (IDL) que define los métodos exportados por el servidor.

Hoy en día se está utilizando el XML como lenguaje para definir el IDL y el HTTP
como protocolo de red, dando lugar a lo que se conoce como servicios web.
Ejemplos de éstos pueden ser SOAP o XML-RPC. XML-RPC es un protocolo de llamada a
procedimiento remoto que usa XML para codificar los datos y HTTP como protocolo
de transmisión de mensajes.[1]

Es un protocolo muy simple ya que sólo define unos cuantos tipos de datos y
comandos útiles, además de una descripción completa de corta extensión. La
simplicidad del XML-RPC está en contraste con la mayoría de protocolos RPC que
tiene una documentación extensa y requiere considerable soporte de software para
su uso.

Fue creado por Dave Winer de la empresa UserLand Software en asociación con
Microsoft en el año 1998. Al considerar Microsoft que era muy simple decidió
añadirle funcionalidades, tras las cuales, después de varias etapas de
desarrollo, el estándar dejó de ser sencillo y se convirtió en lo que es
actualmente conocido como SOAP. Una diferencia fundamental es que en los
procedimientos en SOAP los parámetros tienen nombre y no interesan su orden, no
siendo así en XML-RPC.[2
