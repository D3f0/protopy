\chapter{Protopy}
El desarrollo de un framework en javascript que funcione del lado del cliente
presupone gran cantidad de codigo
viajando de un lado al otro de la conexion. Previendo basicamente este postulado
desarrollamos una libreria
que brinde el soporte a los requerimentos mas basicos.
Esta librerÃ­a contituye la base para posteriores contrucciones mas complejas en
el ciente y auna herramientas
que simplifican el desarrollo client-side.

\section{Modulos}
Undo de los principales inconvenientes a los que protopy da solucion es a la
inclucion dinamica de funcionalidad bajo demanda,
esto es logrado mediante los modulos.
Basicamente un modulo en un archivo con codigo javascript que recide en el
servidor y es obtenido y ejecutado en el cliente.

\begin{lstlisting}[style=javascript,label=estructura-modulo,caption=Estructura
de un modulo]
//Archivo: tests/module.js
require('event');

var h1 = $('titulo');

function set_texto(txt) {
    h1.update(txt);
}

function get_texto() {
    return h1.innerHTML;
}

event.connect($('titulo'), 'click', function(event) {
    alert('El texto es: ' + event.target.innerHTML);
});

publish({
    set_texto: set_texto,
    get_texto: get_texto
});
\end{lstlisting}

\begin{lstlisting}[style=consola]
>>> require('tests.module')
>>> module.get_texto()
"Test de modulo"
>>> module.set_texto('Un titulo')
>>> require('tests.module', 'get_texto')
>>> get_texto()
"Un titulo"
>>> require('tests.module', '*')
>>> set_texto('Hola luuu!!!')
>>> get_texto()
"Hola luuu!!!"
\end{lstlisting}

\section{Modulos incluidos en el nucleo de protopy}
\subsection{builtin}
Este modulo contiene la principal funcionalidad de protopy, en el se encuentran
las funciones y contructores para realizar la mayoria de las tareas, no es
necesario importarlo en el espacio de nombres ya que su funcionalidad esta
disponible desde que protopy se carga.

\subsubsection*{publish}
\begin{verbatim}
  publish(object)
\end{verbatim}
Publica la funcionalidad de un modulo. 
Para interactuar con el codigo definido en un modulo es necesario
exponer una interface de acceso al mismo, de esto se encarga la funcion publish.

\subsubsection*{require}
\begin{verbatim}
  require(module[, object...]) -> module | object
\end{verbatim} 
Importa un modulo en el espacio de nombres.
Al invocar a esta funcion un modulo es cargado desde el servidor y ejecutado en
el clinete, la forma en que el modulo se presenta en el espacio de nombres
depende de la invoacion.
\begin{itemize}
 \item{var cntx = require('doff.template.context')}
  Importa el modulo 'doff.template.context' y lo retorna en cntx, dejando
tambien una referencia en el espacio de nombres llamda 'context', esta dualidad
en la asociacion del modulo permite imporatar modulos sin asociarlos a una
variable, simplemente alcanza con asumir que la parte final del nombre es la
referencia a usar.
 \item{var cur = require('gears.database', 'cursor')}
  Importa el modulo 'gears.databse' y retorna en cur el objeto publicado bajo el
nombre de cursor, similar al caso anterior una referencia se define en el
espacio de nombres para cursor.  
 \item{require('doff.db.models', 'model', 'query')}
  Importa el modulo 'doff.db.models' y define en el espacio de nombres las
referencias a model y query usando los mismos nombres.
 \item{require('doff.core.urlpattern', '*')}
  Importa del modulo 'doff.core.urlpattern' todos los objetos publicados y los
publica en el espacio de nombres.
\end{itemize}

\subsubsection*{type}
\begin{verbatim}
  type(name, [base...] [, class ], instance) -> Type
\end{verbatim} 
Funcion encargada de la construccion de nuevos tipos o clases.
Una vez definido un nuevo tipo este puede ser utilizado para la contruccion
indiscriminada de objetos de ese tipo mediante el operador new.
Como argumentos admite, el nombre del nuevo tipo, las bases de la cual hereda,
opcionalmente los atributos y metodos de clase y los atributos y metodos para la
instancia.

La funcion constructor de los objetos tiene por nombre __init__ y es disparada
en el momento de la construccion del objeto; en conjunto con otros metodos que
se mencionaran a lo largo del texto estas funciones resultan de especial interes
para interactuar con nuestros objetos y existen operadores en protopy para
manejarlas, esto es, no debieran ser invocadas o llamadas directamente.
\begin{lstlisting}[style=javascript,label=definicion-de-tipos,caption=Definicion de tipos]
var Animal = type('Animal', object, {
    contador: 0,
}, {
    __init__: function(especie) {
	this.especie = especie;
	this.orden = Animal.contador++;
    }
});

var Terrestre = type('Terrestre', Animal, {
    caminar: function() {
	console.log(this.especie + ' caminando');
    }
});

var Acuatico = type('Acuatico', Animal, {
    nadar: function() {
	console.log(this.especie + ' nadando');
    }
});

var Anfibio = type('Anfibio', [Terrestre, Acuatico]);

var Piton = type('Piton', Terrestre, {
    __init__: function(nombre) {
	super(Terrestre, this).__init__(this.__name__);
	this.nombre = nombre;
    },
    caminar: function() {
	throw new Exception(this.especie + ' no camina');
    },
    reptar: function() {
	console.log(this.nombre + ' la ' + this.especie.toLowerCase() + ' esta
reptando');
    }
});

var doris = new Piton('Doris');
var ballena = new Acuatico('Ballena');
var rana = new Anfibio('Rana');
\end{lstlisting}
\begin{lstlisting}[style=consola]
>>> doris
window.Piton especie=Piton orden=0 nombre=Doris __name__=Piton
>>> rana
window.Anfibio especie=Rana orden=2 __name__=Anfibio
>>> isinstance(rana, Terrestre)
true
>>> isinstance(doris, Animal)
true
>>> issubclass(Anfibio, Acuatico)
true
>>> issubclass(Piton, Animal)
true
>>> doris.caminar()
Exception: Piton no camina args=[1] message=Piton no camina
>>> doris.reptar()
Doris la piton esta reptando
\end{lstlisting}

\subsubsection*{\$}
\begin{verbatim}
  $(id) -> HTMLElement
  $(id[, id...]) -> [HTMLElement...]
\end{verbatim}
Esta funcion recibe una cadena de texto y retorna un elemento del documento cuyo
id se corresponda con la cadena. En conjunto con la funcion \$\$ constituyen dos
herramientas muy utiles para recuperar elementos e interactuar con el arbol DOM.
Si mas de un argumento es pasado, la forma de retorno es mediante un arreglo,
permitiendo asi la iteracion sobre los mismos.
\begin{lstlisting}[style=consola]
>>> $('content')
<div id="content">
>>> $('content body')
>>> $('content', 'body')
[div#content, div#body]
>>> $('content', 'body', 'head')
[div#content, div#body, undefined]
\end{lstlisting}

\subsubsection*{\$\$}
\begin{verbatim}
  $$(cssRule) -> [HTMLElement...]
\end{verbatim}
Recupera elementos del documento, pero en lugar de hacerlo mediante un
identificador, lo realiza utilizando las reglas de css o hoja de estilos.
\begin{lstlisting}[style=consola]
>>> $$('div')
[div#wrap, div#top, div#content, div.header, div.breadcrumbs, div.middle, div,
div.right, div#clear, div#footer, div#toolbar]
>>> $$('div#toolbar')
[div#toolbar]
>>> $$('div#toolbar li')
[li, li.panel, li.panel, li, li]
>>> $$('div#toolbar li.panel')
[li.panel, li.panel]
>>> $$('a:not([href~=google])')
[a add_post, a add_tag, a removedb, a syncdb]
>>> $$('a:not([href=google])')
[a add_post, a add_tag, a#google www.google.com, a removedb, a syncdb]
>>> $$('div:empty')
[div#logger.panel, div#dbquery.panel, div#clear, div#top]
\end{lstlisting}

%extend
\subsubsection*{extend}
\begin{verbatim}
  extend(destiny, source) -> alteredDestiny
\end{verbatim}
Extiende sobre un objeto destino todos los objetos pasados como argumentos a
continuacion, copiando cada uno de los atributos correspondientes, el objeto
destino es retornado modificado.
\begin{lstlisting}[style=consola]
>>> a = {perro: 4}
>>> b = {gato: 4}
>>> c = extend(a, b)
>>> c
Object perro=4 gato=4
>>> a
Object perro=4 gato=4
>>> b
Object gato=4
\end{lstlisting}

%super
\subsubsection*{super}
\begin{verbatim}
  super(tipo, objeto) -> boundedObject
\end{verbatim}
Enlaza un objeto con un tipo de objeto, de este modo la invocacion sobre una
funcion del tipo se realizara sobre el objeto enlazado.
Normalemnte esta funcion es utilizada para llamar a metodos de un tipo base.

%isundefined
\subsubsection*{isundefined}
\begin{verbatim}
  isundefined(object) -> boolean
\end{verbatim}
Determina si un objeto no esta definido o asociado a un valor. Retorna un valor
de verdad correspondiente.

%isinstance
\subsubsection*{isinstance}
\begin{verbatim}
  isinstance(object, type | [type...]) -> boolean
\end{verbatim}
Retorna verdadero si el objeto es una instancia del tipo, si un arreglo de tipos
es pasado como segundo argumento el valor de verdad surge de preguntar por cada
uno de ellos.

%issubclass 
\subsubsection*{issubclass}
\begin{verbatim}
  issubclass(type1, type2 | [type...]) -> boolean
\end{verbatim}
Retorna si type1 es una subclase de type2, cuando se pasa un arrgelo en lugar de
type2 la evalucion se reliza para cada una de las clases incluidas en el mismo.

%Arguments
\subsubsection*{Arguments}
\begin{verbatim}
  new Arguments(arguments) -> Arguments
\end{verbatim}

\begin{lstlisting}[style=consola]
\end{lstlisting}

%Template
\subsubsection*{Template}
\begin{verbatim}
    new Template(destiny, source) -> Template
\end{verbatim}

\subsubsection*{Dict}
\begin{verbatim}
  new Dict(object) -> Dict
\end{verbatim}
\begin{lstlisting}[style=consola]
>>> dic = new Dict({'db': 5, 'template': 2, 'core': 9})
>>> obj = {'un': 'objeto'}
>>> dic.set(obj, 10)
>>> arreglo = [1,2,3,4,obj]
>>> dic.set(arreglo, 50)
>>> dic.get('template')
2
>>> dic.get(arreglo)
50
>>> dic.get(obj)
10
>>> dic.items()
[["db", 5], ["template", 2], ["core", 9], [Object un=objeto, 10], [[1, 2, 3, 2
more...], 50]]
>>> dic.keys()
["db", "template", "core", Object un=objeto, [1, 2, 3, 2 more...]]
>>> dic.values()
[5, 2, 9, 10, 50]
\end{lstlisting}

\subsubsection*{Set}
\begin{verbatim}
  new Set(array) -> Set
\end{verbatim}
Un set es una coleccion de elementos unicos, similar a conjuntos este tipo de
objeto brinda funcionalidad util a la momento de trabajar con los elementos,
como son la interseccion la union la diferencia, etc.
\begin{lstlisting}[style=consola]
>>> set = new Set([1,2,3,4,5,6,7,8,9,3,6,1,4,7])
>>> len(set)
9
>>> set.add(6)
>>> len(set)
9
>>> set2 = set.intersection([1,3,5,6])
>>> set2.elements
[1, 3, 5, 6]
\end{lstlisting}

%hash
\subsubsection*{hash}
\begin{verbatim}
  hash(string | number) -> number
\end{verbatim}
Retorna un valor de hash para el argumento dado, para los mismos argumentos se
teronran los mismos valores de hash.

\subsubsection*{id}
\begin{verbatim}
  id(value) -> number
\end{verbatim}
Asigna y retorna un identificador unico para el valor pasado como argumento.
Al pasar un valor que sea de tipo objeto la funcion id modificara la
estructura interna agregando el atributo __hash__ para ``etiquetar''
el objeto y en posteriores llamadas retornara el mismo identificador.

%getattr
\subsubsection*{getattr}
\begin{verbatim}
  getattr(object, name, default) -> value
\end{verbatim}
Obtiene un atributo de un objeto mediante su nombre, en caso de pasar un valor
por defecto este es retornado si el atributo buscado no esta definido en el
objeto, en caso contrario una excepcion es lanzada.

%setattr
\subsubsection*{setattr}
\begin{verbatim}
  setattr(object, name, value)
\end{verbatim}
Establece un atributo en un objeto con el nombre pasado. El valor establecido
pasa a formar parte del objeto.

%hasattr
\subsubsection*{hasattr}
\begin{verbatim}
  hasattr(object, name) -> boolean
\end{verbatim}
Retrona verdadero en caso de que el objeto tenga un atributo con el nombre
correspondiente, falso en caso contrario.

%assert
\subsubsection*{assert}
\begin{verbatim}
  assert(boolean, mesage)
\end{verbatim}
Chequea que el valor de verdad pasado sea verdadero en caso contrario retorna
una excepcion conteniendo el mensaje pasado.

%bool
\subsubsection*{bool}
\begin{verbatim}
  bool(object)
\end{verbatim}
Determina el valor de verdad de un objeto pasado, los valores de verdad son como
sigue: arreglos, objetos y cadenas vacias en conjunto con los valores null y
undefined son falsos; todos los demas casos son verdaderos.
En el caso particular de que un objeto defina el metodo __nonzero__ este es
invocado para determinar el valor de verdad.

%callable
\subsubsection*{callable}
\begin{verbatim}
  callable(value) -> boolean
\end{verbatim}
Retorna verdadero en caso de que el valor pasado sea instancia de una funcion
osea pueda ser llamado, falso en caso contrario.

%chr
\subsubsection*{chr}
\begin{verbatim}
  chr(number) -> character
\end{verbatim}
Retorna el caracter correspondiente al numero ordinal pasado.

%ord
\subsubsection*{ord}
\begin{verbatim}
  ord(character) -> number
\end{verbatim}
Retorna un numero correspondiente al caracter pasado.
\begin{lstlisting}[style=consola]
>>> ord(chr(65))
65
>>> chr(ord("A"))
"A"
\end{lstlisting}

\subsubsection*{bisect}
bisect(seq, element) \rightarrow position
\begin{lstlisting}[style=consola]
>>> a = [1,2,3,4,5]
>>> bisect(a,6)
5
>>> bisect(a,2)
2
>>> a[bisect(a,3)] = 3
>>> a
[1, 2, 3, 3, 5]
\end{lstlisting}

%equal
\subsubsection*{equal}
\begin{verbatim}
  equal(object1, object2) -> boolean
\end{verbatim}
Compara dos objetos determinando el valor de igual para los mismos, verdadero es
retornado en caso de ser los dos objetos iguales.
En caso de que object1 implemente el metodo __eq__ este es invocado con object2
pasado como parametro.

%nequal
\subsubsection*{nequal}
\begin{verbatim}
  nequal(object, object) -> boolean
\end{verbatim}
Compara dos objetos determinando el valor de igual para los mismos, verdadero es
retornado en caso de ser los dos objetos distintos.
En caso de que object1 implemente el metodo __ne__ este es invocado con object2
pasado como parametro.

%number
\subsubsection*{number}
\begin{verbatim}
  number(object) -> number
\end{verbatim}

\subsubsection*{flatten}
flatten(destiny, source) \rightarrow alteredDestiny

%include
\subsubsection*{include}
\begin{verbatim}
  include(object, element) -> boolean
\end{verbatim}
__contains__

%len
\subsubsection*{len}
\begin{verbatim}
  len(object) -> boolean
\end{verbatim}
__len__

\subsubsection*{array}
\begin{verbatim}
  array(iterable) -> [element...]
\end{verbatim}
__iter__

\subsubsection*{print}
print(destiny, source) \rightarrow alteredDestiny

\subsubsection*{string}
string(destiny, source) \rightarrow alteredDestiny
__str__

\subsubsection*{values}
\begin{verbatim}
  values(object) -> [value...]
\end{verbatim}
Retorna un arreglo con los valores del objeto pasado como argumento.

\subsubsection*{keys}
\begin{verbatim}
  keys(object) -> [key...]
\end{verbatim}
Retorna un arreglo con las claves del objeto pasado como argumento.

%items
\subsubsection*{items}
\begin{verbatim}
  items(object) -> [[key, value]...]
\end{verbatim}
Retorna en forma de arreglo cada pareja clave, valor de un objeto pasado como
argumento.
\begin{lstlisting}[style=consola]
>>> items({'perro': 1, 'gato': 7})
[["perro", 1], ["gato", 7]]
\end{lstlisting}

\subsubsection*{inspect}
\begin{verbatim}
  inspect(object) -> string
\end{verbatim}

%unique
\subsubsection*{unique}
\begin{verbatim}
  unique(array) -> [element...]
\end{verbatim}

%range
\subsubsection*{range}
\begin{verbatim}
  range([begin = 0, ] end[, step = 1]) -> [number...]
\end{verbatim}
Retorna un arreglo conteniendo una progresion aritmetica de numeros enteros.
Los parametros son variables y en su invocacion mas simple se pasa solo el final
de la secuencia de numeros a generar, asumiendo para ello un inicio en 0 y un
incremento en una unidad, estos valores pueden ser modificados.
\begin{lstlisting}[style=consola]
>>> range(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> range(4, 10)
[4, 5, 6, 7, 8, 9]
>>> range(4, 10, 2)
[4, 6, 8]
\end{lstlisting}

%xrange
\subsubsection*{xrange}
\begin{verbatim}
  xrange([begin = 0, ] end[, step = 1]) -> generator
\end{verbatim}
Similar a range pero en lugar de retornar un arrglo retorna un objeto que
generar los valores bajo demanda.

%zip
\subsubsection*{zip}
\begin{verbatim}
  zip(seq1 [, seq2 [...]]) \rightarrow [[seq1[0], seq2[0] ...], [...]]
\end{verbatim}
Retorna un arreglo en donde cada secuencia contenida es el resultado de combinar
cada una de las secuencias que se pasaron como argumento, la longitud de las
secuencias queda acotada a la longitud de la secuencia mas corta.
\begin{lstlisting}[style=consola]
>>> zip([1,2,3,4,5,6], ['a','b','c','d','e','f'])
[[1, "a"], [2, "b"], [3, "c"], [4, "d"], [5, "e"], [6, "f"]]
>>> zip([1,2,3,4,5,6], ['a','b','c','d','e','f','g','h'])
[[1, "a"], [2, "b"], [3, "c"], [4, "d"], [5, "e"], [6, "f"]]
>>> zip([1,2,3,4,5,6], ['a','b','c','d'])
[[1, "a"], [2, "b"], [3, "c"], [4, "d"], [5, undefined], [6, undefined]]
>>> zip([1,2,3,4,5,6], ['a','b','c','d','e','f'], [10,11,12,13,14,15,16])
[[1, "a", 10], [2, "b", 11], [3, "c", 12], [4, "d", 13], [5, "e", 14], [6, "f",
15]]
\end{lstlisting}

\subsection{sys}
Este modulo provee acceso a algunos objetos mantenidos por protopy y funciones
que resultan de utilidad para interactuar con el ambiente de ejecucion.
\subsubsection*{version}
Es la version de protopy.
\subsubsection*{browser}
Este objeto provee informacion sobre el navegador en el cual protopy se cargo.
\begin{itemize}
 \item{IE} Si el navegador es Internet Explorer.
 \item{Opera} Si el navegador es Opera.
 \item{WebKit} Si el navegador es AppleWebKit.
 \item{Geck} Si el navegador es Gecko.
 \item{MobileSafari} Si el navegador es Apple Mobile Safari.
 \item{fatures} Algunas herramientas que el navegador proveea, por ejemplo
XPath, un selector de css, y otras extensiones.
\end{itemize}

\subsubsection*{get\_gears}
Mediante esta funcion obtenemos el objeto gears para interactuar con el plugin
de google gears para el navegador.
\subsubsection*{register\_path}
Registra una ruta en el servidor para un paquete, de este modo, las imporaciones
de modulos dependientes de de ese paquete se realizaran sobre la ruta asociada. 
\subsubsection*{module\_url}
Retorna la ruta correspondiente al nombre de modulo pasado.
\subsubsection*{modules}
Un objeto para asociar los nombres de modulos con los modulos propiamente dicho
que se van cargando bajo demanda.
\subsubsection*{paths}
Las rutas registradas para la carga de modulos.

\subsection{exception}
Este modulo reune todas las excepciones que protopy provee a la hora de mostrar
errores, estas son:
Exception, AssertionError, AttributeError, LoadError, KeyError,
NotImplementedError, TypeError, ValueError.
El modulo de excepciones es cargado en el ambiente de trabajo cuando protopy
inicia, no siendo necesario su llamada posterior.

\subsection{event}
\subsubsection*{connect}
connect(object, event, context, method)
\subsubsection*{disconnect}
disconnect(handle)
\subsubsection*{subscribe}
subscribe(topic, context, method)
\subsubsection*{unsubscribe}
unsubscribe(handle)
\subsubsection*{publish}
publish(topic, args)
\subsubsection*{connectpublisher}
connectpublisher(topic, obj, event)
\subsubsection*{fixevent}
fixevent()
\subsubsection*{stopevent}
stopevent()
\subsubsection*{keys}
keys: { BACKSPACE: 8, TAB: 9, CLEAR: 12, ENTER: 13, SHIFT: 16, CTRL: 17, ALT:
18, PAUSE: 19, CAPS_LOCK: 20, 
		    ESCAPE: 27, SPACE: 32, PAGE_UP: 33, PAGE_DOWN: 34, END: 35,
HOME: 36, LEFT_ARROW: 37, UP_ARROW: 38,
		    RIGHT_ARROW: 39, DOWN_ARROW: 40, INSERT: 45, DELETE: 46,
HELP: 47, LEFT_WINDOW: 91, RIGHT_WINDOW: 92,
		    SELECT: 93, NUMPAD_0: 96, NUMPAD_1: 97, NUMPAD_2: 98,
NUMPAD_3: 99, NUMPAD_4: 100, NUMPAD_5: 101,
		    NUMPAD_6: 102, NUMPAD_7: 103, NUMPAD_8: 104, NUMPAD_9: 105,
NUMPAD_MULTIPLY: 106, NUMPAD_PLUS: 107,
		    NUMPAD_ENTER: 108, NUMPAD_MINUS: 109, NUMPAD_PERIOD: 110,
NUMPAD_DIVIDE: 111, F1: 112, F2: 113, F3: 114,
		    F4: 115, F5: 116, F6: 117, F7: 118, F8: 119, F9: 120, F10:
121, F11: 122, F12: 123, F13: 124, 
		    F14: 125, F15: 126, NUM_LOCK: 144, SCROLL_LOCK: 145 }
    });

\subsection{timer}
\subsubsection*{setTimeout}
setTimeout: window.setTimeout,
\subsubsection*{setInterval}
setInterval: window.setInterval,
\subsubsection*{clearTimeout}
clearTimeout: window.clearTimeout,
\subsubsection*{delay}
delay: function(f) {
\subsubsection*{defer}
defer: function(f) {

\subsection{ajax}
\subsubsection*{Request}
new Request()
\subsubsection*{Response}
new Response()
\subsubsection*{toQueryParams}
toQueryParams(string, separator) \rightarrow object
\subsubsection*{toQueryString}
toQueryString(params) \rightarrow string

\subsection{dom}
\subsubsection*{query}
\begin{verbatim}
  query(cssRule) -> [HTMLElement...]
\end{verbatim}

\section{Extendiendo Javascript}
Protopy no solo aporta modulos utiles para el trabjo de desarrollo, sino que
tambien extiende los objetos de javascript agregando funcionalidad a los mismos.
\subsection{String}
\subsubsection*{gsub}
gsub(pattern, replacement) \rightarrow string
\subsubsection*{sub}
sub(pattern, replacement[, count = 1]) \rightarrow string
\subsubsection*{subs}
subs(pattern, replacement) \rightarrow string
\subsubsection*{format}
format(pattern, replacement) \rightarrow string
\subsubsection*{inspect} 
inspect(use_double_quotes) \rightarrow string
\subsubsection*{truncate}
truncate(length, truncation) \rightarrow string
\subsubsection*{strip}
strip() \rightarrow string
\subsubsection*{striptags}
striptags() \rightarrow string
\subsubsection*{stripscripts}
stripscripts() \rightarrow string
\subsubsection*{extractscripts}
extractscripts() \rightarrow string
\subsubsection*{evalscripts}
evalscripts() \rightarrow string
\subsubsection*{escapeHTML}
escapeHTML() \rightarrow string
\subsubsection*{unescapeHTML}
unescapeHTML() \rightarrow string
\subsubsection*{succ}
succ() \rightarrow string
\subsubsection*{times}
times(count[, separator = '']) \rightarrow string
\subsubsection*{camelize}
camelize() \rightarrow string
\subsubsection*{capitalize}
capitalize() \rightarrow string
\subsubsection*{underscore}
underscore() \rightarrow string
\subsubsection*{dasherize}
dasherize() \rightarrow string
\subsubsection*{startswith}
\begin{verbatim}
  startswith(pattern) -> boolean
\end{verbatim}
Si la cadena de texto inicia con un patron.

\subsubsection*{endswith}
\begin{verbatim}
  endswith(pattern) -> boolean
\end{verbatim}
Si la cadena de texto termina con un patron.

\subsubsection*{blank}
\begin{verbatim}
  blank() -> boolean
\end{verbatim}
Valor de verdad asociado a si la cadena solo pose espacios osea esta en blanco.

\subsection{Number}
\subsubsection*{format}
format(f, radix) \rightarrow string

\subsection{Date}
\subsubsection*{toISO8601}
toISO8601() \rightarrow string

\subsection{Element}
\subsubsection*{visible}
visible()
\subsubsection*{toggle}
toggle()
\subsubsection*{hide}
hide()
\subsubsection*{show}
show()
\subsubsection*{remove}
remove()
\subsubsection*{update}
update(content)
\subsubsection*{insert}
insert(insertions)
\subsubsection*{select}
select(selector)

\begin{lstlisting}[style=consola]
>>> $('PostForm').select('input')
[input#id_title, input guardar]
>>> $('content').select('div')
[div.header, div.breadcrumbs, div.middle, div, div.right, div#clear]
>>> $('content').select('div.middle')
[div.middle]
\end{lstlisting}

\subsection{Forms}
\subsubsection*{disable}
disable()
\subsubsection*{enable}
enable()
\subsubsection*{serialize}
serialize() \rightarrow object
\begin{lstlisting}[style=consola]
>>> $('PostForm')
<form id="PostForm" method="post" onsubmit="return blog.handler.handle(this);"
action="/blog/add_post/">
>>> $('PostForm').serialize()
Object title=Hola mundo body=Este es un post tags=[1]
\end{lstlisting}

\subsection{Forms.Element}
\subsubsection*{serialize}
serialize()
\subsubsection*{get\_value}
get\_value()
\subsubsection*{set\_value}
set\_value(value) {
\subsubsection*{clear}
clear()
\subsubsection*{present}
present()
\subsubsection*{activate}
activate()
\subsubsection*{disable}
disable()
\subsubsection*{enable}
enable()