\chapter{Protopy}
Protopy es una librería en JavaScript que simplifica el desarrollo de
aplicaciones web dinámicas.
Agregando un enfoque modular para la inclusión de código, orientación a objetos,
soporte para AJAX, manipulación del DOM y eventos.

\section{Módulos}
Uno de los principales inconvenientes a los que protopy da solución es a la
inclusión dinámica de funcionalidad bajo demanda,
esto es logrado mediante los módulos.
Básicamente un modulo en un archivo con código javascript que recide en el
servidor y es obtenido y ejecutado en el cliente.

\begin{lstlisting}[style=javascript,label=estructura-modulo,caption=Estructura
de un modulo]
//Archivo: tests/module.js
require('event');

var h1 = $('titulo');

function set_texto(txt) {
    h1.update(txt);
}

function get_texto() {
    return h1.innerHTML;
}

event.connect($('titulo'), 'click', function(event) {
    alert('El texto es: ' + event.target.innerHTML);
});

publish({
    set_texto: set_texto,
    get_texto: get_texto
});
\end{lstlisting}

\begin{lstlisting}[style=consola]
>>> require('tests.module')
>>> module.get_texto()
"Test de modulo"
>>> module.set_texto('Un titulo')
>>> require('tests.module', 'get_texto')
>>> get_texto()
"Un titulo"
>>> require('tests.module', '*')
>>> set_texto('Hola luuu!!!')
>>> get_texto()
"Hola luuu!!!"
\end{lstlisting}

\section{Módulos incluidos en el núcleo de Protopy}
\subsection{builtin}
Este modulo contiene las funciones principales de Protopy, en el se encuentran
las herramientas basicas para relizar la mayoia de las tareas.
No es necesario requerir este modulo en el espacio de nombres principal
(``window''), ya que su funcionalidad esta disponible desde la carga de Protopy
en el mismo.

\paragraph{Funciones}
\subsubsection*{publish}
\begin{verbatim}
  publish(object)
\end{verbatim}
Publica la funcionalidad de un modulo.
Para interactuar con el codigo definido en un modulo es necesario
exponer una interface de acceso al mismo, de esto se encarga la funcion publish.

\subsubsection*{require}
\begin{verbatim}
  require(module[, object...]) -> module | object
\end{verbatim} 
Importa un modulo en el espacio de nombres.
Al invocar a esta funcion un modulo es cargado desde el servidor y ejecutado en
el clinete, la forma en que el modulo se presenta en el espacio de nombres
depende de la invoacion.
\begin{itemize}
 \item{var cntx = require('doff.template.context')}
  Importa el modulo 'doff.template.context' y lo retorna en cntx, dejando
tambien una referencia en el espacio de nombres llamda 'context', esta dualidad
en la asociacion del modulo permite imporatar modulos sin asociarlos a una
variable, simplemente alcanza con asumir que la parte final del nombre es la
referencia a usar.
 \item{var cur = require('gears.database', 'cursor')}
  Importa el modulo 'gears.databse' y retorna en cur el objeto publicado bajo el
nombre de cursor, similar al caso anterior una referencia se define en el
espacio de nombres para cursor.  
 \item{require('doff.db.models', 'model', 'query')}
  Importa el modulo 'doff.db.models' y define en el espacio de nombres las
referencias a model y query usando los mismos nombres.
 \item{require('doff.core.urlpattern', '*')}
  Importa del modulo 'doff.core.urlpattern' todos los objetos publicados y los
publica en el espacio de nombres.
\end{itemize}

\subsubsection*{type}
\begin{verbatim}
  type(name, [base...] [, class ], instance) -> Type
\end{verbatim} 
Funcion encargada de la construccion de nuevos tipos o clases.
Una vez definido un nuevo tipo este puede ser utilizado para la contruccion
indiscriminada de objetos de ese tipo mediante el operador new.
Como argumentos admite, el nombre del nuevo tipo, las bases de la cual hereda,
opcionalmente los atributos y metodos de clase y los atributos y metodos para la
instancia.

La funcion constructor de los objetos tiene por nombre __init__ y es disparada
en el momento de la construccion del objeto; en conjunto con otros metodos que
se mencionaran a lo largo del texto estas funciones resultan de especial interes
para interactuar con nuestros objetos y existen operadores en protopy para
manejarlas, esto es, no debieran ser invocadas o llamadas directamente.
\begin{lstlisting}[style=javascript,label=definicion-de-tipos,caption=Definicion
de tipos]
var Animal = type('Animal', object, {
    contador: 0,
}, {
    __init__: function(especie) {
	this.especie = especie;
	this.orden = Animal.contador++;
    }
});

var Terrestre = type('Terrestre', Animal, {
    caminar: function() {
	console.log(this.especie + ' caminando');
    }
});

var Acuatico = type('Acuatico', Animal, {
    nadar: function() {
	console.log(this.especie + ' nadando');
    }
});

var Anfibio = type('Anfibio', [Terrestre, Acuatico]);

var Piton = type('Piton', Terrestre, {
    __init__: function(nombre) {
	super(Terrestre, this).__init__(this.__name__);
	this.nombre = nombre;
    },
    caminar: function() {
	throw new Exception(this.especie + ' no camina');
    },
    reptar: function() {
	console.log(this.nombre + ' la ' + this.especie.toLowerCase() + ' esta
reptando');
    }
});

var doris = new Piton('Doris');
var ballena = new Acuatico('Ballena');
var rana = new Anfibio('Rana');
\end{lstlisting}
\begin{lstlisting}[style=consola]
>>> doris
window.Piton especie=Piton orden=0 nombre=Doris __name__=Piton
>>> rana
window.Anfibio especie=Rana orden=2 __name__=Anfibio
>>> isinstance(rana, Terrestre)
true
>>> isinstance(doris, Animal)
true
>>> issubclass(Anfibio, Acuatico)
true
>>> issubclass(Piton, Animal)
true
>>> doris.caminar()
Exception: Piton no camina args=[1] message=Piton no camina
>>> doris.reptar()
Doris la piton esta reptando
\end{lstlisting}

\subsubsection*{\$}
\begin{verbatim}
  $(id) -> HTMLElement
  $(id[, id...]) -> [HTMLElement...]
\end{verbatim}
Esta funcion recibe una cadena de texto y retorna un elemento del documento cuyo
id se corresponda con la cadena. En conjunto con la funcion \$\$ constituyen dos
herramientas muy utiles para recuperar elementos e interactuar con el arbol DOM.
Si mas de un argumento es pasado, la forma de retorno es mediante un arreglo,
permitiendo asi la iteracion sobre los mismos.
\begin{lstlisting}[style=consola]
>>> $('content')
<div id="content">
>>> $('content body')
>>> $('content', 'body')
[div#content, div#body]
>>> $('content', 'body', 'head')
[div#content, div#body, undefined]
\end{lstlisting}

\subsubsection*{\$\$}
\begin{verbatim}
  $$(cssRule) -> [HTMLElement...]
\end{verbatim}
Recupera elementos del documento, pero en lugar de hacerlo mediante un
identificador, lo realiza utilizando las reglas de css o hoja de estilos.
\begin{lstlisting}[style=consola]
>>> $$('div')
[div#wrap, div#top, div#content, div.header, div.breadcrumbs, div.middle, div,
div.right, div#clear, div#footer, div#toolbar]
>>> $$('div#toolbar')
[div#toolbar]
>>> $$('div#toolbar li')
[li, li.panel, li.panel, li, li]
>>> $$('div#toolbar li.panel')
[li.panel, li.panel]
>>> $$('a:not([href~=google])')
[a add_post, a add_tag, a removedb, a syncdb]
>>> $$('a:not([href=google])')
[a add_post, a add_tag, a#google www.google.com, a removedb, a syncdb]
>>> $$('div:empty')
[div#logger.panel, div#dbquery.panel, div#clear, div#top]
\end{lstlisting}

%extend
\subsubsection*{extend}
\begin{verbatim}
  extend(destiny, source) -> alteredDestiny
\end{verbatim}
Extiende sobre un objeto destino todos los objetos pasados como argumentos a
continuacion, copiando cada uno de los atributos correspondientes, el objeto
destino es retornado modificado.
\begin{lstlisting}[style=consola]
>>> a = {perro: 4}
>>> b = {gato: 4}
>>> c = extend(a, b)
>>> c
Object perro=4 gato=4
>>> a
Object perro=4 gato=4
>>> b
Object gato=4
\end{lstlisting}

%super
\subsubsection*{super}
\begin{verbatim}
  super(tipo, objeto) -> boundedObject
\end{verbatim}
Enlaza un objeto con un tipo de objeto, de este modo la invocacion sobre una
funcion del tipo se realizara sobre el objeto enlazado.
Normalemnte esta funcion es utilizada para llamar a metodos de un tipo base.

%isundefined
\subsubsection*{isundefined}
\begin{verbatim}
  isundefined(object) -> boolean
\end{verbatim}
Determina si un objeto no esta definido o asociado a un valor. Retorna un valor
de verdad correspondiente.

%isinstance
\subsubsection*{isinstance}
\begin{verbatim}
  isinstance(object, type | [type...]) -> boolean
\end{verbatim}
Retorna verdadero si el objeto es una instancia del tipo, si un arreglo de tipos
es pasado como segundo argumento el valor de verdad surge de preguntar por cada
uno de ellos.

%issubclass 
\subsubsection*{issubclass}
\begin{verbatim}
  issubclass(type1, type2 | [type...]) -> boolean
\end{verbatim}
Retorna si type1 es una subclase de type2, cuando se pasa un arrgelo en lugar de
type2 la evalucion se reliza para cada una de las clases incluidas en el mismo.

%Arguments
\subsubsection*{Arguments}
\begin{verbatim}
  new Arguments(arguments) -> Arguments
\end{verbatim}

\begin{lstlisting}[style=consola]
\end{lstlisting}

%Template
\subsubsection*{Template}
\begin{verbatim}
    new Template(destiny, source) -> Template
\end{verbatim}

\subsubsection*{Dict}
\begin{verbatim}
  new Dict(object) -> Dict
\end{verbatim}
\begin{lstlisting}[style=consola]
>>> dic = new Dict({'db': 5, 'template': 2, 'core': 9})
>>> obj = {'un': 'objeto'}
>>> dic.set(obj, 10)
>>> arreglo = [1,2,3,4,obj]
>>> dic.set(arreglo, 50)
>>> dic.get('template')
2
>>> dic.get(arreglo)
50
>>> dic.get(obj)
10
>>> dic.items()
[["db", 5], ["template", 2], ["core", 9], [Object un=objeto, 10], [[1, 2, 3, 2
more...], 50]]
>>> dic.keys()
["db", "template", "core", Object un=objeto, [1, 2, 3, 2 more...]]
>>> dic.values()
[5, 2, 9, 10, 50]
\end{lstlisting}

\subsubsection*{Set}
\begin{verbatim}
  new Set(array) -> Set
\end{verbatim}
Un set es una coleccion de elementos unicos, de forma similar a los conjuntos este objeto soporta intersecciones, uniones y otros metodos tipicos con sus elementos.
\begin{lstlisting}[style=consola]
>>> set = new Set([1,2,3,4,5,6,7,8,9,3,6,1,4,7])
>>> len(set)
9
>>> set.add(6)
>>> len(set)
9
>>> set2 = set.intersection([1,3,5,6])
>>> set2.elements
[1, 3, 5, 6]
\end{lstlisting}

%hash
\subsubsection*{hash}
\begin{verbatim}
  hash(string | number) -> number
\end{verbatim}
Retorna un valor de hash para el argumento dado, para los mismos argumentos se
teronran los mismos valores de hash.

\subsubsection*{id}
\begin{verbatim}
  id(value) -> number
\end{verbatim}
Asigna y retorna un identificador unico para el valor pasado como argumento.
Al pasar un valor que sea de tipo objeto la funcion id modificara la
estructura interna agregando el atributo __hash__ para ``etiquetar''
el objeto y en posteriores llamadas retornara el mismo identificador.

%getattr
\subsubsection*{getattr}
\begin{verbatim}
  getattr(object, name, default) -> value
\end{verbatim}
Obtiene un atributo de un objeto mediante su nombre, en caso de pasar un valor
por defecto este es retornado si el atributo buscado no esta definido en el
objeto, en caso contrario una excepcion es lanzada.

%setattr
\subsubsection*{setattr}
\begin{verbatim}
  setattr(object, name, value)
\end{verbatim}
Establece un atributo en un objeto con el nombre pasado. El valor establecido
pasa a formar parte del objeto.

%hasattr
\subsubsection*{hasattr}
\begin{verbatim}
  hasattr(object, name) -> boolean
\end{verbatim}
Retrona verdadero en caso de que el objeto tenga un atributo con el nombre
correspondiente, falso en caso contrario.

%assert
\subsubsection*{assert}
\begin{verbatim}
  assert(boolean, mesage)
\end{verbatim}
Chequea que el valor de verdad pasado sea verdadero en caso contrario retorna
una excepcion conteniendo el mensaje pasado.

%bool
\subsubsection*{bool}
\begin{verbatim}
  bool(object)
\end{verbatim}
Determina el valor de verdad de un objeto pasado, los valores de verdad son como
sigue: arreglos, objetos y cadenas vacias en conjunto con los valores null y
undefined son falsos; todos los demas casos son verdaderos.
En el caso particular de que un objeto defina el metodo __nonzero__ este es
invocado para determinar el valor de verdad.

%callable
\subsubsection*{callable}
\begin{verbatim}
  callable(value) -> boolean
\end{verbatim}
Retorna verdadero en caso de que el valor pasado sea instancia de una funcion
osea pueda ser llamado, falso en caso contrario.

%chr
\subsubsection*{chr}
\begin{verbatim}
  chr(number) -> character
\end{verbatim}
Retorna el caracter correspondiente al numero ordinal pasado.

%ord
\subsubsection*{ord}
\begin{verbatim}
  ord(character) -> number
\end{verbatim}
Retorna un numero correspondiente al caracter pasado.
\begin{lstlisting}[style=consola]
>>> ord(chr(65))
65
>>> chr(ord("A"))
"A"
\end{lstlisting}

\subsubsection*{bisect}
\begin{verbatim}
  bisect(seq, element) -> position
\end{verbatim}
Dada una secuencia ordenada y un elemento la funcion bisect retorna un numero referenciando a la posicion en que el elemnto debe ser insertado en la secuencia, para que esta conseve su orden.
Si los elementos de la secuencia definen el metodo ``__cmp__'' este es invocado para determinar la posicion a retornar.
\begin{lstlisting}[style=consola]
>>> a = [1,2,3,4,5]
>>> bisect(a,6)
5
>>> bisect(a,2)
2
>>> a[bisect(a,3)] = 3
>>> a
[1, 2, 3, 3, 5]
\end{lstlisting}

%equal
\subsubsection*{equal}
\begin{verbatim}
  equal(object1, object2) -> boolean
\end{verbatim}
Compara dos objetos determinando el valor de igual para los mismos, verdadero es
retornado en caso de ser los dos objetos iguales.
En caso de que object1 defina el metodo ``__eq__'' este es invocado con object2
pasado como parametro para determinar la igualdad.

%nequal
\subsubsection*{nequal}
\begin{verbatim}
  nequal(object, object) -> boolean
\end{verbatim}
Compara dos objetos determinando el valor de igual para los mismos, verdadero es
retornado en caso de ser los dos objetos distintos.
En caso de que object1 defina el metodo ``__ne__'' este es invocado con object2
pasado como parametro para determinar la no igualdad.

%number
\subsubsection*{number}
\begin{verbatim}
  number(object) -> number
\end{verbatim}
Convierte un objeto a su representacion numerica.

\subsubsection*{flatten}
\begin{verbatim}
  flatten(array) -> flattenArray
\end{verbatim}
Aplana un arreglo de modo que el resultado sea un unico arreglo conteniendo todos los elementos que se pasaron en multiples arreglos a la funcion.

%include
\subsubsection*{include}
\begin{verbatim}
  include(object, element) -> boolean
\end{verbatim}
__contains__

%len
\subsubsection*{len}
\begin{verbatim}
  len(object) -> boolean
\end{verbatim}
__len__

\subsubsection*{array}
\begin{verbatim}
  array(iterable) -> [element...]
\end{verbatim}
__iter__

\subsubsection*{print}
\begin{verbatim}
  print(text...)
\end{verbatim}
Si la consola de firebug esta instalada este metodo imprime el texto pasado por consola.

\subsubsection*{string}
\begin{verbatim}
  string(object)
\end{verbatim}
Retorna una reprecentacion en texto del objeto pasado como argumento.
Si el objeto define el metodo ``__str__'' este es invocado para obtener la reprecentacion.

\subsubsection*{values}
\begin{verbatim}
  values(object) -> [value...]
\end{verbatim}
Retorna un arreglo con los valores del objeto pasado como argumento.

\subsubsection*{keys}
\begin{verbatim}
  keys(object) -> [key...]
\end{verbatim}
Retorna un arreglo con las claves del objeto pasado como argumento.

%items
\subsubsection*{items}
\begin{verbatim}
  items(object) -> [[key, value]...]
\end{verbatim}
Retorna en forma de arreglo cada pareja clave, valor de un objeto pasado como
argumento.
\begin{lstlisting}[style=consola]
>>> items({'perro': 1, 'gato': 7})
[["perro", 1], ["gato", 7]]
\end{lstlisting}

\subsubsection*{inspect}
\begin{verbatim}
  inspect(object) -> string
\end{verbatim}

%unique
\subsubsection*{unique}
\begin{verbatim}
  unique(array) -> [element...]
\end{verbatim}
Dado un arreglo con elementos repetidos retorna un nuevo arreglo que se compone de los elementos unicos encontrados.

%range
\subsubsection*{range}
\begin{verbatim}
  range([begin = 0, ] end[, step = 1]) -> [number...]
\end{verbatim}
Retorna un arreglo conteniendo una progresion aritmetica de numeros enteros.
Los parametros son variables y en su invocacion mas simple se pasa solo el final
de la secuencia de numeros a generar, asumiendo para ello un inicio en 0 y un
incremento en una unidad, estos valores pueden ser modificados.
\begin{lstlisting}[style=consola]
>>> range(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> range(4, 10)
[4, 5, 6, 7, 8, 9]
>>> range(4, 10, 2)
[4, 6, 8]
\end{lstlisting}

%xrange
\subsubsection*{xrange}
\begin{verbatim}
  xrange([begin = 0, ] end[, step = 1]) -> generator
\end{verbatim}
Similar a range pero en lugar de retornar un arrglo retorna un objeto que
generar los valores bajo demanda.

%zip
\subsubsection*{zip}
\begin{verbatim}
  zip(seq1 [, seq2 [...]]) \rightarrow [[seq1[0], seq2[0] ...], [...]]
\end{verbatim}
Retorna un arreglo en donde cada secuencia contenida es el resultado de combinar
cada una de las secuencias que se pasaron como argumento, la longitud de las
secuencias queda acotada a la longitud de la secuencia mas corta.
\begin{lstlisting}[style=consola]
>>> zip([1,2,3,4,5,6], ['a','b','c','d','e','f'])
[[1, "a"], [2, "b"], [3, "c"], [4, "d"], [5, "e"], [6, "f"]]
>>> zip([1,2,3,4,5,6], ['a','b','c','d','e','f','g','h'])
[[1, "a"], [2, "b"], [3, "c"], [4, "d"], [5, "e"], [6, "f"]]
>>> zip([1,2,3,4,5,6], ['a','b','c','d'])
[[1, "a"], [2, "b"], [3, "c"], [4, "d"], [5, undefined], [6, undefined]]
>>> zip([1,2,3,4,5,6], ['a','b','c','d','e','f'], [10,11,12,13,14,15,16])
[[1, "a", 10], [2, "b", 11], [3, "c", 12], [4, "d", 13], [5, "e", 14], [6, "f",
15]]
\end{lstlisting}

\subsection{sys}
Este modulo provee acceso a algunos objetos mantenidos por protopy y funciones
que resultan de utilidad para interactuar con el ambiente de ejecucion.
\subsubsection*{version}
Es la version de protopy.
\subsubsection*{browser}
Este objeto provee informacion sobre el navegador en el cual protopy se cargo.
\begin{itemize}
 \item{IE} Si el navegador es Internet Explorer.
 \item{Opera} Si el navegador es Opera.
 \item{WebKit} Si el navegador es AppleWebKit.
 \item{Geck} Si el navegador es Gecko.
 \item{MobileSafari} Si el navegador es Apple Mobile Safari.
 \item{fatures} Algunas herramientas que el navegador proveea, por ejemplo
XPath, un selector de css, y otras extensiones.
\end{itemize}

\subsubsection*{get\_gears}
Mediante esta funcion obtenemos el objeto gears para interactuar con el plugin
de google gears para el navegador.
\subsubsection*{register\_path}
Registra una ruta en el servidor para un paquete, de este modo, las imporaciones
de modulos dependientes de de ese paquete se realizaran sobre la ruta asociada. 
\subsubsection*{module\_url}
Retorna la ruta correspondiente al nombre de modulo pasado.
\subsubsection*{modules}
Un objeto para asociar los nombres de modulos con los modulos propiamente dicho
que se van cargando bajo demanda.
\subsubsection*{paths}
Las rutas registradas para la carga de modulos.

\subsection{exception}
Este modulo reune todas las excepciones que Protopy provee a la hora de mostrar
errores.
\paragraph{Excepciones}
Exception, AssertionError, AttributeError, LoadError, KeyError,
NotImplementedError, TypeError, ValueError.
El modulo de excepciones es cargado en el ambiente de trabajo cuando protopy
inicia, no siendo necesario su llamada posterior.

\subsection{event}
Este es el modulo encargado de encapsular la logica de eventos requerida tanto por los elementos del DOM como la de usuario.

\paragraph{Funciones}
\subsubsection*{connect}
\begin{verbatim}
  connect(object, event, context, method) -> handle
\end{verbatim}

\subsubsection*{disconnect}
\begin{verbatim}
  disconnect(handle)
\end{verbatim}

\subsubsection*{subscribe}
\begin{verbatim}
  subscribe(topic, context, method) -> handle
\end{verbatim}

\subsubsection*{unsubscribe}
\begin{verbatim}
  unsubscribe(handle)
\end{verbatim}

\subsubsection*{publish}
\begin{verbatim}
  publish(topic, args)
\end{verbatim}

\subsubsection*{connectpublisher}
\begin{verbatim}
  connectpublisher(topic, obj, event)
\end{verbatim}

\subsubsection*{fixevent}
\begin{verbatim}
  fixevent()
\end{verbatim}

\subsubsection*{stopevent}
\begin{verbatim}
  stopevent()
\end{verbatim}

\subsubsection*{keys}
Objeto que encapsula los codigos de las teclas de funcion y control.

\subsection{timer}

\paragraph{Funciones}
\subsubsection*{setTimeout}
setTimeout: window.setTimeout,
\subsubsection*{setInterval}
setInterval: window.setInterval,
\subsubsection*{clearTimeout}
clearTimeout: window.clearTimeout,
\subsubsection*{delay}
delay: function(f) {
\subsubsection*{defer}
defer: function(f) {

\subsection{ajax}
Este modulo contiene funcionalidad propia del ajax, para el manejo de peticiones asincronicas al servidor.
\paragraph{Funciones}
\subsubsection*{Request}
\begin{verbatim}
  stopevent()
\end{verbatim}
new Request()
\subsubsection*{Response}
\begin{verbatim}
  stopevent()
\end{verbatim}
new Response()
\subsubsection*{toQueryParams}
\begin{verbatim}
  stopevent()
\end{verbatim}
toQueryParams(string, separator) \rightarrow object
\subsubsection*{toQueryString}
\begin{verbatim}
  stopevent()
\end{verbatim}
toQueryString(params) \rightarrow string

\subsection{dom}
Este modulo brinda el soporte para el manejo del DOM de una forma simple para el usuario.
\paragraph{Funciones}
\subsubsection*{query}
\begin{verbatim}
  query(cssRule) -> [HTMLElement...]
\end{verbatim}

\section{Extendiendo Javascript}
Protopy no solo aporta modulos utiles para el trabjo de desarrollo, sino que
tambien extiende los objetos de javascript agregando funcionalidad a los mismos.
\subsection{String}
\subsubsection*{gsub}
gsub(pattern, replacement) \rightarrow string
\subsubsection*{sub}
sub(pattern, replacement[, count = 1]) \rightarrow string
\subsubsection*{subs}
subs(pattern, replacement) \rightarrow string
\subsubsection*{format}
format(pattern, replacement) \rightarrow string
\subsubsection*{inspect} 
inspect(use_double_quotes) \rightarrow string
\subsubsection*{truncate}
truncate(length, truncation) \rightarrow string
\subsubsection*{strip}
strip() \rightarrow string
\subsubsection*{striptags}
striptags() \rightarrow string
\subsubsection*{stripscripts}
stripscripts() \rightarrow string
\subsubsection*{extractscripts}
extractscripts() \rightarrow string
\subsubsection*{evalscripts}
evalscripts() \rightarrow string
\subsubsection*{escapeHTML}
escapeHTML() \rightarrow string
\subsubsection*{unescapeHTML}
unescapeHTML() \rightarrow string
\subsubsection*{succ}
succ() \rightarrow string
\subsubsection*{times}
times(count[, separator = '']) \rightarrow string
\subsubsection*{camelize}
camelize() \rightarrow string
\subsubsection*{capitalize}
capitalize() \rightarrow string
\subsubsection*{underscore}
underscore() \rightarrow string
\subsubsection*{dasherize}
dasherize() \rightarrow string
\subsubsection*{startswith}
\begin{verbatim}
  startswith(pattern) -> boolean
\end{verbatim}
Si la cadena de texto inicia con un patron.

\subsubsection*{endswith}
\begin{verbatim}
  endswith(pattern) -> boolean
\end{verbatim}
Si la cadena de texto termina con un patron.

\subsubsection*{blank}
\begin{verbatim}
  blank() -> boolean
\end{verbatim}
Valor de verdad asociado a si la cadena solo pose espacios osea esta en blanco.

\subsection{Number}
\subsubsection*{format}
format(f, radix) \rightarrow string

\subsection{Date}
\subsubsection*{toISO8601}
toISO8601() \rightarrow string

\subsection{Element}
\subsubsection*{visible}
visible()
\subsubsection*{toggle}
toggle()
\subsubsection*{hide}
hide()
\subsubsection*{show}
show()
\subsubsection*{remove}
remove()
\subsubsection*{update}
update(content)
\subsubsection*{insert}
insert(insertions)
\subsubsection*{select}
select(selector)

\begin{lstlisting}[style=consola]
>>> $('PostForm').select('input')
[input#id_title, input guardar]
>>> $('content').select('div')
[div.header, div.breadcrumbs, div.middle, div, div.right, div#clear]
>>> $('content').select('div.middle')
[div.middle]
\end{lstlisting}

\subsection{Forms}
\subsubsection*{disable}
disable()
\subsubsection*{enable}
enable()
\subsubsection*{serialize}
serialize() \rightarrow object
\begin{lstlisting}[style=consola]
>>> $('PostForm')
<form id="PostForm" method="post" onsubmit="return blog.handler.handle(this);"
action="/blog/add_post/">
>>> $('PostForm').serialize()
Object title=Hola mundo body=Este es un post tags=[1]
\end{lstlisting}

\subsection{Forms.Element}
\subsubsection*{serialize}
serialize()
\subsubsection*{get\_value}
get\_value()
\subsubsection*{set\_value}
set\_value(value) {
\subsubsection*{clear}
clear()
\subsubsection*{present}
present()
\subsubsection*{activate}
activate()
\subsubsection*{disable}
disable()
\subsubsection*{enable}
enable()
