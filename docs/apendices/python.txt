=====================================
Referencia sobre el lenguaje Python
=====================================

Modularidad
-----------

Ámbito de nombres
~~~~~~~~~~~~~~~~~

**TODO**

.. _apendice-python-filosofia:

Filosofía del lenguaje
~~~~~~~~~~~~~~~~~~~~~~

El código que sigue los principios de Python de legibilidad y transparencia se 
dice que es *pythonico*. Contrariamente, el código opaco u ofuscado es bautizado 
como *no pythonico* (*unpythonic* en inglés). Estos principios fueron famosamente 
descritos por el desarrollador de Python Tim Peters en **El Zen de Python**.

	#. Bello es mejor que feo.
  
	#. Explícito es mejor que implícito.
  
	#. Simple es mejor que complejo.
  
	#. Complejo es mejor que complicado.
  
	#. Plano es mejor que anidado.
  
	#. Ralo es mejor que denso.
  
	#. La legibilidad cuenta.
  
 	#. Los casos especiales no son tan especiales como para quebrantar las reglas.
  
		* Aunque lo práctico gana a la pureza.
    
	#. Los errores nunca deberían dejarse pasar silenciosamente.
    
		* A menos que hayan sido silenciados explícitamente.
  
	#. Frente a la ambigüedad, rechaza la tentación de adivinar.
  
	#. Debería haber una *-y preferiblemente sólo una-* manera obvia de hacerlo.
   
		* Aunque esa manera puede no ser obvia al principio a menos que usted sea Holandés
  
  
	#. Ahora es mejor que nunca
  
		* Aunque nunca es a menudo mejor que ya
  
	#. Si la implementación es dificil de explicar, es una mala idea.
	
	#. Si la implementacion es fácil de explicar, puede que sea una buena idea
  
	#. Los espacios de nombres (namespaces) son una gran idea ¡Hagamos más de esas cosas!


Desde la versión 2.1.2, Python incluye estos puntos (en su versión original en
inglés) 
como un huevo de pascua que se muestra al ejecutar

.. code-block:: python

	import this

Ámbito de nombres
~~~~~~~~~~~~~~~~~

.. note:: O espacio de nombres
	
Cuando se ejecuta el intérprete de Python de forma interactiva o
cuando se invocama para ejecutar un script, están diponibles un conjuto de funciones,
clases, tipos de excepciones. El conjunto de estos nombres se conoce como ámbito de
nombres __builtin__ (*incorporado*) y en este encontramos: int(), char(),
str(), object, Exception, TypeError, ValueError, True, False, range, 
map, zip, locals, globals, entre otras.

Pueden verse en el interprete interactivo mediante

.. code-block:: python

	>>> dir(__builtins__)


Un *ámbito de nombres* o *espacio de nombres* en Python es un mapeo de nombres a objetos. La
mayoría de los ámbitos de nombres están implementados mediante diccionarios, but that's
normally not noticeable in any
way (except for performance), y podría cambiar en el futuro. Otros ejemplos de
ámbitos de nombre son los nombres globales en un módulo; 
los valores locales en la invocación de una función y en cierta forma, 
los atributos de un objeto también forman un ámbito de nombres.
Es importante tener en cuenta que no existe ninguna relación entre nombres de
diferentes ámbitos de nobres. 

Un *módulo* es un archivo con definiciones y sentencias en Python.
El conjunto de todas las sentencias que no están indentadas, forman el ámbito de
nombres global del modulo,
las funciones, variables y clases que están suelen decirse que estan a *nivel
módulo*. Los elementos que pueden
ser parete del ámbito de nombres del módulo son:

	* una definición de una función
	* una vairable
	* una expresión lambda
	* el nombre de otro módulo importado

Un número, el llamado a función o el lanzado de una excepción no alteran el
ámbito de nombres.
Un módulo puede ser cargado desde el intérprete interactivo en el ámbito de
nombres global
o desde otro módulo (en su propio espacio de nombres) a través de 
la sentencia *import*

.. code-block:: python

	import os

En este caso, el intérprete buscará secuencialmente en el PYTHONPATH un módulo
llamado **os**, en caso de encontrarlo, lo cargará y en el ámbito de nombres 
actual generará una referencia con el 
nombre *os*. A esta actividad se la llama importación y el interprete
garantiza que un módulo se cargará de unicamente una sola vez, en otras palabras, 
existe una única instancia de un módulo.
En este caso, si varios módulos importan a *os*, solo la primer ocurrencia
realiza la importación efetiva.
El resto de las sentencias import solamente generan referencias a la primera
*instancia* de un módulo.

La sentencia *import* permite a su vez hacer una importación selectiva de símbolos
de un módulo, por ejemplo:

.. code-block:: python

	from os import path

En este caso, import crea la instancia del módulo en la máquina virtual, pero no
expone todo el contenido
al ámbito de nombres local, sino que únicamente genera una referencia al símbolo
*path*

El comodín ``*`` permite importar todos los símbolos definidos en un módulo
al espacio de nombres local.

.. code-block:: python

	from os import *


Está técnica debe ser utilizada con cuidado, debido a que "contamina" el
ámbito de nombres local. Para mitigar este problma, puede definirse una variable 
*__all__* al comienzo del archivo, con una tupla en la cual se definen los 
símbolos que se desean exportar. Suponendo que el siguiente código se encuentra
en el módulo promedio:

.. code-block:: python

	__all__ = ('calcular_promedio', )
	
	def calular_promedio(numeros):
	    return suma (numeros) / len( numeros )
	def suma(lista):
	    return float( sum( lista ) ) 


Al realizar
.. code-block:: python

	from promedio import *


El único símbolo que encontraremos en nuestro espacio de nombres será,
*calcular_promedio*.

..	\subsection{Sobrecarga de operadores}
	
	\subsection{Funciones en Python}
	En python, una función se define de la sieguiente manera:
	\begin{lstlisting}[style=python]
	def funcion(argumento1, argumento2):
	  ''' Doc de la funcion '''
	  print argumento1, argumento2
	\end{lstlisting}
	Python soporta lo que se ha dadon en llamar \emph{empaquetado de argumentos }
	tanto en la 
	definición como en la invocación de una función.
	
	El empaquetado más simple es el del tipo lista, que consiste en la hablidad de
	una función de
	recibir argumentos variables en formato lista. Para usar esta caractrística es
	necesrio utilizar
	una signatura especial (agregando un asterisco).
	
	\begin{lstlisting}[style=python]
	def promedio(*lista):
	  ''' Calcula promedio '''
	  return sum(lista) / float(len(lista)) # utilizando 
						# varios builtins
	
	# Ejemplo de utilizacion
	>>> promedio(1, 2, 4, 5, 5)
	3.3999999999999999
	
	\end{lstlisting}
	Esta signatura de argumentos se puede combinar con argumentos posicionales.
	\begin{lstlisting}[style=python]
	def dividir_suma_por( numero, *lista ):
	  return sum(lista) / numero
	\end{lstlisting}
	La capiacidad de recibir listas puede ser utilizada a la inversa. Es decir,
	conociendo que una función
	recibe una cantidad de argumentos, ``acomodar'' en una lista los argumentos que
	se desean utilizar.
	\begin{lstlisting}[style=python]
	# Utilizanodo la funcion promedio anterior
	>>> lista = [1, 2, 4, 6, 7]
	>>> promedio( *lista )
	4.0
	\end{lstlisting}





Módulos
~~~~~~~
Un módulo en Python es un archivo con código python. Usualmente con la extensión .py.
Un módulo puede ser importado en el ámbito de nombres local mediante la sentecia **import**.

Por ejemplo, consideremos el módulo ***funciones.py***

.. code-block:: python
	
	# coding: utf-8
	
	def media(lista):
		return float(sum(lista)) / len(lista)
	
	def media_geo(lista):
		# La raíz puede expresarse como potencia > 1
		return reduce(lambda x, y: x*y, lista) ** 1.0/len(lista)

Para importar el módulo al ámbito de nombres local se puede utilizar la sentencia **import**.


.. code-block:: python

	>>> import funciones 
	>>> dir(funciones)
	

Paquete
~~~~~~~
Un paquete es una colección de uno o más módulos, contenidos en una directorio. Para que un directorio
sea tratado como paquete debe crearse un módulo con el nombre __init__.py.

El módulo __init__ puede contener código que será evaluado si se realiza una import con el nombre del paquete
como argumento, o si se realiza la importación de todos los símbolos:

.. code-block:: python
	
	from mi_paquete import * # Se evalua __init__.py
	 

Módulo de expresiones regulares "re"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

El módulo de expresiones regulares de Python permite recuperar gurpos nombrados.

.. code-block:: python

	r'persona/(?P<nombre>\w+)/(?P<edad>\d{2,3})'
	
En la expresión regular anterior se pueden recuperar el grupo **nombre**, que es un gurpo de
uno o más letras, y el grupo **edad**, que es un entero de 2 o 3 cifras.

.. code-block:: python
	
	>>> import re
	>>> expresion = re.compile(r'persona/(?P<nombre>\w+)/(?P<edad>\d{2,3})')
	>>> match = expresion.search('persona/nahuel/25')
	>>> match.group('nombre')
	'nahuel'
	>>> match.group('edad')
	'25'
	
Metaprogramación mediante metaclases
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Se puede definir la estructura de una clase mediante otra clase que herede de type.


.. _apendice_python_callables:

Objetos llamables o *callables*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Un objeto callable