#######
Protopy
#######

Protopy es una librería en JavaScript que simplifica el desarrollo de
aplicaciones web dinámicas. Basada en Python, aporta un enfoque modular para la inclusión de
código, orientación a objetos, soporte para AJAX, manipulación del DOM y eventos.

Módulos
=======

Uno de los principales inconvenientes a los que Protopy da solución es a la
inclusión dinámica de funcionalidad bajo demanda, esto se logra mediante los
módulos. Básicamente un modulo en un archivo con código JavaScript que reside
en el servidor y posteriormente es obtenido y ejecutado en el cliente.

.. code-block:: javascript

    //Archivo: tests/module.js
    require('event');

    var h1 = $('titulo');

    function set_texto(txt) {
        h1.update(txt);
    }

    function get_texto() {
        return h1.innerHTML;
    }

    event.connect($('titulo'), 'click', function(event) {
        alert('El texto es: ' + event.target.innerHTML);
    });

    publish({
        set_texto: set_texto,
        get_texto: get_texto
    });

.. code-block:: javascript

    >>> require('tests.module')
    >>> module.get_texto()
    "Test de modulo"
    >>> module.set_texto('Un titulo')
    >>> require('tests.module', 'get_texto')
    >>> get_texto()
    "Un titulo"
    >>> require('tests.module', '*')
    >>> set_texto('Hola luuu!!!')
    >>> get_texto()
    "Hola luuu!!!"

Módulos Nativos
---------------

Estos módulos están incluidos en el núcleo de Protopy, es decir que están
disponibles con la sola inclusión de la librería en el documento.
Los módulos que a continuación se detallan engloban las herramientas básicas
requeridas para el desarrollo del lado del cliente.

builtin
~~~~~~~

Este modulo contiene las funciones principales de Protopy, en el se encuentran
las herramientas básicas para realizar la mayoría de las tareas.
No es necesario requerir este modulo en el espacio de nombres global
(``window``), ya que su funcionalidad esta disponible desde la carga de Protopy
en el mismo.

    * publish(simbols: Object)

        Publica la funcionalidad de un modulo.
        Para interactuar con el código definido en un modulo es necesario exponer una
        interfase de acceso al mismo, de esto se encarga la función ``publish``.

    * require(module_name: String[, simbol: String...]) -> module: Object | simbol

        Importa un modulo en el espacio de nombres local.
        Al invocar a esta función un módulo es cargado desde el servidor y ejecutado en
        el cliente, la forma en que el módulo se presenta en el espacio de nombres
        depende de la invocación.

        * var cntx = require('doff.template.context')

            Importa el modulo ``doff.template.context`` y lo retorna en ``cntx``, dejando también una referencia
            en el espacio de nombres llamada ``context``, esta dualidad en la asociación del modulo permite importar
            módulos sin asociarlos a una variable, simplemente alcanza con asumir que la parte final del
            nombre es la referencia a usar.

        * var cur = require('gears.database', 'cursor')

            Importa el modulo ``gears.databse`` y retorna en ``cur`` el objeto publicado bajo el nombre de cursor,
            similar al caso anterior una referencia se define en el espacio de nombres para ``cursor``.

        * require('doff.db.models', 'model', 'query')

            Importa el modulo ``doff.db.models`` y define en el espacio de nombres las referencias a ``model`` y ``query``
            usando los mismos nombres.

        * require('doff.core.urlpattern', '*')

            Importa del modulo ``doff.core.urlpattern`` todos los símbolos exportados y los publica en el espacio de nombres.

    * type(name: String, [bases: Array ] [, class: Object ], instance: Object) -> Type

        Función encargada de la construcción de nuevos tipos de objeto o
        simplemente clases.
        Una vez definido un nuevo tipo este puede ser utilizado para la construcción
        de instancias mediante el operador "new".
        Los argumentos para la función ``type`` son, el nombre para el nuevo tipo de
        objeto, los tipos base de los cuales se hereda funcionalidad, opcionalmente los
        atributos y/o métodos de clase y los atributos y/o métodos para la instancia.
        El método que inicializa los objetos tiene por nombre ``__init__`` y es
        llamada en el momento de la instanciación de un objeto.

        Existen otros métodos “mágicos” que tienen un comportamiento especial al ser llamados por
        funciones especificas de Protopy, estas no debieran ser invocadas o llamadas directamente
        por el desarrollador y se verán a lo largo del apéndice sus nombres y las funciones del 
        núcleo que trabajan sobre ellas.

        .. code-block:: javascript

            var Animal = type('Animal', object, {
                contador: 0,
            }, {
                __init__: function(especie) {
                    this.especie = especie;
                    this.orden = Animal.contador++;
                }
            });

            var Terrestre = type('Terrestre', Animal, {
                caminar: function() {
                    console.log(this.especie + ' caminando');
                }
            });

            var Acuatico = type('Acuatico', Animal, {
                nadar: function() {
                    console.log(this.especie + ' nadando');
                }
            });

            var Anfibio = type('Anfibio', [Terrestre, Acuatico]);

            var Piton = type('Piton', Terrestre, {
                __init__: function(nombre) {
                    super(Terrestre, this).__init__(this.__name__);
                    this.nombre = nombre;
                },
                caminar: function() {
                    throw new Exception(this.especie + ' no camina');
                },
                reptar: function() {
                    console.log(this.nombre + ' la ' + this.especie.toLowerCase() + ' esta reptando');
                }
            });

            var doris = new Piton('Doris');
            var ballena = new Acuatico('Ballena');
            var rana = new Anfibio('Rana');

        .. code-block:: javascript

            >>> doris
            window.Piton especie=Piton orden=0 nombre=Doris __name__=Piton
            >>> rana
            window.Anfibio especie=Rana orden=2 __name__=Anfibio
            >>> isinstance(rana, Terrestre)
            true
            >>> isinstance(doris, Animal)
            true
            >>> issubclass(Anfibio, Acuatico)
            true
            >>> issubclass(Piton, Animal)
            true
            >>> doris.caminar()
            Exception: Piton no camina args=[1] message=Piton no camina
            >>> doris.reptar()
            Doris la piton esta reptando

    * $(id: String) -> HTMLElement

        Esta función recibe una cadena de texto y retorna el elemento del documento
        cuyo ``id'' se corresponda con la cadena. En conjunto con la función $$
        constituyen dos herramientas muy útiles para recuperar elementos e interactuar
        con el árbol DOM. Si más de un argumento es pasado, la forma de retorno es
        mediante un arreglo, permitiendo así la iteración sobre los mismos.

    .. code-block:: javascript

        >>> $('content')
        <div id="content">
        >>> $('content body')
        >>> $('content', 'body')
        [div#content, div#body]
        >>> $('content', 'body', 'head')
        [div#content, div#body, undefined]

    * $$(cssRule: String) -> [HTMLElement...]

        Recupera elementos del árbol DOM, basando las reglas de selección en los
        atributos de estilo o CSS.

    .. code-block:: javascript

        >>> $$('div')
        [div#wrap, div#top, div#content, div.header, div.breadcrumbs, div.middle, div,
        div.right, div#clear, div#footer, div#toolbar]
        >>> $$('div#toolbar')
        [div#toolbar]
        >>> $$('div#toolbar li')
        [li, li.panel, li.panel, li, li]
        >>> $$('div#toolbar li.panel')
        [li.panel, li.panel]
        >>> $$('a:not([href~=google])')
        [a add_post, a add_tag, a removedb, a syncdb]
        >>> $$('a:not([href=google])')
        [a add_post, a add_tag, a#google www.google.com, a removedb, a syncdb]
        >>> $$('div:empty')
        [div#logger.panel, div#dbquery.panel, div#clear, div#top]

    * extend(destiny: Object, source: Object) -> alteredDestiny: Object

        Extiende sobre un objeto destino todos los objetos pasados como argumentos a
        continuación, copiando cada uno de los atributos correspondientes, el objeto
        destino es retornado modificado.

    .. code-block:: javascript

        >>> a = {perro: 4}
        >>> b = {gato: 4}
        >>> c = extend(a, b)
        >>> c
        Object perro=4 gato=4
        >>> a
        Object perro=4 gato=4
        >>> b
        Object gato=4

    * super(type: Type, instance: Object) -> boundedObject: Object
    
        Asocia un objeto con un tipo de objeto, de este modo la invocación sobre una
        función del tipo se realizara sobre el objeto enlazado.
        Normalmente esta función es utilizada para llamar a métodos de un tipo base.
    
    * isundefined(object: Object) -> boolean
    
        Determina si un objeto no esta definido o asociado a un valor. Retorna un valor
        de verdad correspondiente.
    
    * isinstance(object, type | [type...]) -> boolean
    
        Retorna verdadero si el objeto es una instancia del tipo, si un arreglo de tipos
        es pasado como segundo argumento el valor de verdad surge de preguntar por cada
        uno de ellos.
    
    * issubclass(type1, type2 | [type...]) -> boolean
    
        Retorna si type1 es una subclase de type2, cuando se pasa un arreglo en lugar de
        type2 la evaluación se realiza para cada una de las clases incluidas en el mismo.
    
    * Arguments(arguments) -> Arguments
    
        La clase ``Argumentes`` tiene como objetivo agregar a JavaScript el empaquetado de argumentos.
        JavaScript soporta argumentos variables en las llamadas a función, internamente una funcion
        puede inspeccionar sus argumentos a través del objeto ``arguments``, Protopy ofrece esta clase
        como una forma uniforme de trabajar sobre el objeto ``arguments`` e incorporar atributos por
        defecto a las llamadas.

    .. code-block:: javascript

        function unaFuncion(arg1, arg2, arg3) { 
            var todos = new Arguments(arguments);
            print('Argumento 1: %s o %s o %s', arg1, todos[0], todos.arg1);
            print('Argumento 2: %s o %s o %s', arg2, todos[1], todos.arg2);
            print('Argumento 3: %s o %s o %s', arg3, todos[2], todos.arg3);
            print('Otros argumentos: %s', todos.args);
            print('Argumentos pasados por objeto: %o', todos.kwargs);
        }

        function otraFuncion(arg1) { 
            var todos = new Arguments(arguments, {'def1': 1, 'def2': 2});
            print('Argumento 1: %s o %s o %s', arg1, todos[0], todos.arg1);
            print('Otros argumentos: %s', todos.args);
            print('Argumentos pasados por objeto: %o', todos.kwargs);
        }

        >>> unaFuncion('uno', 2, null, 3, 4, 5, {'nombre': 'Diego', 'apellido': 'van Haaster'})
        Argumento 1: uno o uno o uno
        Argumento 2: 2 o 2 o 2
        Argumento 3: null o null o null
        Otros argumentos: 3,4,5
        Argumentos pasados por objeto: Object nombre=Diego apellido=van Haaster
        >>> unaFuncion('uno', 2, null, {'nombre': 'Diego', 'apellido': 'van Haaster'})

        Otros argumentos:
        Argumentos pasados por objeto: Object nombre=Diego apellido=van Haaster
        >>> unaFuncion('uno', 2, null, 3, 2, 3, 4)

        Otros argumentos: 3,2,3,4
        Argumentos pasados por objeto: Object
        >>> otraFuncion('uno', 2, {'nombre': 'Diego', 'apellido': 'van Haaster'})
        Argumento 1: uno o uno o uno
        Otros argumentos: 2
        Argumentos pasados por objeto: Object def1=1 def2=2 nombre=Diego apellido=van Haaster
        >>> otraFuncion('uno', 2, {'def1': 'Diego', 'apellido': 'van Haaster'})
        Argumento 1: uno o uno o uno
        Otros argumentos: 2
        Argumentos pasados por objeto: Object def1=Diego def2=2 apellido=van Haaster
    
    * Template(template, pattern) -> Template

        La clase ``Template`` es la encargada de interpretar cadenas de texto en función de una plantilla y valores.
        La plantilla debe contener etiquetas especificas relacionadas con el patrón de inspección pasado a la
        construcción, en una instancia posterior los objeto ``Template`` son evaluados y retornan una cadena de texto.  

    .. code-block:: javascript

        // Se crea un Template
       var myTemplate = new Template('El show televisivo #{title} fue creado por #{author}.');

       // los datos para dar formato al template
       var show = {
           title: 'The Simpsons',
           author: 'Matt Groening',
           network: 'FOX'
       };

       // Se evalúa el template
       >>> myTemplate.evaluate(show);
       "The TV show The Simpsons was created by Matt Groening.


    * Dict(object) -> Dict
        
       La clase ``Dict`` de manera similar a un diccionario de Python (``dict``), trabaja con
       duplas de la forma clave = valor, las instancias de esta clase soportan a objetos
       como claves en lugar de solo cadenas como ocurre en los arreglos asociativos de JavaScript.

    .. code-block:: javascript
    
        >>> dic = new Dict({'db': 5, 'template': 2, 'core': 9})
        >>> obj = {'un': 'objeto'}
        >>> dic.set(obj, 10)
        >>> arreglo = [1,2,3,4,obj]
        >>> dic.set(arreglo, 50)
        >>> dic.get('template')
        2
        >>> dic.get(arreglo)
        50
        >>> dic.get(obj)
        10
        >>> dic.items()
        [["db", 5], ["template", 2], ["core", 9], [Object un=objeto, 10], [[1, 2, 3, 2
        more...], 50]]
        >>> dic.keys()
        ["db", "template", "core", Object un=objeto, [1, 2, 3, 2 more...]]
        >>> dic.values()
        [5, 2, 9, 10, 50]

    * Set(array) -> Set

        Un set es una colección de elementos únicos, de forma similar a los conjuntos
        este objeto soporta intersecciones, uniones, restas, etc.

    .. code-block:: javascript

        >>> set = new Set([1,2,3,4,5,6,7,8,9,3,6,1,4,7])
        >>> len(set)
        9
        >>> set.add(6)
        >>> set)
        9
        >>> set2 = set.intersection([1,3,5,6])
        >>> set2.elements
        [1, 3, 5, 6]
    
    * hash(string | number) -> number
    
        Retorna un valor de ``hash`` para el argumento dado.
    
    * id(value) -> number
    
        Asigna y retorna un identificador único para el valor pasado como argumento.
        Al pasar un valor que sea de tipo arreglo asosciativo la función ``id`` modificara la
        estructura interna agregando el atributo ``__hash__`` para “etiquetar”
        el objeto y en posteriores llamadas retornara el mismo identificador.
    
    * getattr(object, name, default) -> value
    
        Obtiene un atributo de un objeto mediante su nombre, en caso de pasar un valor
        por defecto este es retornado si el atributo buscado no esta definido en el
        objeto, en caso contrario una excepción es lanzada.
    
    * setattr(object, name, value)
    
        Establece un atributo en un objeto con el nombre pasado. El valor establecido
        pasa a formar parte del objeto.
    
    * hasattr(object, name) -> boolean
    
        Retorna verdadero en caso de que el objeto tenga un atributo con el nombre
        correspondiente, falso en caso contrario.
    
    * assert(boolean, mesage)
    
        Evalua si el valor de verdad pasado es verdadero en caso contrario retorna
        una excepción conteniendo el mensaje pasado.
    
    * bool(object)
    
        Determina el valor de verdad de un objeto pasado, los valores de verdad son como
        sigue: arreglos, arreglos asociativos y cadenas vaciás en conjunto con los valores null y
        undefined son falsos; todos los demás casos son verdaderos.
        En el caso particular de que un objeto defina el método ``__nonzero__`` este
        es invocado para determinar el valor de verdad.
    
    * callable(value) -> boolean
    
        Retorna verdadero en caso de que el valor pasado sea instancia de una función
        osea pueda ser llamado, falso en caso contrario.
    
    * chr(number) -> character
    
        Retorna el carácter correspondiente al numero ordinal pasado.
    
    * cmp(object, object) -> number

         Compara la precedencia de dos objetos, retornando un valor numérico positivo, negativo o cero
         indicando mayor precedencia, menor precedencia o igualdad.
         Si el objeto define el método ``__cmp__`` la función se vale de este para determinar la precedencia de los objetos.

    * ord(character) -> number
    
        Retorna un numero correspondiente al carácter pasado.
    
    ::

        >>> ord(chr(65))
        65
        >>> chr(ord("A"))
        "A"
    
    * bisect(seq, element) -> position
    
        Dada una secuencia ordenada y un elemento la función ``bisect`` retorna el número
        correspondiente a la posición en que el elemento debe ser insertado en la
        secuencia, para que esta conserve su orden.
        Internamente esta función utiliza la función de comparación de Protopy.
    
    ::

        >>> a = [1,2,3,4,5]
        >>> bisect(a,6)
        5
        >>> bisect(a,2)
        2
        >>> a[bisect(a,3)] = 3
        >>> a
        [1, 2, 3, 3, 5]
    
    * equal(object1, object2) -> boolean
    
        Compara dos objetos determinando el valor de igual para los mismos, verdadero es
        retornado en caso de ser los dos objetos iguales.
        En caso de que object1 defina el método ``__eq__`` este es invocado con
        object2 pasado como parámetro para determinar la igualdad.
    
    * nequal(object1, object2) -> boolean
    
        Compara dos objetos determinando el valor de igual para los mismos, verdadero es
        retornado en caso de ser los dos objetos distintos.
        En caso de que object1 defina el método ``__ne__`` este es invocado con
        object2 pasado como parámetro para determinar la no igualdad.
    
    * number(object) -> number
    
        Convierte un objeto a su representación numérica.
    
    * flatten(array) -> flattenArray
    
        Aplana un arreglo de modo que el resultado sea un único arreglo conteniendo
        todos los elementos que se pasaron en múltiples arreglos a la función.
    
    * include(seq, element) -> boolean
    
        Determina si un elemento esta incluido en una secuencia o colección de objetos,
        si la colección implementa el método ``__contains__``, este es utilizado para
        determinar la pertenencia del elemento.
    
    * len(seq) -> boolean
    
        Retorna un valor numérico representando la cantidad de elementos contenidos en
        la secuencia o colección, si la colección implementa el método ``__len__``,
        este es utilizado para determinar la cantidad de elementos.
    
    * array(seq) -> [element...]
    
        Genera un arreglo en base a la secuencia pasada, si la secuencia implementa el
        método ``__iter__``, este es utilizado para llenar el arreglo con los
        elementos.
    
    * print(text...)
    
        Si la consola de Firebug esta instalada esta función imprime el texto pasado por
        consola.
    
    * string(object)
    
        Retorna una representación en texto del objeto pasado como argumento.
        Si el objeto define el método ``__str__`` este es invocado para obtener la
        representación.
    
    * values(object) -> [value...]
    
        Retorna un arreglo con los valores del objeto pasado como argumento.
    
    * keys(object) -> [key...]
    
        Retorna un arreglo con las claves del objeto pasado como argumento.
    
    * items(object) -> [[key, value]...]
    
        Retorna en forma de arreglo cada pareja clave, valor de un objeto pasado como
        argumento.
    
    ::

        >>> items({'perro': 1, 'gato': 7})
        [["perro", 1], ["gato", 7]]
    
    * unique(array) -> [element...]
    
        Dado un arreglo con elementos repetidos retorna un nuevo arreglo que se compone
        de los elementos únicos encontrados.
    
    * range([begin = 0, ] end[, step = 1]) -> [number...]
    
        Retorna un arreglo conteniendo una progresión aritmética de números enteros.
        Los parámetros son variables y en su invocación más simple se pasa solo el final
        de la secuencia de números a generar, asumiendo para ello un inicio en 0 y un
        incremento en una unidad, estos valores pueden ser modificados.
    
    ::

        >>> range(10)
        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        >>> range(4, 10)
        [4, 5, 6, 7, 8, 9]
        >>> range(4, 10, 2)
        [4, 6, 8]
    
    * xrange([begin = 0, ] end[, step = 1]) -> generator
    
        Similar a ``range`` pero en lugar de retornar un arreglo retorna un objeto que
        generar los valores bajo demanda.
    
    * zip(seq1 [, seq2 [...]]) -> [[seq1[0], seq2[0] ...], [...]]
    
        Retorna un arreglo en donde cada secuencia contenida es el resultado de combinar
        cada una de las secuencias que se pasaron como argumento, la longitud de las
        secuencias queda acotada a la longitud de la secuencia mas corta.

    ::

        >>> zip([1,2,3,4,5,6], ['a','b','c','d','e','f'])
        [[1, "a"], [2, "b"], [3, "c"], [4, "d"], [5, "e"], [6, "f"]]
        >>> zip([1,2,3,4,5,6], ['a','b','c','d','e','f','g','h'])
        [[1, "a"], [2, "b"], [3, "c"], [4, "d"], [5, "e"], [6, "f"]]
        >>> zip([1,2,3,4,5,6], ['a','b','c','d'])
        [[1, "a"], [2, "b"], [3, "c"], [4, "d"], [5, undefined], [6, undefined]]
        >>> zip([1,2,3,4,5,6], ['a','b','c','d','e','f'], [10,11,12,13,14,15,16])
        [[1, "a", 10], [2, "b", 11], [3, "c", 12], [4, "d", 13], [5, "e", 14], [6, "f",
        15]]

sys
~~~

Este módulo provee acceso a algunos objetos y funciones mantenidas por Protopy y
que resultan de utilidad para trabajar con el ambiente.

    * version

        Version de Protopy.
    
    * browser

        Este objeto provee información sobre el navegador en el cual Protopy se cargó.
        
            * IE Si el navegador es Internet Explorer.
            * Opera Si el navegador es Opera.
            * WebKit Si el navegador es AppleWebKit.
            * Geck Si el navegador es Gecko.
            * MobileSafari Si el navegador es Apple Mobile Safari.
            * fatures Algunas herramientas que el navegador proveea, por ejemplo
                XPath, un selector de css, y otras extensiones.
        
    * register_path(module, path)

        Registra una ruta en el servidor para un paquete, de este modo las importaciones
        de módulos dependientes de de ese paquete se realizaran sobre la ruta asociada. 
    
    * module_url(name, postfix) -> url

        Retorna la ruta correspondiente al nombre de modulo pasado.
    
    * modules

        Un objeto para asociar los nombres de módulos con los módulos propiamente dicho
        que se van cargando bajo demanda.
    
    * paths

        Las rutas registradas para la carga de módulos.

    * get_gears()

        Esta función retorna el objeto ``gears`` para construir los objetos de Google Gears.
        El objeto retornado presenta funciones para instalar Google Gears en caso de no estar
        presente en el navegador y administrar la construcción de los objetos del plug-in.
    
    * window, transport, document, history

        Los objetos que el navegador provee, el espacio global de nombres, el objeto para
        transporte asincrónico, documento e historial.

exception
~~~~~~~~~

Modulo que reúne todas las excepciones que Protopy provee a la hora de mostrar
errores, este modulo es cargado en el ambiente cuando Protopy inicia, no siendo
necesario su requerimiento posteriormente.

    * Excepciones
        ``Exception``, ``AssertionError``, ``AttributeError``, ``LoadError``, ``KeyError``,
        ``NotImplementedError``, ``TypeError``, ``ValueError``

event
~~~~~

Este es el modulo encargado de encapsular la lógica de eventos requerida tanto
por los elementos del DOM como por el usuario.

    * connect(obj: Object|null, event: String, context: Object|null, method: String|Function, dontFix: Boolean) -> handle: Handle

        Provee un mecanismos para conectar la ejecución de una función a otra o a un
        evento del DOM.  

    * disconnect(handle: Handle)

        Quita el la relación establecida por ``connect``.

    * subscribe(topic: String, context: Object|null, method: String|Function) -> handle: Handle

        Subscribe una función a un evento de usuario expresado como un texto, cuando el
        evento ocurra la función se ejecuta.
    
    * unsubscribe(handle: Handle)

        Quita la relación de la función con el evento. 
    
    * publish(topic: String, arguments: Array)

        Emite el evento de usuario, provocando la ejecución de las funciones subscriptas
        y pasando los argumentos correspondientes.
    
    * connectPublisher(topic: String, obj: Object, event: String) -> handle: Handle

        Conecta un evento a un evento de usuario asegurando que cada vez que el evento
        se produzca se llamara a la función registrada para el evento de usuario.
    
    * fixEvent(evt: Event, sender: DOMNode)

        Normaliza las propiedades de un evento, tanto pulsaciones del teclado como
        posiciones x/y del ratón.
    
    * stopEvent(evt: Event)

        Detiene el evento, evitando la propagación y la acción por defecto.
    
    * keys

        Objeto que encapsula los códigos de las teclas de función y control.

Timer
~~~~~
    
    * delay(function)

        Espera un tiempo determinado para ejecutar la función pasada como argumento.

    * defer(function)

        Demora la ejecución de una función hasta que el interprete este listo para procesarla.

ajax
~~~~

Este modulo provee una interfaz de recubrimiento sobre las peticiones asincrónicas
al servidor o simplemente ``AJAX``, uno de sus principales objetivos es el de encapsular y 
simplificar la utilización del objeto ``XMLHttpRequest``.

    * Request()

        new Request()
    
    * Response()

        new Response()
    
    * toQueryParams(string, separator) -> object
    
    	Convierte una cadena conteniendo una consulta de URL a un objeto de la
    	forma clave = valor. El separador por defecto para estas consultas es el
    	caracter ``&`` aunque otro separador puede ser usado.
    
    * toQueryString(params) -> string
    
    	Realiza el proceso inverso a ``toQueryParams``, convirtiendo un objeto
    	a una consulta de URL.
    	
    .. code-block:: javascript
    
	    >>> require('ajax')
		>>> ajax.toQueryString({numero:1, cadena:'Hola mundo', fecha: new Date(), arreglo: [1,2,3,4]})
		"numero=1&cadena=Hola%20mundo&fecha=1258839800956&arreglo=1&arreglo=2&arreglo=3&arreglo=4"
		>>> var query = ajax.toQueryString({numero:1, cadena:'Hola mundo'})
		>>> ajax.toQueryParams(query)
		{ numero="1" cadena="Hola mundo"}
    
dom
~~~

Este modulo brinda el soporte para el manejo del DOM de una forma simple para
el usuario.

    * query(cssRule) -> [HTMLElement...]

Extendiendo Javascript
----------------------

Protopy no solo aporta módulos y funciones útiles al desarrollo, sino que
también agrega nueva funcionalidad a los objetos de JavaScript.

String
~~~~~~

Estos métodos amplían las herramientas para el manejo de cadenas de texto.

    * sub(pattern, replacement[, count = 1]) -> string

        Retorna una cadena donde la primera ocurrencia del patron pasado es reemplazado
        por la cadena o cada uno de los valores retornados por la función pasada como
        segundo argumento. El patrón puede ser una expresión regular o una cadena.
    
    * subs(value...) -> string

        Substituye cada patrón encontrado en la cadena por los valores
        correspondientes, si el primer valor es un objeto, se espera un patrón del
        tipo clave en la cadena para su reemplazo.
    
    * format(f) -> string

        Da formato a una cadena de texto, al estilo C.
    
    * inspect(use_double_quotes) -> string

        Retorna una versión de debug de la cadena, esta puede ser con comillas simples o
        con comillas dobles.
    
    * truncate([length = 30[, suffix = '...']]) -> string

        Recorta una cadena recortada en la longitud indicada o 30 caracteres por
        defecto, si se pasa un sufijo este es utilizado para indicar el recorte, sino
        los ''...'' son utilizados.
    
    * strip() -> string

        Quita los espacios en blanco al principio y al final de una cadena.
    
    * striptags() -> string

        Quita las etiquetas HTML de una cadena.
    
    * stripscripts() -> string

        Quita todos los bloques ''strips'' de una cadena.
    
    * extractscripts() -> [ string... ]

        Extrae todos los scripts contenidos en la cadena y los retorna en un arreglo.
    
    * evalscripts() -> [ value... ]

        Evalúa todos los scripts contenidos en la cadena y retorna un arreglos con los
        resultados de cada evaluación.
    
    * escapeHTML() -> string

        Convierte los caracteres especiales del HTML a sus entidades equivalentes.
    
    * unescapeHTML() -> string

        Convierte las entidades de caracteres especiales del HTML a sus respectivos
        símbolos.
    
    * succ() -> string
        
        Convierte un caracter en el caracter siguiente segun la tabla de caracteres
        Unicode.
    
    * times(count[, separator = '']) -> string

        Concatena una cadena tantas veces como se indique, si se pasa un separador, este
        es utilizado para intercalar.
    
    * camelize() -> string

        Convierte una cadena separada por guiones medios (``-'') a una nueva cadena tipo
        ''camello''. Por ejemplo, 'foo-bar' pasa a ser 'fooBar'.
    
    * capitalize() -> string

        Pasa a mayúscula la primera letra y el resto de la cadena a minúsculas.
    
    * underscore() -> string

        Convierte una cadena tipo "camello" a una nueva cadena separada por guiones
        bajos ("_").
    
    * dasherize() -> string

        Remplaza cada ocurrencia de un guión bajo ("_") por un guión medio ("-").
    
    * startswith(pattern) -> boolean

        Chequea si la cadena inicia con el patrón pasado.
    
    * endswith(pattern) -> boolean

        Chequea si la cadena termina con el patrón pasado.
    
    * blank() -> boolean

        Chequea si una cadena esta en blanco, esto es si esta vacía o solo contiene
        espacios en blanco.

Number
~~~~~~

Estos métodos agregan funcionalidad sobre los objetos numéricos.

    * format(f, radix) -> string

        Da formato a un numero en base a una cadena de texto, al estilo C.

Element
~~~~~~~

Extensión sobre los elementos del DOM, simplificando trabajos comunes de desarrollo.

    * visible() -> Boolean

        Retorna un valor de verdad que determina si el elemento esta visible al
        usuario, verificando el atributo de estilo ``display''.
    
    * toggle() -> HTMLElement

        Alterna la visibilidad del elemento.
    
    * hide() -> HTMLElement

        Oculta el elemento al usuario, modificando el atributo de estilo.
    
    * show() -> HTMLElement

        Muestra el elemento.
    
    * remove() -> HTMLElement

        Quita el elemento del documento y lo retorna.
    
    * update(content) -> HTMLElement

        Reemplaza el contenido del elemento con el argumento pasado y retorna el
        elemento.
    
    * insert({ position: content }) -> HTMLElement
    * insert(content) -> HTMLElement

        Inserta contenido al principio, al final, sobre o debajo del
        elemento, para definir la posición de la inserción el argumento se debe pasar
        en forma de objeto, donde la clave es la posición y el valor el contenido a
        insertar; si el argumento es contenido a insertar este se inserta al final
        del elemento.
    
    * select(selector) -> HTMLElement

        Toma un numero arbitrario de selectores CSS y retorna un arreglo con los
        elementos que concuerden con estos y estén dentro del elemento al que se aplica
        la funcion.
    
        >>> $('PostForm').select('input')
        [input#id_title, input guardar]
        >>> $('content').select('div')
        [div.header, div.breadcrumbs, div.middle, div, div.right, div#clear]
        >>> $('content').select('div.middle')
        [div.middle]

Forms
~~~~~

Estos métodos decoran a los elementos del tipo formulario, agregando
funcionalidad sobre los mismos y sobre los campos que contienen.

    * disable() -> HTMLFormElement

        Deshabilita todos los campos de este formulario para el ingreso de
        valores.

    * enable() -> HTMLFormElement

        Habilita todo campos del formulario para el ingreso de valores.

    * serialize() -> object

        Retorna un objeto conteniendo todos campos del formulario serializados
        con sus respectivos valores.

        >>> $('PostForm')
        <form id="PostForm" method="post" action="/blog/add_post/">
        >>> $('PostForm').serialize()
        Object title=Hola mundo body=Este es un post tags=[1]

Forms.Element
~~~~~~~~~~~~~

Los métodos que a continuación se presentan decoran a los elementos o campos de
un formulario, simplificando y agilizando el trabajo con los mismos.

    * serialize() -> string

        Crea una cadena en URL-encoding representando el contenido del
        campo expresado como clave=valor, para su uso en una petición AJAX por
        ejemplo.
        Este atributo trabaja sobre un unico campo, si en lugar de esto se requiere
        serializar todo el formulario vea Form.serialize().
        Si se requiere es el valor del campo en lugar de la pareja clave=valor, vea
        get_value().

    * get_value() -> value

        Retorna el valor actual del campo. Una cadena de texto es retornada en la
        mayoría de los casos excepto en el caso de un select multiple, en que se retorna
        un arreglo con los valores.

    * set_value(value) -> HTMLElement

        Establese el valor de un campo.

    * clear() -> HTMLElement

        Limpia un campo de texto asignando como valor la cadena vacia.

    * present() -> boolean

        Retorna verdadero si el campo de texto tiene un valor asignado, falso en otro
        caso.

    * activate() -> HTMLElement

        Pone el cursor sobre el campo y selecciona el valor si el campo es del tipo
        texto.

    * disable() -> HTMLElement

        Deshabilita el campo, impidiendo de este modo que se modifique su valor hasta
        que sea habilitado nuevamente.
        Los campos de un formulario que esten deshabilitados no se serializan.

    * HTMLElement.enable() -> HTMLElement

        Habilita un campo, previamente deshabilitado, para el ingreso de valores.

Otros modulos
-------------

gears
~~~~~

En este paquete se encuentran las extensiones que Protopy brinda a los objetos Gears.
La interacción con el plugin de Google se realiza a través del modulo ``sys`` y el objetivo
de este paquete es tomar parte en la obtención de los objetos incorporando sobre ellos nueva
funcionalidad, como cursores en el objeto ``database`` o manejo de archivos en el objeto ``desktop``.

logging
~~~~~~~

El módulo logging ofrece un sistema de registros (logs) completo y flexible. En su forma
más simple, los mensajes de registro se envían a la consola de Firebug.

De forma predeterminada, los mensajes de depuración e informativos se suprimen, y la salida
se envía a una función "nula". Otras opciones de salida incluyen mensajes al servidor HTTP.
Nuevos filtros pueden seleccionar diferentes rutas basadas en la prioridad del mensaje: DEBUG,
INFO, WARNING, ERROR, y CRITICAL (Depuración, Informativo, Atención, Error y Crítico respectivamente)

El sistema de registro puede configurarse directamente desde Protopy o puede cargarse la configuración
desde un archivo editable por el usuario para personalizar el registro sin alterar la aplicación.

json
~~~~

El módulo ``json`` tiene como objetivo el paso de objetos JavaScript a cadenas de texto json y viceversa.

    >>> require('json')
    >>> toJson = {'numero': 1, 'cadena': 'texto', 
    	'arreglo': [1,2,3,4,5,6], 'objeto': {'clave': 'valor'}, 
    	'logico': true}
    >>> toSend = json.stringify(toJson)
    "{"numero": 1, "cadena": "texto", "arreglo": [1, 2, 3, 4, 5, 6],
    "objeto": {"clave": "valor"}, "logico": true}"
    >>> fromJson = json.parse(toSend)
    Object numero=1 cadena=texto arreglo=[6] objeto=Object

rpc
~~~

Este módulo encapsula la lógica de comunicación mediante RPC con el servidor HTTP. La clase principal
del modulo es ``ServiceProxy`` y mediante configuración de la misma se obtienen varias formas de
interacción con el servidor, pudiendo ser estas sincrónicas o asincrónicas, con XML o JSON como protocolo
de transporte.

Se presenta a continuacion un ejemplo de comunicación RPC entre un objeto en Python en el servidor y un
cliente usando este módulo de Protopy.

La clase publicada en el servidor es:

.. code-block:: python

    class MyFuncs:
        def _listMethods(self):
            # this method must be present for system.listMethods
            # to work
            return ['add', 'pow']
        def _methodHelp(self, method):
            # this method must be present for system.methodHelp
            # to work
            if method == 'add':
                return "add(2,3) => 5"
            elif method == 'pow':
                return "pow(x, y[, z]) => number"
            else:
                # By convention, return empty
                # string if no help is available
                return ""
        def _dispatch(self, method, params):
            if method == 'pow':
                return pow(*params)
            elif method == 'add':
                return params[0] + params[1]
            else:
                raise 'bad method'

    server = SimpleXMLRPCServer(("localhost", 8000))
    dispatcher.register_introspection_functions()
    dispatcher.register_instance(MyFuncs())

mientras que en el cliente, la forma de utilizar el RPC es como sigue

.. code-block:: javascript

    >>> require('rpc')
    >>> funcs = new rpc.ServiceProxy('rpc/test', {asynchronous: false})
    >>> funcs.system.listMethods()
    ["add", "pow", "system.listMethods", "system.methodHelp", "system.methodSignature"]
    >>> for each (m in funcs.system.listMethods())
                    print(m + ': ' + funcs.system.methodHelp(m));
    add: add(2,3) => 5
    pow: pow(x, y[, z]) => number
    system.listMethods: system.listMethods() => ['add', 'subtract', 'multiple']
        Returns a list of the methods supported by the server.
    system.methodHelp: system.methodHelp('add') => "Adds two integers together"
        Returns a string containing documentation for the specified method.
    system.methodSignature: system.methodSignature('add') => [double, int, int]
        Returns a list describing the signature of the method. In the above example,
    the add method takes two integers as arguments and returns a double result.
        This server does NOT support system.methodSignature.
    >>> funcs.add(24,4)
    28
    >>> funcs.pow(2,4)
    16

a continuación se presentan los datos intercambiados entre el cliente y el servidor en formato JSON.

    Add
    -----> {"version": "1.1", "method": "add", "id": 1, "params": [24,4]}
    <----- {"id":1,"result":28}

    Pow
    -----> {"version": "1.1", "method": "pow", "id": 2, "params": [2,4]}
    <----- {"id":2,"result":16}
