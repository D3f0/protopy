####
Doff
####

En apartados teóricos se mencionó, entre otras cosas, que la creación de un
framework generalmente surge de la identificación de objetos reusables en
el desarrollo de software. Posteriormente los objetos identificados constituyen
luego componentes que forman parte de una arquitectura. A estos se accede
mediante una API especifica y se añade o modifica su funcionlaidad mediante 
configuración o extensión.


En el desarrollo del framework desconectado, si bien se contaba con Django
como base, muchos aspectos no estabn claramente definidos y algunos componentes
carecían de sentido en el contexto del navegador. Por esta razón
se realizaron dos proyectos [*]_ que sirvieron para identificar las piezas necesarias
del framework y mejorar el enfoque de Protopy, además de permitir crear
nuevos componentes reusables que no estaban presentes en Django.

El framework desconectado, de manera similar a Protopy, se apodó en base
a su padre y a la tarea que este cumple. Se bautizó como **Doff**, tomando
la *d* de Django y *off* de offline (desconectado), su nombre significa por
lo tanto, Django Desconectado:

    | **d** jango + **off** line = **doff**
    
.. [*] Inicialmente se creó una aplicación de *blog*, debido a la popularidad de este tipo de
        aplicaciones, y luego "salesman" (o agente de ventas viajate) 
        que intenta explotar las posiblidades de contar con una aplicación web desconectada.
    
    
Migración de Componetes Básicos
-------------------------------


Doff se inició como un conjunto de modulos para Protopy. Estos módulos implementaban
diferentes componentes de Django sobre el cliente. Debido a que los módulos de 
JavaScript son recursos estáticos, se sirvieron mediante un servidor de archivos
muy simple llamado Aspen, que no requería intervensión de Django [AspenWebServer09]_.

Como se mencionó en el capítulo introductorio, los compoentes que
requerían una migración directa a JavaScript eran el ORM (``django.db.models``) y 
el sistema de templates (``django.templates``). Las vistas y el sistema de URLs
deberían ser adaptadas para el contexto del navegador.

.. [AspenWebServer09] Lawrence Akka, Christopher Baus, Chris Beaven, Steven Brown,
    Chad Whitacre,
    *Servidor Web Aspen*,
    ultimo acceso Diciembre 2008,
    http://www.zetadev.com/software/aspen/


El primer componente de Django migrado fue ``django.db.models``, el cual se realizó
simplificando algunos aspectos como el soporte para múltiples bases de datos, ya
que Gears solo provee SQLite.
La tarea de migración ayudó a perfeccionar el sistema de tipos (clases) y el de módulos. 
El paquete resultante fue ``doff.db.models`` y gracias a implementar progresivamente 
la misma API que Django, fue posible realizar el mismo manejo de datos en el cliente y en el 
servidor.


Las pruebas y depuración del proyecto se realizaron sobre Firebug, cargando
protopy en un archivo estático y realizando los ``require()``s correspondientes
en la consola. Por ejemplo:

.. code-block:: javascript

    // En la consola de firebug
    >>> require('doff.db.models.base');
    


.. Mientras que un cliente se encuentre sin conexion con el servidor web, es capaz
    de generar y almacenar datos usando su base de datos local. Al reestablecer
    la conexion con el servidor web, estos datos deben ser transimitos a la base de
    datos central para su actulizacion y posterior sincronizacion del resto de los
    clientes. Para plantear la tarea de sincronización es necesario contar con
    el framework funcionando desconecatdo, por lo que se postergó su analisis en esta
    etapa.
 
El siguiente componente en ser analizado y migrado fue el sistema de plantillas
(``django.templates``).
La librería de JavaScript Dojo provee un sistema de renderizado de planitllas
basado en la sintaxis de Django [DojoLibDjangoTmpl09]_. Sin embargo se optó 
por portar la propia de Django ya que la implementación de Dojo no está basada
en el sistema de módulos de Protopy. Esta funcionalidad se situó en el módulo 
``doff.templates``.


.. [DojoLibDjangoTmpl09] The Dojo Foundation,
    Documetnación sobre los templates de Django portados a Dojo,
    ultimo acceso Septiembre de 2009,
    http://www.dojotoolkit.org/book/dojo-book-0-9/part-5-dojox/dojox-dtl/ 

Definción de Proyecto y Aplicaciones Desconectadas
--------------------------------------------------

Luego de haber alcanzado un nivel de funcionalidad básico en ``doff.db.models`` y 
``doff.templates`` se definió la interacción básica con Django, mediante
la cual un proyecto en linea sería capaz de transferirse al cliente. Para
este fin se creó una aplicación Django llamada ``offline`` cuyo objetivo incial 
fue servir estáticamente el código JavaScript de Protopy y Doff.

El siguiente paso fue definir un proyecto Django desconectado, es decir, un
proyecto Doff. Se buscó el mayor grado de similitud posible con Django, donde
un proyecto es un paquete Python (con los módulos ``settings.py``, ``manage.py``
y ``urls.py``) y cada aplicación un paquete dentro de la proyecto o localizable
en el ``PYTHONPATH`` (una aplicación cuenta con los módulos ``models.py`` y
``views.py``).

En Doff, un proyecto se definió como un paquete Protopy con un módulo ``settings.js``
con la configuración del proyecto. El módulo de proyecto Django ``manage.py`` carece de 
sentido en el navegador, ya que no se cuenta con una interfase de comandos en 
JavaScript, por lo que se implementó la clase ``doff.core.project.Project``.
Esta clase define una serie de métodos para interactuar con el proyecto que 
cumplen algunas de las funciones de el módulo ``manange.py`` y realizar tareas
necesarias en el ambiente desconectado.
El módulo ``urls.js`` se reservó para análisis posterior. 

La clase proyecto posee los siguientes métodos:

 * ``bootstrap`` debe ser llamado cada vez que se quiera ceder el control
    de la navegación a el framework desconectado. Debe ser asociado al evento
    de catga de la página.
    
 * ``install`` se encarga de persistir el framework y proyecto en
   el almacenamiento local del cliente. También crea la base de datos equivalente
   a ``manage.py syncdb``.
   
 * ``uninstall`` remueve la base de datos, el proyecto y el código del framework
   del clinete.
   
Un proyecto se crea de la siguiente manera:

.. code-block:: javascript

    <script type="text/javascript;version=1.7">
        require('doff.core.project', 'new_project');
        
        var agentes = new_project('agentes', '/off/agentes');
        agentes.bootstrap();
    </script>
    
El primer argumento es el nombre del proyecto y el segundo es la URL que se 
agrega al ``sys.path`` de Protopy, deifiniendo de esta manera un nuevo 
paquete en Protopy en ámbito de nombres global. 

Las aplicaciones de un proyecto Doff se definieron como paquetes de Protopy que se encuentran
dentro del proyecto. Constan del módulo ``views.js`` y ``models.js``. 

Para facilitar la instalación de proyectos se creo una etiqueta de plantilla 
(``template tag``) que incluye de manera automática Protopy, Doff y crea
un proyecto con el nombre que se pasa como parámetro. La creación de un proyecto
consitió en esta etapa en almacenar el código del Doff y el proyecto en el cliente
mediante gears. La página donde se instancia la clase ``Project`` se persiste 
como la URL incial y punto de entrada a la apilicación desconectada, garantizando
que cada vez que el cliente acceda a esta URL sin conexión el proyecto se vuelva
a instanciar.

Los siguientes apartados tratan sobre las implementaciones de la API del ORM,
templates, vistas y formularios.

Modelos
=======

Doff implementa la misma API que Django, realizando las adaptaciones
a la sintaxis de JavaScript y la librería Protopy.

A continuación se ejemplifica la implementación  en el cliente del módulo 
``models.js`` de una aplicación que consta con las entidades Libro, Autor y Editor:

.. code-block:: javascript

    // Cargar el módulo del ORM
    var models = require('doff.db.models.base');
    
    // La clase editor (Publisher) extiende de models.Model y por lo tanto
    // se crea como tabla en la base de datos
    var Publisher = type('Publisher', [ models.Model ], {
        name: new models.CharField({ maxlength: 30 }),
        address: new models.CharField({ maxlength: 50 }),
        city: new models.CharField({ maxlength: 60 }),
        state_province: new models.CharField({ maxlength: 30 }),
        country: new models.CharField({ maxlength: 50 }),
        website: new models.URLField()
    });
    
    // La clase autor (Author) extiende de models.Model y por lo tanto
    // se crea como tabla en la base de datos
    var Author = type('Author', [ models.Model ], {
        salutation: new models.CharField({ maxlength: 10 }),
        first_name: new models.CharField({ maxlength: 30 }),
        last_name: new models.CharField({ maxlength: 40 }),
        email: new models.EmailField(),
        headshot: new models.ImageField({ upload_to: '/tmp' })
    });
    
    // La clase libro (Book) extiende de models.Model y por lo tanto
    // se crea como tabla en la base de datos
    var Book = type('Book', [ models.Model ], {
        title: new models.CharField({ maxlength: 100 }),
        authors: new models.ManyToManyField(Author),
        publisher: new models.ForeignKey(Publisher),
        publication_date: new models.DateField()
    });

Cada modelo es representado por un clase de Protopy que extiende a
``doff.db.models.model.Model``. 

Cada modelo se corresponde con una tabla única de la base de datos, y cada
atributo de un modelo con una columna en esa tabla. El nombre de atributo
corresponde al nombre de columna, y el tipo de campo corresponde al tipo de
columna de la base de datos. Por ejemplo, el modelo ``Publisher`` es equivalente
a la siguiente tabla:

.. code-block:: sql

    CREATE TABLE "books_publisher" (
        "id" serial NOT NULL PRIMARY KEY,
        "name" varchar(30) NOT NULL,
        "address" varchar(50) NOT NULL,
        "city" varchar(60) NOT NULL,
        "state_province" varchar(30) NOT NULL,
        "country" varchar(50) NOT NULL,
        "website" varchar(200) NOT NULL
    );

La excepción a la regla de una clase por tabla es el caso de las relaciones
muchos a muchos. En el ejemplo, ``Book`` tiene un ``ManyToManyField`` llamado
``authors``. Esto significa que un libro tiene uno o más autores, pero la tabla
de la base de datos ``Book``  no tiene una columna ``authors``. En su lugar, se
crea una tabla adicional que maneja la correlación entre libros y autores.


Finalmente, no se define explícitamente una clave primaria en ninguno de estos
modelos. A no ser que se le indique lo contrario, Doff dará automáticamente a
cada modelo un campo de clave primaria entera autoincremental llamado ``id``.

Para activar los modelos en el proyecto, la aplicación que los contine debe
estar incluida en la lista de aplicaciones instaladas de Doff. En consonancia
con Django, esta configuración se realiza en el módulo ``settings.js`` en
la variable de configuración ``INSTALLED_APPS``.
Suponiendo que este archivo se encuentre en ``bookstore/models.js``, el nombre de 
la aplicación sería ``bookstore``.



Cuando el usuario instala el proyecto para operación desconectada en su navegador, el
sistema recorre las aplicaciones en ``INSTALLED_APPS`` y genera el SQL para
cada modelo, creando las tablas en la base de datos. 

Además de implementar la API de consultas, el desarrollador puede realizar
``queries`` en SQL sobre la base de datos del cliente mediante las herramientas
de desarrollador provistas por Doff.


Creación y Recuperación de Datos
--------------------------------

Una vez que se creo el modelo, Doff provee automáticamente una API JavaScript
de alto nivel para trabajar con estos modelos muy similar a la de Django:

    >>> require('books.models', 'Publisher');
    >>> p1 = new Publisher({ name: 'Addison-Wesley', address: '75 Arlington Street',
    ...     city: 'Boston', state_province: 'MA', country: 'U.S.A.',
    ...     website: 'http://www.apress.com/'});
    // Guardado de la instancia
    >>> p1.save();
    // Recuperación mediante le Manager
    >>> publisher_list = Publisher.objects.all();
    // Mostrar el resultado de la consulta
    >>> print(array(publisher_list));
    [<Publisher: Publisher object>]
    
    
En la última linea del ejemplo anterior, se ve que en el listado no
aparece una representación adecuada de la instacia de Editor. Esto
responde a que en la definción del modelo no se incluyó un método de 
pasaje a cadena, o ``__str__``. Se puede implementar este método para 
mejorar la depuración.


Inserción y Actualización de Datos
----------------------------------

En el ejemplo presentado anteriormente se mostró la forma de realizar una
inseción de una fila en la base de datos. Primero se crea una instancia del 
modelo pasando argumentos nombrados y 
luego se llama al método ``save()`` de la intancia.

En el caso de ``Publisher`` se usa una clave primaria autoincremental ``id``,
por lo tanto la llamada inicial a ``save()`` hace una cosa más: calcula el valor
de la clave primaria para el registro y lo establece como el valor del atributo
``id``  de la instancia.

Las subsecuentes llamadas a ``save()`` guardarán el registro en su lugar, sin
crear un nuevo registro (es decir, ejecutarán una sentencia SQL ``UPDATE`` en
lugar de un ``INSERT``).

``Managers`` y ``QuerySet``s en el Cliente 
------------------------------------------

La forma de seleccionar y filtrar los datos es la utilización de ``Managers``
o administradores de consultas.

En el ejmplo la linea ``Publisher.objects.all()`` del ejemplo anterior, se solicita
al administrador ``objects`` de Publisher que obtenga todos los registros,
internamente esto genera una consulta SQL::

    SELECT
        id, name, address, city, state_province, country, website
    FROM book_publisher;

Todos los modelos automáticamente obtienen un administrador ``objects`` que debe
ser usado cada vez que se quiera consultar sobre una instancia del modelo.
El metodo ``all()`` es un método del administrador ``objects`` que retorna todas
las filas de la base de datos. Al igual que en Django, el valor retornado
es un ``QuerySet``.

En el caso de requerir una fila o conjunto en particular, se utilzia el método
``filter``. Por ejemplo:

.. code-block:: javascript

    >>> Publisher.objects.filter({name : "Apress Publishing"})
    [<Publisher: Apress Publishing>]

``filter()`` toma argumentos del tipo arreglo asociativo que son traducidos en las
cláusulas SQL ``WHERE`` apropiadas, concatenando con el operador ``AND`` en el 
caso de tener más de un parámetro. El ejemplo anterior sería traducido en la
siguiente consulta:

.. code-block:: sql

    SELECT
        id, name, address, city, state_province, country, website
    FROM book_publisher
    WHERE name = 'Apress Publishing';

En las claves de los parámetros del arreglo asociativo de ``filter`` pueden
contener subargumentos separados por dobles guiones bajos, por ejemplo:

.. code-block:: javascript 

    >>> Publisher.objects.filter({name__contains : "press"})
    [<Publisher: Apress Publishing>]

Busca los Editores en los cuales su nombre contenga la palabra "press".

Esto se traduce en la secuencia SQL:

.. code-block:: sql

    SELECT
        id, name, address, city, state_province, country, website
    FROM book_publisher
    WHERE name LIKE '%press%';

Hay disponibles varios otos tipos de subargumentos de búsqueda, 
incluyendo ``icontains`` (``LIKE`` no sensible a diferencias de mayúsculas/minúsculas), 
``startswith`` y ``endswith``, y ``range`` (consultas SQL ``BETWEEN``). 
El Apéndice C describe en detalle todos esos tipos de búsqueda.

Cuando se requiere obtener un único objeto dada una condición, los
administradores de consutlas brindan el método ``get()``:

.. code-block:: javascript

    >>> Publisher.objects.get({name : "Apress Publishing"})
    <Publisher: Apress Publishing>

En lugar de un ``QuerySet``, este método retorna un objeto
individual. Debido a eso, una consulta cuyo resultado sean múltiples objetos
causará una excepción así mismo como una consulta que no retorne objeto alguno.

Generalmente se requiere que los resultados de los ``QuerySet`` posean un
orden determinaodo por algun campo, para esto está disponible el método 
``order_by()``. Por ejemplo, para un listado de Editores, ordenados por el
campo nombre:

    >>> Publisher.objects.order_by("name")
    [<Publisher: Apress Publishing>, <Publisher: Addison-Wesley>, <Publisher: O'Reilly>]

El ejemplo anterior es similar a la invocación de ``all()``, pero la consulta SQL
incluye un parámetro extra: 

.. code-bloc:: sql

    SELECT
        id, name, address, city, state_province, country, website
    FROM book_publisher
    ORDER BY name;

El ordenamiento puede realizarse por cualquier campo ordenable (cadenas, enteros, 
fechat, esc.) y además por múltiples campos. Si se antepone al nombre del campo
un guión, el ordenamiento es inverso. Por ejemplo:

.. code-block:: javascript

    >>> Publisher.objects.order_by("-name")
    [<Publisher: O'Reilly>, <Publisher: Apress Publishing>, <Publisher: Addison-Wesley>]


Cuando el ordenamiento es frecuente, puede incluirse por defecto en la
definción del modelo mediante la clase interna ``Meta``:

.. code-block:: javascript

    var Publisher = type('Publisher', [ models.Model ], {
        name: new models.CharField({ maxlength: 30 }),
        //...
        
        // Clase interna 
        Meta: {'ordering': ['name']}
    });
    

Las búsquedas y ordenamientos, por ser métodos que devuelven ``QuerySet``, se pueden
encadenar, por lo que serán frecuentes consultas como las siguientes:

.. code-block:: javascript

    >>> Publisher.objects.filter(country="U.S.A.").order_by("-name")
    [<Publisher: O'Reilly>, <Publisher: Apress Publishing>, <Publisher: Addison-Wesley>]


Cuando se requiere acceder a un registro en particular, se puede usar la sintaxis
de arreglo sobre un ``QuerySet``, por ejemplo:

.. code-block:: javascript

    >>> Publisher.objects.all()[0] // Acceder al primer elemento
    <Publisher: Addison-Wesley>

Esto se traduce al siguiente listado SQL:

.. code-block:: sql

    SELECT
        id, name, address, city, state_province, country, website
    FROM book_publisher
    ORDER BY name
    LIMIT 1;


Eliminación de Datos
--------------------

Para eliminar objetos, simplemente se debe llamar al método ``delete()`` 
sobre una instancia:

.. code-block:: javascript

    >>> p = Publisher.objects.get({ name: "Addison-Wesley" });
    >>> p.delete();
    >>> array(Publisher.objects.all());
    []

Los QuerySet pueden recibir también le método ``delete()`` y se traduce
en la eliminiación de todas las filas afectadas por el ``QuerySet``. Por 
ejemplo:

.. code-block:: javascript

    >>> publishers = Publisher.objects.all();
    >>> publishers.delete();
    >>> array(Publisher.objects.all());
    []


Plantillas
==========

Doff brinda soporte al sistema de plantillas de Django. Las plantillas escritas 
para una apilcacion en línea son reutilzables sin modificaciones en la aplicación
desconectada.

Existen sin emabargo algunos factores a tener en cuenta a la hora de
realizar plantillas para aplicaciones offline. Cuando una aplicación se
ejecuta de manera desconectada, el navegador solo realiza una carga de documento
y la navegación se basa manipulaciones de DOM. 
Cada vez que se carga una página, en realidad se suprime la anterior y se anexa
la nueva en un elemento llamado ``fake-body`` y ``fake-header``. Este trabajo
es realizado por Doff y con ayuda del paquete ``dom`` de Protopy.

A continuación se realizará un breve anális de la API de plantillas y 
su utilización en Doff.

Creación de objetos Template
----------------------------

Doff implementa la calse ``Template`` para crear plantillas, y esté
se encuentra en el módulo ``doff.template.base``. El argumento para la
instanciación del objeto es el texto en crudo de la plantilla. 

    >>> require('doff.template.base', 'Template');
    >>> t = new Template("Mi nombre es {{ name }}.");
    >>> print(t);

En este ejemplo ``t`` es un objeto template listo para ser renderizado. En
caso de encontrar errores en el análisis de la plantilla, la instanciación
de ``Template`` falla. Los errores contemplados son:

    * Bloques de etiquetas inválidos
    * Argumentos inválidos de una etiqueta válida
    * Filtros inválidos
    * Argumentos inválidos para filtros válidos
    * Sintaxis de plantilla inválida
    * Etiquetas de bloque sin cerrar (para etiquetas de bloque que requieran la
      etiqueta de cierre)

En todos los casos el sistema lanza una excepción ``TemplateSyntaxError``.

Renderizar una plantilla
------------------------

Para obtener la salida procesada de una instancia de ``Template``, 
es necesario proveer un *contexto*. Un contexto es simplemente un
conjunto de variables y sus valores asociados, en Doff, un arreglo asociativo.
Una plantilla usa las variables para rellenar la plantilla evaluando las 
etiquetas.

El contexto esta representado en el tipo ``Context``, el cual se encuentra en el
módulo ``doff.template.base``. La construccion del objeto toma un argumento
opcional  un arreglo asociativo. La llamada al método ``render()`` del la 
instacia de ``Template`` con el contexto como argumento "rellena" la
plantilla::

    >>> requiere('doff.template.base', 'Context', 'Template');
    >>> t = new Template("Mi nombre es {{ name }}.")
    >>> c = new Context({"name": "Pedro"})
    >>> t.render(c)
    'My name is Pedro.'

El objeto ``Template`` puede ser renderizado con múltiples contextos, obteniendo
así salidas diferentes para la misma plantilla. Por cuestiones de eficiencia es
conveniente crear un objeto ``Template`` y luego llamar a ``render()``
sobre este muchas veces::

    # Código ineficiente
    for each (var name in ['John', 'Julie', 'Pat']) {
        var t = new Template('Hello, {{ name }}');
        print(t.render(new Context({'name': name})));
    }

    # Código eficiente
    t = new Template('Hello, {{ name }}');
    for each (var name in ['John', 'Julie', 'Pat'])
        print(t.render(new Context({'name': name})));

Al igual que en Django el objeto contexto puede contener variables mas complejas
y la forma de inspeccionar dentro de estas es con el operador `.` (punto). Usando el
punto se puede acceder a objetos, atributos, índices, o métodos de un objeto.

Cuando un sistema de plantillas encuentra un punto en una variable el orden de
busqueda es el siguiente:

    * Diccionario (por ej. ``foo["bar"]``)
    * Atributo (por ej. ``foo.bar``)
    * Llamada de método (por ej. ``foo.bar()``)
    * Índice de lista (por ej. ``foo[bar]``)

El sistema utiliza el primer tipo de búsqueda que funcione.

Finalmente, si una variable no existe en el contexto, el
sistema de plantillas renderiza este como una cadena vacía. 
Es posible cambiar este comportamiento modificando el valor de
la variable de configuración ``TEMPLATE_STRING_IF_INVALID`` en el módulo
``settings.js``.

Cargador de Plantillas
----------------------

Si bien en los ejemplos anteriores se mostró la API de plantillas con
cadenas como argumentos, las plantillas suelen estar almacenadas en 
archivos. Para Doff estos son recuros estáticos y existe un sistema
para la carga similar al de Django. Para tal fin en el módulo ``settings.js`` se esablece
el valor ``TEMPLATE_URL``.

Se ve a continuación un ejemplo de una vista que retorna HTML generado por una
plantilla::

    require('doff.template.base', 'Template', 'Context');
    require('doff.utils.http', 'HttpResponse');
    require('doff.template.loader', 'get_template');

    function current_datetime(request) {
        var t = get_template('mytemplate.html');
        html = t.render(new Context({'current_date': new Date()}))
        return new HttpResponse(html);
    }

En esta vista se utiliza la API para cargar plantillas, a la cual se accede 
mediante la funcion `get_template()`.

Existen varios cargadores de plantillas que se pueden habilitar en el archivo de 
configuración. En el presente trabajo se utilzará solo el de carga de templates
a través de URLs. Por omisión, ``TEMPLATE_URLS`` es es una cadena vacia, en cuyo
caso la búsqueda de template se realizará en ``templates/`` a partir de donde
se instanció el proyecto.


Emulación de HTTP
-----------------

En una aplicación en línea, con cada click sobre un enlace, envío de formulario
o solicitud asincrónica (AJAX) se realiza un requerimiento al servidor, es decir
se traduce en una solicitud HTTP.

Cuando la aplicación se encuentra desconectada, es decir, se ha instanciado
el proyecto, Doff utiliza dos clases para emular HTTP y el comportamiento
predefinido del navegador. Estas clases son ``DOMAdapter`` y ``LocalHandler``.

``DOMAdapter`` se encarga de crear un documento falso en el DOM, un historial
y administrar la interacción con el usuario, generando instancias de ``Request``
con los eventos de los enlaces y formularios, que son enviadas al ``LocalHandler``
como ``Request`` que emulan las peticiones HTTP. 

En Django, cuando se recibe una petición, es procesada por una instancia de
la clase ``Handler``. El equivalente en el proyecto desconectado es ``LocalHandler``.
Se encarga de procesar las peticiones que envía el ``DOMAdapter``,
realizando la ejecución del clico normal de proceso  los ``Middlewares`` que conllevan
la resolución de la URL y ejecución de la vista.

La salida de la vista se envuelve en un objeto ``Response``, equivalente a
la respuesta HTTP, que es devuelto al ``DOMAdapter``.

Cuando el ``DOMAdapter`` recibe la respuesta, reliza las tareas de acutalización
de la fachada del navegador, estas comprenden: actualizar el documento falso, 
genera una entrada en el historial y registrarse los eventos de los links y formularios
con los nuevos contenidos del documento.

.. figure:: ../_svg/esquema_domadapter.png

    Diagrama de comunicacion entre el docummento y el sistema de meulación 
    HTTP de ``DOMAapter`` y su comunicación con el ``LocalHandler``.
 
Con cada entrada en el historial se modifica la *query* de la URL. La instancia
de ``History`` captura durante la instanciación del proyecto desconectado la URL raíz.
La navegación en el proyecto desconectado se realiza en base a la url raíz. 
Por ejemplo, si la URL en la que se instancia el proyecto es::

    http://mi_dominio.com/base_offline/base
    
y se accede en la aplicación en línea a la URL::

    http://mi_dominio.com/base_offline/base/ventas

El objeto ``History`` generará la URL

    http://mi_dominio.com/base_offline/base/#ventas

Los módulos antes mencionados se encuetran conectados entre si mediante el 
módulo de eventos ``event`` provisto por Protopy. 


Debido a que la operación con el DOM se encuentra recubierta en la operación
desconectada, el código de las plantillas debe ser adaptado para trabajar
con la API de Doff/Protopy:

    * Se debe utilizar ``sys.window`` en vez de elemento ``window``. Éste apunta
      a ``window`` cuando el template se rederiza con conexión, y a 
      ``DOMAdapter`` cuando se encuentra sin conexión.
      
    * Se debe utilzar ``sys.transport`` en vez de ``XMLHttpRequest`` para 
      que las llamadas asincrónicas sean correctamente ruteadas. Éste apunta
      a ``XMLHttpRequest`` cuando la aplicación se encuentra en línea y a una
      emulación que trabaja con el ``LocalHandler`` en modo desconectado.
    
    * Utilizar el selector CSS ``$$(selector)`` para selección de elementos que trabaja
      adecuadamente en el contexto desconectado y en linea. Es un ``builtin``
      por lo que está simepre disponible. Para el caso de la selección de por
      ID se tiene ``$(id)`` (similar a Prototype).
      
      .. code-block:: javascript
      
        var mi_boton = $('mi_boton'); // en vez de
                       // sys.window.document.getElementById('mi_boton');
                       
        var mis_links = $$('a.mis_links');
       
    * En vez de utilizar ``addListener`` sobre los ``HTMLElements`` u otros
      elementos del DOM, utilizar 
      ``event.connect( nombre_evento, emisor, receptor, [metodo])``. Por ejemplo:
      
      .. code-block:: javascript
        
        require('event');
        event.connect('click', $('boton'), function() {
            alert("Clickeaste mi boton");
        });
            
      Una opreación muy común es ejecutar algo ante el evento de carga de página, 
      esto se realiza de la siguiente manera:
      
      .. code-block:: javascript
      
        require('event');
        event.connect('load', sys.window, miFuncionListener);
      
    
    * Si existiese parte del template que solo debe mostrarse solo en un estado
      de la aplicación, evaluar el valor del contexto ``offline``.
      
      .. code-block:: html
        
        {% if offline %}
            <h1>Estoy Offline!</h1>
        {% else %}
            <h1>Estoy en linea</h1>
        {% endif %}
      
Como se ha visto, Doff modifica el comportamiento de varios módulos de Protopy 
para lograr consistencia en el entorno desconectado.

Vistas
------

Las vistas son en Doff funciones que contienen la lógica de la aplicación. Están
asociadas a URLs en el archivo ``urls.js`` (siempre que no se halla modifcado
el ``ROOT_URLCONF``) del proyecto desconectado. Al igual
que Django, la variable que almacena estas asociaciones es ``urlpatterns``.
En el mapeo se pueden hacer inclusiones de módulos de URLs definidos en las 
aplicaciones. 

Es importante notar que las expresiones regulares nativas de JavaScript no 
poseen la capacidad de recuperación de grupos nombrados, solo recuperación
posicional.

Un módulo de urls se conforma de la siguiente manera:

.. code-block:: javascript

    require('doff.conf.urls', '*');
    // El proyecto se llama Blog y la aplicación Post, por lo que las vistas
    // se encuentran en el submódulo blog.post.views
    require('blog.post.views');
    
    // Definción de los patrones
    var urlpatterns = patterns('',
        // Asociacion por el nombre completo de la vista
        ['^/$', 'blog.post.index'],
        ['^add_tag/$', 'blog.post.views.add_tag'],
        ['^remove_tag/([A-Za-z0-9-]+)/$', 'blog.post.views.remove_tag'],
        // Asociación mediante la referencia de la función del módulo importado
        ['^add_post/$', views.add_post],
        ['^remove_post/([A-Za-z0-9-]+)/$', views.remove_post]
    );
    
    // Lo único que se publica es la variable urlpatterns
    publish({ 
        urlpatterns: urlpatterns 
    });

Una vista se conforma muy similar a Django, notar que para el ejemplo anterior la ubicación
de argumentos mediante grupos es posicional:

.. code-block:: javascript

    require('doff.utils.shortcuts', 'render_to_response', 'redirect');

    function remove_tag(request, slug){
        var tag = Tag.objects.get({'slug': slug});
        tag.delete();
        return redirect('/');
    }
    
    function index(request){
        return render_to_response('mi_template.html', {
            titulo: "Bienvenido a la aplicación desconectada"
        });
    }   
    
    // ... más vistas
    
    publish({
        emove_tag: emove_tag,
        index: index,
        // ... mas publicaciones
    });

Las vistas reciben el objeto ``HTTPRequest`` como primer argumento, en consonancia
con Django. En la aplicación sin conexión, 
la creación del ciclo del ``Request`` comienza con
la captura del evento por parte del ``DOMAdapter`` como se describe en el 
apartado de **Emulación de HTTP**.

Las vistas deben devover un objeto ``HTTPResponse``. Doff implementa algunos
atajos de ``django.shortcuts``, por ejemplo, ``render_to_response(nombre_template,
contexto)``, que simplifica el proceso de la plantilla.

Formularios
===========

Los formularios son casi por excelencia el mecanismo de entrada 
para las operaciones CRUD en los sistemas de información basados en
la Web. 

Doff posee la misma abstracción en objetos que brinda Django para
facilitar la manipulación y validación de datos mediante instancias
del tipo ``Form``.

Un formulario en Doff es una clase que exitende de ``Form`` y tiene 
la resonsabilidad de generar salida HTML y validar la entrada de 
datos. 

Los campos del formulario se definen como atributos de la clase
formulario, y extienden a ``doff.forms.fields.Field`` o alguna 
de sus subclases.

Un campo tiene como atributo, de manera implícita, un ``Widget`` que se 
encarga de la repsresentación en HTML del campo particular. 
Por ejemplo, un formulario para un Autor del ejemplo
expuesto al comienzo del apartado sobre modelos, se define de la siguiente manera:

.. code-block:: javascript

    require('doff.forms.base');
    require('doff.forms.fields');
    
    var AuthorForm = type('Author', [ forms.Form ], {
        salutation: new forms.CharField({ maxlength: 10 }),
        first_name: new forms.CharField({ maxlength: 30 }),
        last_name: new forms.CharField({ maxlength: 40 }),
        email: new forms.EmailField(),
        headshot: new forms.ImageField({ upload_to: '/tmp' })
    });
    
Las instancias de ``Form`` tienen el método ``as_ul()`` y ``as_table()`` que
generan la salida HTML del formulario y son utilizados en las plantillas. Por
ejemplo:

.. code-block:: html

    <html>
        <head>
            <title>Template para formulario</title>
        </head>
        <body>
            <!-- Definición del formulario -->
            <form action="" method="POST">
                <ul>
                    <!-- Si el formulario  fue envaido en el contexto del
                    template con el nombre "form", se puede invocar el método
                    que lo muestra como items de una lista -->
                    {{ form.as_ul }}
                </ul>
                <!-- Botón de enviar -->
                <input type="submit" value="Enviar">
            </form>
        </body>
    </html>

De esta manera se muestra el formulario en la página. Cuando el usuario 
pulse en botón "Enviar" en modo desconectado (tarea realizada por el ``DOMAdapter``).

Por regla general, los formularios se encuentran en un módulo ``forms.js``, 
aunque pueden definirse al vuelo para necesidades puntuales.

Las vistas que manejas formularios suelen valerse del ``request.method`` para 
evaluar si el formulario está siendo requerido o enviado para su validación.
Por ejemplo, la siguiente vista analiza hace uso del atributo mencionado:

.. code-block:: javascript
    :linenos:
    
    // Funciones de ayuda
    require('doff.shortcuts', 'redirect', 'render_to_response');
    // Importar el formulario
    require('bookstore.core.forms', 'AuthorForm');
    // Importar el modelo
    require('bookstore.core.models', 'Author');
    
    function crear_autor(request) {
        // El formulario es para validacion
        if (request.method == "POST") { 
            var form = new AuthorForm({ data: request.POST });
            // Los datos ingresados son validos?
            if (form.is_valid()) {
                // Creamos el autor
                var autor = new Author(form.data);
                autor.save();
                // Redireccionamos a una pagina sobre el autor
                return redirect('/autores/%d'.subs(autor.id));
            }
            
            // Si el formulario no es valido, cuando se muestre
            // en el template, se marcaran los errores de validación
        } else {
            // Creamos el form vacio
            var form = new AuthorForm();
        }
        
        return render_to_response("mi_formulario", {
            form: form
        });
    
    }

Una instancia de formulario puede estar en uno de dos estados: *bound*
(vinculado) o *unbound* (no vinculado). Una instancia vinculada se
construye con un arreglo asociativo (como en la linea 11 del ejemplo anterior)
y posee la capacidad de validar y volver a representar los datos con
los cuales fue construido. Un
formulario desvinculado no tiene datos asociados y simplemente tiene la
utilidad de representarse en HTML.


Validación de Datos
===================

Un formulario vinculado, tiene la responsabilidad de validar los datos
con los cuales ha sido instanciado. 

Para saber si un formulario está vinculado (*bound*) a datos válidos,
se llama al método ``is_valid()``::

.. code-block:: javascript

    form = new ContactForm({ data: request.POST })
    if (form.is_valid()):
        # Hace algo con los datos del formulario

Para acceder a los datos se puede acceder directamente al ``request.POST``, 
pero de esta manera no se saca provecho de la conversión que realiza Doff,
por ejemplo, para el caso de las fechas. Se debe utilizar en cambio
``form.clean_data``:

.. code-block:: javascript

    if (form.is_valid()) {
        var name = form.clean_data['first_name'],
            year = form.clean_data['email'];
            //...
        
    }

La validación se lleva a cabo llamado al método ``clean`` de cada campo del
formulario. La salida de cada una de esas llamadas completa el arreglo asociativo
``cleaned_data``. Finalmente se ejecuta la validación integral del fromulario
llamando al método ``clean()`` del formulario si existe.

Se puede generar validación personalizada creando una sublcase del campo en
el cual se requirea validación extra, pero existe un mecanismo abreviado que
consiste en implementar un método ``clean_nombre_campo`` directamente sobre el 
formulario. Por ejemplo:


.. code-block:: javascript

    var AuthorForm = type('Author', [ forms.Form ], {
        salutation: new forms.CharField({ maxlength: 10 }),
        first_name: new forms.CharField({ maxlength: 30 }),
        last_name: new forms.CharField({ maxlength: 40 }),
        email: new forms.EmailField(),
        headshot: new forms.ImageField({ upload_to: '/tmp' }),
        // Validación personalizada
        clean_salutation: function () {
            var salutation = self.data['salutation'];
            if (!salutation in ['mr', 'ms', 'mrs', 'miss']) {
                throw new ValidationError("%s no es un saludo válido".subs(
                    salutation);
            }
            return salutation;
        }
        
    });
    
Finalmente el orden de validación es el siguiente:

    #. ``celan()`` de cada campo del formulario (``CharField.clean()``, ``EmailField.clean()``, etc).
    
        * ``clean_<nombre_campo>`` sobre el formulario, si existiese
    
    #. ``clean()`` del fomrulario

Si en este ciclo no se captura ninguna excepción los datos son válidos, caso
contraio el formulario almacena el mensaje de error y lo presenta adecuadamente
cuando se realiza su representación. 


Creando formularios a partir de Modelos
=======================================

Construyamos algo un poquito más interesante: un formulario que
suministre los datos de un nuevo publicista a nuestra aplicación de
libros del `Capítulo 5`_.

Una regla de oro que es importante en el desarrollo de software, a la
que Django intenta adherirse, es: no te repitas (del inglés *Don't
Repeat Yourself*, abreviado DRY). Andy Hunt y Dave Thomas la definen
como sigue, en *The Pragmatic Programmer*:

    Cada pieza de conocimiento debe tener una representación única, no
    ambigua, y de autoridad, dentro de un sistema.

Nuestro modelo de la clase ``Publisher`` dice que un publicista tiene
un nombre, un domicilio, una ciudad, un estado o provincia, un país, y
un sitio web. Si duplicamos esta información en la definición del
formulario, estaríamos quebrando la regla anterior. En cambio, podemos
usar este útil atajo: ``form_for_model()``::

    from models import Publisher
    from django.newforms import form_for_model

    PublisherForm = form_for_model(Publisher)

``PublisherForm`` es una subclase de ``Form``, tal como la clase
``ContactForm`` que creamos manualmente con anterioridad. Podemos
usarla de la misma forma::

    from forms import PublisherForm

    def add_publisher(request):
        if request.method == 'POST':
            form = PublisherForm(request.POST)
            if form.is_valid():
                form.save()
                return HttpResponseRedirect('/add_publisher/thanks/')
        else:
            form = PublisherForm()
        return render_to_response('books/add_publisher.html', {'form': form})

El archivo ``add_publisher.html`` es casi idéntico a nuestra plantilla
``contact.html`` original, así que la omitimos. Recuerda además
agregar un nuevo patrón al URLconf: ``(r'^add_publisher/$',
'mysite.books.views.add_publisher')``.

Ahí se muestra un atajo más. Dado que los formularios derivados de
modelos se emplean a menudo para guardar nuevas instancias del modelo
en la base de datos, la clase del formulario creada por
``form_for_model`` incluye un conveniente método ``save()``. Este
método trata con el uso común; pero puedes ignorarlo si deseas hacer
algo más que tenga que ver con los datos suministrados.

``form_for_instance()`` es un método que está relacionado con el
anterior, y puede crear formularios preinicializados a partir de la
instancia de un modelo. Esto es útil al crear formularios "editar".

