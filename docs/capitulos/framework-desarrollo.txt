####
Doff
####

En apartados teóricos se menciono, entre otras cosas, que la creación de un
framework generalmente surge de la identificación de objetos reusables en
el desarrollo de software. Posteriormente los objetos identificadas decantan en
componentes que forman parte de una arquitectura. A estos se accede
mediante una API especifica y se añade o modifica su funcionlaidad mediante 
configuración o extensión.


En el desarrollo del framework desconectado, si bien se contaba con Django
como base, muchos aspectos no estabn claramente definidos y algunos componentes
de Django carecían de sentido en el contexto del navegador. Por esta razón
se realizaron dos proyectos [*]_ que sirvieron para identificar las piezas necesarias
de Django y mejorando el enfoque de Protopy, además de permitir crear
nuevos componentes reusables necesarios para un desarrollo simplificado.

El framework desconectado, de manera similar a Protopy, se apodó en base
a su padre y a la tarea que este cumple. Se bautizó como **Doff**, tomando
la *d* de Django y *off* de offline (desconectado), su nombre significa por
lo tanto, Django Desconectado:

    | **d** jango + **off** line = **doff**
    
.. [*] Inicialmente se creó un Blog, debido a la popularidad de este tipo de
        aplicaciones, y luego una aplicación denominada "salesman" (o
        agente de ventas viajate) que intenta explotar las posiblidades de contar
        con una aplicación web desconectada.
    
    
Arquitectura del Framework Desconectado
---------------------------------------


Doff se inció como un conjunto de modulos para Protopy. Estos módulos implementaban
diferentes componentes de Django sobre el cliente. Debido a que los módulos de 
JavaScript son recursos estáticos, se sirvieron mediante un servidor de archivos
muy simple llamado Aspen, que no requería intervensión de Django [AspenWebServer09]_.

.. [AspenWebServer09] Lawrence Akka, Christopher Baus, Chris Beaven, Steven Brown,
    Chad Whitacre,
    *Servidor Web Aspen*,
    ultimo acceso Diciembre 2008,
    http://www.zetadev.com/software/aspen/



El primer componente migrado fue el ORM, el cual se encuentra en Django
en el pauqete ``django.db.models``. La tarea de migración ayudó a perfeccionar
el sistema de tipos (clases) y el de módulos. El paquete resultante fue
``doff.db.models`` y gracias a implementar progresivamente la misma API que 
Django, fue posible realizar el mismo manejo de datos en el cliente y en el 
servidor.


Pass de Django en una URL específica (Ej: ``http://midominio.com/offline/packages/``).
La librería de JavaScript Dojo provee un sistema de renderizado de planitllas
basado en la sintaxis de Django [DojoLibDjangoTmpl09]_. Esta funcionalidad
fue migrada a Protopy y se situó en el módulo ``doff.templates``. 

Los componentes mencionados se realizaban


.. [DojoLibDjangoTmpl09] The Dojo Foundation,
    Documetnación sobre los templates de Django portados a Dojo,
    ultimo acceso Septiembre de 2009,
    http://www.dojotoolkit.org/book/dojo-book-0-9/part-5-dojox/dojox-dtl/ 

Doff hace uso del sistema de módulos de Protopy, de hecho, ``doff`` es un
paquete de Protopy. Se constituye la migración de muchos módulos de Django
al lenguaje JavaScript/Protopy.

A continuación se realiza una breve descripción de los módulos que se 
migraron y las adaptaciones que fueron necesarias realizar debido al
contexto del navegador:

.. note::
    
    Plantear el tema de:
        * django.db.models -> doff.db.models
        
        * django.http -> django.http
        
        * Migración de un proyecto
        
        * Adaptación del proyecto a JavaScript utilizando las APIs
        
        * Introspección de los modelos de Python
        
        * Presistencia en el navegador:
            
            * Instalación en el navegador del framework
            
            * Instalación en el navegador del proyecto
        
        
        * Sincronización
        
        
 


Para lograr que el paquete ``doff`` se almacene en el cliente, se utiliza la
funcionalidad provista por ``gears``. 


Mientras que un cliente se encuentre sin conexion con el servidor web, es capaz
de generar y almacenar datos usando su base de datos local. Al reestablecer
la conexion con el servidor web, estos datos deben ser transimitos a la base de
datos central para su actulizacion y posterior sincronizacion del resto de los
clinetes.

El framework fue construido con el objeto de ser compatible con los modelos y
las plantillas de django, intentando acercar así al desarrollador que tenga
experiencia en este framework.


Modelos
=======

La forma de interactuar con la base de datos es a traves de los modelos, siendo 
consistente con Django, Doff abstrae la logica de negocios dentro de los modelos.

Continuando con la linea de ejemplos se presenta a continuación una
configuración de datos básica sobre libro/autor/editor, esta estructura debe
estar contenida en un archivo models.js dentro de una aplicacion:

    var models = require('doff.db.models.base');

    var Publisher = type('Publisher', [ models.Model ], {
        name: new models.CharField({ maxlength: 30 }),
        address: new models.CharField({ maxlength: 50 }),
        city: new models.CharField({ maxlength: 60 }),
        state_province: new models.CharField({ maxlength: 30 }),
        country: new models.CharField({ maxlength: 50 }),
        website: new models.URLField()
    });

    var Author = type('Author', [ models.Model ], {
        salutation: new models.CharField({ maxlength: 10 }),
        first_name: new models.CharField({ maxlength: 30 }),
        last_name: new models.CharField({ maxlength: 40 }),
        email: new models.EmailField(),
        headshot: new models.ImageField({ upload_to: '/tmp' })
    });

    var Book = type('Book', [ models.Model ], {
        title: new models.CharField({ maxlength: 100 }),
        authors: new models.ManyToManyField(Author),
        publisher: new models.ForeignKey(Publisher),
        publication_date: new models.DateField()
    });

Cada modelo es representado por un tipo de Protopy que es un subtipo de
``doff.db.models.model.Model``. El tipo ``Model`` contiene toda la maquinaria
necesaria para hacer que los nuevos tipos sean capaces de interactuar con la
base de datos.

Cada modelo se corresponde con una tabla única de la base de datos, y cada
atributo de un modelo con una columna en esa tabla. El nombre de atributo
corresponde al nombre de columna, y el tipo de campo corresponde al tipo de
columna de la base de datos. Por ejemplo, el modelo ``Publisher`` es equivalente
a la siguiente tabla:

    CREATE TABLE "books_publisher" (
        "id" serial NOT NULL PRIMARY KEY,
        "name" varchar(30) NOT NULL,
        "address" varchar(50) NOT NULL,
        "city" varchar(60) NOT NULL,
        "state_province" varchar(30) NOT NULL,
        "country" varchar(50) NOT NULL,
        "website" varchar(200) NOT NULL
    );

La excepción a la regla una-clase-por-tabla es el caso de las relaciones
muchos-a-muchos. En el ejemplo, ``Book`` tiene un ``ManyToManyField`` llamado
``authors``. Esto significa que un libro tiene uno o más autores, pero la tabla
de la base de datos ``Book``  no tiene una columna ``authors``. En su lugar, se
crea una tabla adicional que maneja la correlación entre libros y autores.

Para una lista completa de tipos de campo y opciones de sintaxis de modelos,
ver el Apéndice B.

Finalmente, no se define explícitamente una clave primaria en ninguno de estos
modelos. A no ser que se le indique lo contrario, Doff dará automáticamente a
cada modelo un campo de clave primaria entera llamado ``id``.

Para activar los modelos en el proyecto, la aplicación que los contine debe
estar incluida en la lista de aplicaciones instaladas de Doff. Esto es, edita
el archivo ``settings.js``, y examina la variable de configuración ``INSTALLED_APPS``

Posteriormente, cuando el usuario instala la aplicación en su navegador, el
sistema recorre las aplicaciones en ``INSTALLED_APPS`` y genera el SQL para
cada modelo, creando las tablas en la base de datos. 

Doff provee entre las herramientas del desarrollador, un interprete de SQL sobre
la base de datos del cliente para conslutas.

Acceso básico a datos
---------------------

Una vez que se creo el modelo, Doff provee automáticamente una API JavaScript
de alto nivel para trabajar con estos modelos:

    >>> require('books.models', 'Publisher');
    >>> p1 = new Publisher({ name: 'Addison-Wesley', address: '75 Arlington Street',
    ...     city: 'Boston', state_province: 'MA', country: 'U.S.A.',
    ...     website: 'http://www.apress.com/'});
    >>> p1.save();
    >>> publisher_list = Publisher.objects.all();
    >>> print(array(publisher_list));
    [<Publisher: Publisher object>]

Se puede hacer mucho con la API de base de datos de Doff y para mejorar la
interactividad se recomienda implementar __str__ de Protopy. Con este
método los objetos tendran su representación en "string", es imporante que eso
sea así ya que el framework utiliza esta representacion en muchos lugares, como
templates y salidas por consola.

Insertando y actualizando datos
-------------------------------

En el ejemplo presentado anteriormente se ve cómo se hace para insertar una fila
en la base de datos, primero se crea una instancia del modelo pasando argumentos
nombrados y luego se llama al método ``save()`` del objeto:

En el caso de ``Publisher`` se usa una clave primaria autoincremental ``id``,
por lo tanto la llamada inicial a ``save()`` hace una cosa más: calcula el valor
de la clave primaria para el registro y lo establece como el valor del atributo
``id``  de la instancia.

Las subsecuentes llamadas a ``save()`` guardarán el registro en su lugar, sin
crear un nuevo registro (es decir, ejecutarán una sentencia SQL ``UPDATE`` en
lugar de un ``INSERT``).

Seleccionar objetos
-------------------

La forma de seleccionar y tamizar los datos se consige a traves de los
administradores de consultas, en el ejmplo la linea ``Publisher.objects.all()``
pide al administrador objects de Publisher que obtenga todos los registros,
internamente esto genera una consulta SQL::

    SELECT
        id, name, address, city, state_province, country, website
    FROM book_publisher;

Todos los modelos automáticamente obtienen un administrador ``objects`` que debe
ser usado cada vez que se quiera consultar sobre una instancia del modelo. El
metodo ``all()`` es un método del administrador ``objects`` que retorna todas
las filas de la base de datos. Aunque este objeto se *parece* a una lista, es
actualmente un *QuerySet* -- un objeto que representa algún conjunto de filas de
la base de datos. El Apéndice C describe QuerySets en detalle.

Cualquier búsqueda en base de datos va a seguir esta pauta general.

Filtrar datos
-------------

Aunque obtener todos los objetos es algo que ciertamente tiene su utilidad, la
mayoría de las veces lo que vamos a necesitar es manejarnos sólo con un
subconjunto de los datos. Para ello usaremos el método ``filter()``::

    >>> Publisher.objects.filter(name="Apress Publishing")
    [<Publisher: Apress Publishing>]

``filter()`` toma argumentos de palabra clave que son traducidos en las
cláusulas SQL ``WHERE`` apropiadas. El ejemplo anterior sería traducido en algo
como::

    SELECT
        id, name, address, city, state_province, country, website
    FROM book_publisher
    WHERE name = 'Apress Publishing';

Puedes pasarle a ``filter()`` múltiples argumentos para reducir las cosas aún
más::

    >>> Publisher.objects.filter(country="U.S.A.", state_province="CA")
    [<Publisher: Apress Publishing>]

Esos múltiples argumentos son traducidos a cláusulas SQL ``AND``. Por lo tanto
el ejemplo en el fragmento de código se traduce a lo siguiente::

    SELECT
        id, name, address, city, state_province, country, website
    FROM book_publisher
    WHERE country = 'U.S.A.' AND state_province = 'CA';

Notar que por omisión la búsqueda usa el operador SQL ``=`` para realizar
búsquedas exactas. Existen también otros tipos de búsquedas::

    >>> Publisher.objects.filter(name__contains="press")
    [<Publisher: Apress Publishing>]

Notar el doble guión bajo entre ``name`` y ``contains``. Del mismo modo que
Python, Django usa el doble guión bajo para indicar que algo "mágico" está
sucediendo -- aquí la parte ``__contains`` es traducida por Django en una
sentencia SQL ``LIKE``::

    SELECT
        id, name, address, city, state_province, country, website
    FROM book_publisher
    WHERE name LIKE '%press%';

Hay disponibles varios otos tipos de búsqueda, incluyendo ``icontains`` (``LIKE`` no
sensible a diferencias de mayúsculas/minúsculas), ``startswith`` y ``endswith``,
y ``range`` (consultas SQL ``BETWEEN``). El Apéndice C describe en detalle todos
esos tipos de búsqueda.

Obteniendo objetos individuales
-------------------------------

En ocasiones desearás obtener un único objeto. Para esto existe el método
``get()``::

    >>> Publisher.objects.get(name="Apress Publishing")
    <Publisher: Apress Publishing>

En lugar de una lista (o más bien, un QuerySet), este método retorna un objeto
individual. Debido a eso, una consulta cuyo resultado sean múltiples objetos
causará una excepción::

    >>> Publisher.objects.get(country="U.S.A.")
    Traceback (most recent call last):
        ...
    AssertionError: get() returned more than one Publisher -- it returned 2!

Una consulta que no retorne objeto alguno también causará una excepción::

    >>> Publisher.objects.get(name="Penguin")
    Traceback (most recent call last):
        ...
    DoesNotExist: Publisher matching query does not exist.

Ordenando datos
---------------

A medida que juegas con los ejemplos anteriores, podrías descubrir que los
objetos so devueltos en lo que parece ser un orden aleatorio. No estás
imaginándote cosas, hasta ahora no le hemos indicado a la base de datos cómo
ordenar sus resultados, de manera que simplemente estamos recibiendo datos con
algún orden arbitrario seleccionado por la base de datos.

Eso es, obviamente, un poco ***silly*** (tonto), no querríamos que una página Web que
muestra una lista de editores estuviera ordenada aleatoriamente. Así que, en la
práctica, probablemente querremos usar ``order_by()`` para reordenar nuestros
datos en listas más útiles::

    >>> Publisher.objects.order_by("name")
    [<Publisher: Apress Publishing>, <Publisher: Addison-Wesley>, <Publisher: O'Reilly>]

Esto no se ve muy diferente del ejemplo de ``all()`` anterior, pero el SQL
incluye ahora un ordenamiento específico::

    SELECT
        id, name, address, city, state_province, country, website
    FROM book_publisher
    ORDER BY name;

Podemos ordenar por cualquier campo que deseemos::

    >>> Publisher.objects.order_by("address")
    [<Publisher: O'Reilly>, <Publisher: Apress Publishing>, <Publisher: Addison-Wesley>]

    >>> Publisher.objects.order_by("state_province")
    [<Publisher: Apress Publishing>, <Publisher: Addison-Wesley>, <Publisher: O'Reilly>]

y por múltiples campos::

    >>> Publisher.objects.order_by("state_provice", "address")
     [<Publisher: Apress Publishing>, <Publisher: O'Reilly>, <Publisher: Addison-Wesley>]

También podemos especificar un ordenamiento inverso antecediendo al nombre del
campo un prefijo ``-`` (el símbolo menos)::

    >>> Publisher.objects.order_by("-name")
    [<Publisher: O'Reilly>, <Publisher: Apress Publishing>, <Publisher: Addison-Wesley>]

Aunque esta flexibilidad es útil, usar ``order_by()`` todo el tiempo puede ser
demasiado repetitivo. La mayor parte del tiempo tendrás un campo particular por
el que usualmente desearás ordenar. Es esos casos Django te permite anexar al
modelo un ordenamiento por omisión para el mismo:

.. literal-evaluado::

    class Publisher(models.Model):
        name = models.CharField(maxlength=30)
        address = models.CharField(maxlength=50)
        city = models.CharField(maxlength=60)
        state_province = models.CharField(maxlength=30)
        country = models.CharField(maxlength=50)
        website = models.URLField()

        def __str__(self):
            return self.name

        **class Meta:**
            **ordering = ["name"]**

Este fragmento ``ordering = ["name"]`` le indica a Django que a menos que se
proporcione un ordenamiento mediante ``order_by()``, todos los editores deberán
ser ordenados por su nombre.

.. exhortacion:: ¿Qué es este asunto de Meta?

    Django usa esta ``class Meta`` interna como un lugar en el cual se pueden
    especificar metadatos  adicionales acerca de un modelo. Es completamente
    opcional, pero puede realizar algunas cosas muy útiles. Examina el Apéndice
    B para conocer las opciones que puede poner bajo ``Meta``.

Encadenando búsquedas
---------------------

Has visto cómo puedes filtrar datos y has visto cómo ordenarlos. En ocasiones,
por supuesto, vas a desear realizar ambas cosas. En esos casos simplemente
"encadenas" las búsquedas entre sí::

    >>> Publisher.objects.filter(country="U.S.A.").order_by("-name")
    [<Publisher: O'Reilly>, <Publisher: Apress Publishing>, <Publisher: Addison-Wesley>]

Como podrías esperar, esto se traduce a una consulta SQL conteniendo tanto un
``WHERE`` como un ``ORDER BY``::

    SELECT
        id, name, address, city, state_province, country, website
    FROM book_publisher
    WHERE country = 'U.S.A'
    ORDER BY name DESC;

Puedes encadenar consultas en forma consecutiva tantas veces como desees. No
existe un límite para esto.

Rebanando datos
---------------

Otra necesidad común es buscar sólo un número fijo de filas. Imagina que tienes
miles de editores en tu base de datos, pero quieres mostrar sólo el primero.
Puedes hacer eso usando la sintaxis estándar de Python para el rebanado de
listas::

    >>> Publisher.objects.all()[0]
    <Publisher: Addison-Wesley>

Esto se traduce, someramente, a::

    SELECT
        id, name, address, city, state_province, country, website
    FROM book_publisher
    ORDER BY name
    LIMIT 1;

.. exhortacion::  Y más...

    Hemos sólo arañado la superficie del manejo de modelos, pero deberías ya
    conocer lo suficiente para entender todos los ejemplos del resto del libro.
    Cuando estés listo para aprender los detalles completos detrás de las
    búsquedas de objetos, échale una mirada al Apéndice C.

Eliminando objetos
------------------

Para eliminar objetos, simplemente se debe llamar al método ``delete()`` del objeto:

    >>> p = Publisher.objects.get({ name: "Addison-Wesley" });
    >>> p.delete();
    >>> array(Publisher.objects.all());
    []

Se pueden borrar objetos al por mayor llamando a ``delete()`` en el resultado de
una búsqueda::

    >>> publishers = Publisher.objects.all();
    >>> publishers.delete();
    >>> array(Publisher.objects.all());
    []

.. note:: 

    Mixin en RemoteSite, los modelos se registran en RemoteSite o se pueden hacer a mano.
    Hacer la referencia correspondiente al anexo de modelos

Plantillas
==========

Doff brinda soporte al sistema de plantillas de Django. La idea detras de esto
es que las plantillas escritas para una apilcacion on-line en Django pueda ser
utilizada en la aplicación off-line de una forma consistente.

.. note::

	Existen sin emabargo algunos factores a tener en cuenta a la hora de
	realizar plantillas para aplicaciones offline. Cuando una aplicación se
	ejecuta de manera desconectada, el browser solo realiza una carga de documento
	y la navegación se basa en la inserción y supresión de nodos sobre el elemento
	document. Esto implica que el estado de la aplicación

Retomando el ejemplo presentado en la seccion de plantillas en Django,
continuamos desde aquí describiendo como es el trabajo con esta plantilla en
Doff.

Rapidamente, la forma de obtener un producto de la plantilla es:

    # Crea un objeto ``Template`` brindando el código crudo de la plantilla
       como una cadena.

    # Llama al método ``render()`` del objeto ``Template`` con un conjunto de
       variables (o sea, el contexto). Este retorna una plantilla totalmente
       renderizada como una cadena de caracteres, con todas las variables y
       etiquetas de bloques evaluadas de acuerdo al contexto.

Creación de objetos Template
----------------------------

Doff provee su versión del objeto ``Template`` para crear plantillas, y esté
puede ser importado del módulo ``doff.template.base``, el argumento para la
construccion del objeto es el texto en crudo de la plantilla. 

    >>> require('doff.template.base', 'Template');
    >>> t = new Template("Mi nombre es {{ name }}.");
    >>> print(t);

En este ejemplo `t` es un objeto template listo para ser renderizado. Si se
obtubo el objeto es porque la plantilla esta correctamente analizada y no se
econtraron errores en la misma, algunos errores por los que puede fallar la
construccion son:

    * Bloques de etiquetas inválidos
    * Argumentos inválidos de una etiqueta válida
    * Filtros inválidos
    * Argumentos inválidos para filtros válidos
    * Sintaxis de plantilla inválida
    * Etiquetas de bloque sin cerrar (para etiquetas de bloque que requieran la
      etiqueta de cierre)

En todos los casos el sistema lanza una excepción ``TemplateSyntaxError``.

Renderizar una plantilla
------------------------

Una vez que se tiene el objeto ``Template``, se esta en condiciones de obtener
una salida procesada en un determinado *contexto*. Un contexto es simplemente un
conjunto de variables y sus valores asociados. Una plantilla usa las variables
para poblar la plantilla evaluando las etiquetas de bloque.

El contexto esta representado en el tipo ``Context``, el cual se encuentra en el
módulo ``doff.template.base``. La construccion del objeto toma un argumento
opcional: un hash mapeando nombres de variables con valores. La llamada al
método ``render()`` del objeto ``Template`` con el contexto "rellena" la
plantilla::

    >>> requiere('doff.template.base', 'Context', 'Template');
    >>> t = new Template("Mi nombre es {{ name }}.")
    >>> c = new Context({"name": "Pedro"})
    >>> t.render(c)
    'My name is Pedro.'

El objeto ``Template`` puede ser renderizado con múltiples contextos, obteniendo
así salidas diferentes para la misma plantilla. Por cuestiones de eficiencia es
conveniente crear un objeto ``Template`` y luego llamar a ``render()``
sobre este muchas veces::

    # Mal chico
    for each (var name in ['John', 'Julie', 'Pat']) {
        var t = new Template('Hello, {{ name }}');
        print(t.render(new Context({'name': name})));
    }

    # Buen chico
    t = new Template('Hello, {{ name }}');
    for each (var name in ['John', 'Julie', 'Pat'])
        print(t.render(new Context({'name': name})));

Al igual que en Django el objeto contexto puede contener variables mas complejas
y la forma de inspeccionar dentro de estas es con el operador `.`. Usando el
punto se puede acceder a objetos, atributos, índices, o métodos de un objeto.

Cuando un sistema de plantillas encuentra un punto en una variable el orden de
busqueda es el siguiente:

    * Diccionario (por ej. ``foo["bar"]``)
    * Atributo (por ej. ``foo.bar``)
    * Llamada de método (por ej. ``foo.bar()``)
    * Índice de lista (por ej. ``foo[bar]``)

El sistema utiliza el primer tipo de búsqueda que funcione. Es la lógica de
cortocircuito.

Para terminar con este objeto, si una variable no existe en el contexto, el
sistema de plantillas renderiza este como un string vacío, fallando
silenciosamente. Es posible cambiar este comportamiento modificando el valor de
la variable de configuración `TEMPLATE_STRING_IF_INVALID` en el módulo
`settings`.

Cargador de plantillas
----------------------

Se ve a continuación un ejemplo de una vista que retorna HTML generado por una
plantilla::

    require('doff.template.base', 'Template', 'Context');
    require('doff.utils.http', 'HttpResponse');
    require('doff.template.loader', 'get_template');

    function current_datetime(request) {
        var t = get_template('mytemplate.html');
        html = t.render(new Context({'current_date': new Date()}))
        return new HttpResponse(html);
    }

En esta vista se utiliza la API para cargar plantillas, a la cual se accede 
mediante la funcion `get_template`, antes de poder utilizar esta funcion es
necesario indicarle al framework donde están las plantillas. El lugar para hacer
esto es en el *archivo de configuración*.

Existen varios cargadores de plantillas que se pueden habilitar en el archivo de 
configuración, este se vera en profundidad en el Apéndice E, por ahora se vera
el cargador realacionado con la variable de configuración ``TEMPLATE_URL``. Esta
variable le indica al mecanismo de carga de plantillas dónde buscar las
plantillas. Por omisión, ésta es una cadena vacia. El valor para esta varible es
la url del servidor en donde se sirven los templates que se renderizan
localmente, por defecto si no se especifica la variable los archivos se buscan
en la base del soporte off-line /templates/.

.. note:: 

    Terminar esto. con el tema de la base del soporte off-line
    Introducir el concepto al inicio de doff
    Hacer la referencia correspondiente al anexo de plantillas

Formularios
===========

--------------------------------  TIENE PONIES ----------------------------------

.. ========================================
.. Capítulo 7: Procesamiento de formularios
.. ========================================

**Autor invitado: Simon Willison**

Si has estado siguiendo el capítulo anterior, ya deberías tener un
sitio completamente funcional, aunque un poco simple. En este capítulo
trataremos con la próxima pieza del juego: cómo construir vistas que
obtienen entradas desde los usuarios.

Comenzaremos haciendo un simple formulario de búsqueda "a mano",
viendo cómo manejar los datos suministrados al navegador. Y a partir
de ahí, pasaremos al uso del *framework* de formularios que trae
Django.

Búsquedas
=========

En la Web todo se trata de búsquedas. Dos de los casos de éxito más
grandes, Google y Yahoo, han construido sus empresas multimillonarias
alrededor de las búsquedas. Casi todos los sitios observan un gran
porcentaje de tráfico viniendo desde y hacia sus páginas de
búsqueda. A menudo, la diferencia entre el éxito y el fracaso de un
sitio, lo determina la calidad de su búsqueda. Así que sería mejor que
agreguemos un poco de búsqueda a nuestro pequeño sitio de libros, ¿no?

Comenzaremos agregando la vista para la búsqueda a nuestro URLconf
(``mysite.urls``). Recuerda que esto se hace agregando algo como
``(r'^search/$', 'mysite.books.views.search')`` al conjunto de URL patterns
(patrones).

A continuación, escribiremos la vista ``search`` en nuestro módulo de vistas
(``mysite.books.views``)::

    from django.db.models import Q
    from django.shortcuts import render_to_response
    from models import Book

    def search(request):
        query = request.GET.get('q', '')
        if query:
            qset = (
                Q(title__icontains=query) |
                Q(authors__first_name__icontains=query) |
                Q(authors__last_name__icontains=query)
            )
            results = Book.objects.filter(qset).distinct()
        else:
            results = []
        return render_to_response("books/search.html", {
            "results": results,
            "query": query
        })

Aquí han surgido algunas cosas que todavía no vimos. La primera, ese
``request.GET``. Así es cómo accedes a los datos del GET desde Django;
Los datos del POST se acceden de manera similar, a través de un objeto
llamado ``request.POST``. Estos objetos se comportan exactamente como
los diccionarios estándar de Python, y tienen además otras
capacidades, que se cubren en el apéndice H.

.. exhortacion:: ¿Qué son estos datos del GET y del POST?

    GET y POST son los dos métodos que emplean los navegadores para
    enviar datos a un servidor. Los encontrarás con frecuencia en los
    elementos *form* de HTML::

        <form action="/books/search/" method="get">

    Esto le indica al navegador que suministre los datos del
    formulario a la URL ``/books/search/`` empleando el método GET.

    Hay diferencias de semántica importantes entre el GET y el POST,
    que no vamos a ver ahora mismo, pero diríjete a
    http://www.w3.org/2001/tag/doc/whenToUseGet.html si quieres
    aprender más.

Así que la línea::

    query = request.GET.get('q', '')

busca un parámetro del GET llamado ``q`` y retorna una cadena de texto
vacía si este parámetro no fue suministrado. Observa que estamos
usando el método ``get()`` de ``request.GET``, algo potencialmente
confuso. Este método ``get()`` es el mismo que posee cualquier
diccionario de Python. Lo estamos usando aquí para ser precavidos:
*no* es seguro asumir que ``request.GET`` tiene una clave ``'q'``, así
que usamos ``get('q', '')`` para proporcionar un valor por omisión,
que es ``''`` (el string vacío). Si hubiéramos intentado acceder a la
variable simplemente usando ``request.GET['q']``, y ``q`` no hubiese
estado disponible en los datos del GET, se habría lanzado un
``KeyError``.

Segundo, ¿qué es ese ``Q``? Los objetos ``Q`` se utilizan para ir
construyendo consultas complejas -- en este caso, estamos buscando los
libros que coincidan en el título o en el nombre con la
consulta. Técnicamente, estos objetos ``Q`` consisten de un QuerySet,
y puede leer más sobre esto en el apéndice C.

En estas consultas, ``icontains`` es una búsqueda en la que no se
distinguen mayúsculas de minúsculas (*case-insensitive*), y que
internamente usa el operador ``LIKE`` de SQL en la base de datos.

Dado que estamos buscando en campos de muchos-a-muchos, es posible que
un libro se obtenga más de una vez (por ej: un libro que tiene dos
autores, y los nombres de ambos concuerdan con la consulta). Al
agregar ``.distinct()`` en el filtrado, se eliminan los resultados
duplicados.

Todavía no hay una plantilla para esta vista. Esto lo solucionará::

    <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
    <html lang="en">
    <head>
        <title>Search{% if query %} Results{% endif %}</title>
    </head>
    <body>
      <h1>Search</h1>
      <form action="." method="GET">
        <label for="q">Search: </label>
        <input type="text" name="q" value="{{ query|escape }}">
        <input type="submit" value="Search">
      </form>

      {% if query %}
        <h2>Results for "{{ query|escape }}":</h2>

        {% if results %}
          <ul>
          {% for book in results %}
            <li>{{ book|escape }}</l1>
          {% endfor %}
          </ul>
        {% else %}
          <p>No books found</p>
        {% endif %}
      {% endif %}
    </body>
    </html>

A esta altura, lo que esto hace debería ser obvio. Sin embargo, hay
unas pocas sutilezas que vale la pena resaltar:

    * *action* es ``.`` en el formulario, esto significa "la URL
      actual". Esta es una buena práctica estándar: no utilices vistas
      distintas para la página que contiene el formulario y para la
      página con los resultados; usa una página única para las dos
      cosas.

    * Volvemos a insertar el texto de la consulta en el
      ``<input>``. Esto permite a los usuarios refinar fácilmente sus
      búsquedas sin tener que volver a teclear todo nuevamente.

    * En todo lugar que aparece ``query`` y ``book``, lo pasamos por
      el filtro ``escape`` para asegurarnos de que cualquier búsqueda
      potencialmente maliciosa sea descartada antes de que se inserte
      en la página

      ¡Es *vital* hacer esto con todo el contenido suministrado por el
      usuario! De otra forma el sitio se abre a ataques de cross-site
      scripting (XSS). El `Capítulo 19`_ discute XSS y la seguridad con
      más detalle.

    * En cambio, no necesitamos preocuparnos por el contenido
      malicioso en las búsquedas de la base de datos -- podemos pasar
      directamente la consulta a la base de datos. Esto es posible
      gracias a que la capa de base de datos de Django se encarga de
      manejar este aspecto de la seguridad por ti.

Ahora ya tenemos la búsqueda funcionando. Se podría mejorar más el
sitio colocando el formulario de búsqueda en cada página (esto es, en
la plantilla base). Dejaremos esto de tarea para el hogar.

A continuación veremos un ejemplo más complejo. Pero antes de hacerlo,
discutamos un tópico más abstracto: el "formulario perfecto".

El "formulario perfecto"
========================

Los formularios pueden ser a menudo una causa importante de
frustración para los usuarios de tu sitio. Consideremos el
comportamiento de un hipotético formulario perfecto:

    * Debería pedirle al usuario cierta información, obviamente. La
      accesibilidad y la usabilidad importan aquí. Así que es
      importante el uso inteligente del elemento ``<label>`` de HTML,
      y también lo es proporcionar ayuda contextual útil.

    * Los datos suministrados deberían ser sometidos a una validación
      extensiva. La regla de oro para la seguridad de una aplicación
      web es "nunca confíes en la información que ingresa". Así que la
      validación es esencial.

    * Si el usuario ha cometido algún error, el formulario debería
      volver a mostrarse, junto a mensajes de error detallados e
      informativos. Los campos deberían rellenarse con los datos
      previamente suministrados, para evitarle al usuario tener que
      volver a tipear todo nuevamente.

    * El formulario debería volver a mostrarse una y otra vez, hasta
      que todos los campos se hayan rellenado correctamente.

¡Construir el formulario perfecto pareciera llevar mucho trabajo! Por
suerte, el *framework* de formularios de Django está diseñado para
hacer la mayor parte del trabajo por ti. Se le proporciona una
descripción de los campos del formulario, reglas de validación, y una
simple plantilla, y Django hace el resto. El resultado es un
"formulario perfecto" que requiere de muy poco esfuerzo.

Creación de un formulario para comentarios
==========================================

La mejor forma de construir un sitio que la gente ame es atendiendo a
sus comentarios. Muchos sitios parecen olvidar esto; ocultan los
detalles de su contacto en *FAQs*, y parecen dificultar lo más posible
el encuentro con las personas.

Cuando tu sitio tiene millones de usuarios, esto puede ser una
estrategia razonable. En cambio, cuando intentas formarte una
audiencia, deberías pedir comentarios cada vez que se presente la
oportunidad. Escribamos entonces un simple formulario para
comentarios, y usémoslo para ilustrar al *framework* de Django en
plena acción.

Comenzaremos agregando ``(r'^contact/$',
'mysite.books.views.contact')`` al URLconf, y luego definamos nuestro
formulario. Los formularios en Django se crean de una manera similar a
los modelos: declarativamente, empleando una clase de Python. He aquí
la clase para nuestro simple formulario. Por convención, lo
insertaremos en un nuevo archivo ``forms.py`` dentro del directorio de
nuestra aplicación::

    from django import newforms as forms

    TOPIC_CHOICES = (
        ('general', 'General enquiry'),
        ('bug', 'Bug report'),
        ('suggestion', 'Suggestion'),
    )

    class ContactForm(forms.Form):
        topic = forms.ChoiceField(choices=TOPIC_CHOICES)
        message = forms.CharField()
        sender = forms.EmailField(required=False)

.. exhortacion:: *¿"New" Forms?* ¿Qué?

    Cuando Django fue lanzado al público por primera vez, poseía un
    sistema de formularios complicado y confuso. Como hacía muy
    dificultosa la producción de formularios, fue rescrito y ahora se
    llama *"newforms"* (nuevos formularios). Sin embargo, como todavía
    hay cierta cantidad de código que depende del "viejo" sistema de
    formularios, Django actualmente viene con ambos paquetes.

    Al momento de escribir ese libro, el viejo sistema de formularios
    de Django sigue disponible como ``django.forms``, y el nuevo
    paquete como ``django.newforms``. En algún momento esto va a
    cambiar, y ``django.forms`` hará referencia al nuevo paquete de
    formularios. Sin embargo, para estar seguros de que los ejemplos
    de este libro funcionen lo más ampliamente posible, todos harán
    referencia a ``django.newforms``.

Un formulario de Django es una subclase de ``django.newforms.Form``,
tal como un modelo de Django es una subclase de
``django.db.models.Model``. El módulo ``django.newforms`` también
contiene cierta cantidad de clases ``Field`` para los campos. Una
lista completa de éstas últimas se encuentra disponible en la
documentación de Django, en
http://www.djangoproject.com/documentation/0.96/newforms/.

Nuestro ``ContactForm`` consiste de tres campos: un tópico, que se
puede elegir entre tres opciones; un mensaje, que es un campo de
caracteres; y un emisor, que es un campo de correo electrónico y es
opcional (porque incluso los comentarios anónimos pueden ser
útiles). Hay una cantidad de otros tipos de campos disponibles, y
puedes escribir nuevos tipos si ninguno cubre tus necesidades.

El objeto formulario sabe cómo hacer una cantidad de cosas útiles por
sí mismo. Puede validar una colección de datos, puede generar sus
propios *"widgets"* de HTML, puede construir un conjunto de mensajes
de error útiles. Y si estás en perezoso, puede incluso dibujar el
formulario completo por ti. Incluyamos esto en una vista y veámoslo en
acción. En ``views.py``:

.. literal-evaluado::

    from django.db.models import Q
    from django.shortcuts import render_to_response
    from models import Book
    **from forms import ContactForm**

    def search(request):
        query = request.GET.get('q', '')
        if query:
            qset = (
                Q(title__icontains=query) |
                Q(authors__first_name__icontains=query) |
                Q(authors__last_name__icontains=query)
            )
            results = Book.objects.filter(qset).distinct()
        else:
            results = []
        return render_to_response("books/search.html", {
            "results": results,
            "query": query
        })

    **def contact(request):**
        **form = ContactForm()**
        **return render_to_response('contact.html', {'form': form})**

y en ``contact.html``::

    <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
    <html lang="en">
    <head>
        <title>Contact us</title>
    </head>
    <body>
        <h1>Contact us</h1>
        <form action="." method="POST">
            <table>
                {{ form.as_table }}
            </table>
            <p><input type="submit" value="Submit"></p>
        </form>
    </body>
    </html>

La línea más interesante aquí es ``{{ form.as_table }}``. ``form`` es
nuestra instancia de ContactForm, que fue pasada al
``render_to_response``. ``as_table`` es un método de ese objeto que
reproduce el formulario como una secuencia de renglones de una tabla
(también pueden usarse ``as_ul`` y ``as_p``). El HTML generado se ve
así::

    <tr>
        <th><label for="id_topic">Topic:</label></th>
        <td>
            <select name="topic" id="id_topic">
                <option value="general">General enquiry</option>
                <option value="bug">Bug report</option>
                <option value="suggestion">Suggestion</option>
            </select>
        </td>
    </tr>
    <tr>
        <th><label for="id_message">Message:</label></th>
        <td><input type="text" name="message" id="id_message" /></td>
    </tr>
    <tr>
        <th><label for="id_sender">Sender:</label></th>
        <td><input type="text" name="sender" id="id_sender" /></td>
    </tr>

Observa que las etiquetas ``<table>`` y ``<form>`` no se han incluido;
debes definirlas por tu cuenta en la plantilla. Esto te da control
sobre el comportamiento del formulario al ser suministrado. Los
elementos *label* sí se incluyen, y proveen a los formularios de
accesibilidad "desde fábrica".

Nuestro formulario actualmente utiliza un *widget* ``<input
type="text">`` para el campo del mensaje. Pero no queremos restringir
a nuestros usuarios a una sola línea de texto, así que la cambiaremos
por un *widget* ``<textarea>``:

.. literal-evaluado::

    class ContactForm(forms.Form):
        topic = forms.ChoiceField(choices=TOPIC_CHOICES)
        message = forms.CharField(**widget=forms.Textarea()**)
        sender = forms.EmailField(required=False)

El *framework* de formularios divide la lógica de presentación para
cada campo, en un conjunto de *widgets*. Cada tipo de campo tiene un
*widget* por defecto, pero puedes sobreescribirlo fácilmente, o
proporcionar uno nuevo de tu creación.

Por el momento, si se suministra el formulario, no sucede
nada. Agreguemos nuestras reglas de validación::

    def contact(request):
        if request.method == 'POST':
            form = ContactForm(request.POST)
        else:
            form = ContactForm()
        return render_to_response('contact.html', {'form': form})

Una instancia de formulario puede estar en uno de dos estados: *bound*
(vinculado) o *unbound* (no vinculado). Una instancia *bound* se
construye con un diccionario (o un objeto que funcione como un
diccionario) y sabe cómo validar y volver a representar sus datos. Un
formulario *unbound* no tiene datos asociados y simplemente sabe cómo
representarse a sí mismo.

Intenta hacer clic en *Submit* en el formulario vacío. La página se
volverá a cargar, mostrando un error de validación que informa que
nuestro campo de mensaje es obligatorio.

Intenta también ingresar una dirección de correo electrónico
inválida. El ``EmailField`` sabe cómo validar estas direcciones, por
lo menos a un nivel razonable.

.. exhortacion:: Cómo especificar datos iniciales

    Al pasar datos directamente al constructor del formulario, estos
    se vinculan, y se indica que la validación debe ser efectuada. A
    menudo, necesitamos mostrar un formulario inicial con algunos
    campos previamente rellenados -- por ejemplo, en un formulario
    "editar". Podemos hacerlo con el argumento de palabras claves
    ``initial``::

        form = CommentForm(initial={'sender': 'user@example.com'})

    Si nuestro formulario *siempre* usará los mismos valores por
    defecto, podemos configurarlos en la definición misma del
    formulario:

    .. literal-evaluado::

        message = forms.CharField(widget=forms.Textarea(),
                                  **initial="Replace with your feedback"**)

Procesamiento de los datos suministrados
========================================

Una vez que el usuario ha llenado el formulario al punto de que pasa
nuestras reglas de validación, necesitamos hacer algo útil con los
datos. En este caso, deseamos construir un correo electrónico que
contenga los comentarios del usuario, y enviarlo. Para esto, usaremos
el paquete de correo electrónico de Django.

Pero antes, necesitamos saber si los datos son en verdad válidos, y si
lo son, necesitamos una forma de accederlos. El *framework* de
formularios hace más que validar los datos, también los convierte a
tipos de datos de Python. Nuestro formulario para comentarios sólo
trata con texto, pero si estamos usando campos como ``IntegerField`` o
``DateTimeField``, el *framework* de formularios se encarga de que se
devuelvan como un valor entero de Python, o como un objeto
``datetime``, respectivamente.

Para saber si un formulario está vinculado (*bound*) a datos válidos,
llamamos al método ``is_valid()``::

    form = ContactForm(request.POST)
    if form.is_valid():
        # Process form data

Ahora necesitamos acceder a los datos. Podríamos sacarlos directamente
del ``request.POST``, pero si lo hiciéramos, no nos estaríamos
beneficiando de la conversión de tipos que realiza el *framework* de
formularios. En cambio, usamos ``form.clean_data``::

    if form.is_valid():
        topic = form.clean_data['topic']
        message = form.clean_data['message']
        sender = form.clean_data.get('sender', 'noreply@example.com')
        # ...

Observa que dado que ``sender`` no es obligatorio, proveemos un valor
por defecto por si no fue proporcionado. Finalmente, necesitamos
registrar los comentarios del usuario. La manera más fácil de hacerlo
es enviando un correo electrónico al administrador del sitio. Podemos
hacerlo empleando la función::

    from django.core.mail import send_mail

    # ...

    send_mail(
        'Feedback from your site, topic: %s' % topic,
        message, sender,
        ['administrator@example.com']
    )

La función ``send_mail`` tiene cuatro argumentos obligatorios: el
asunto y el cuerpo del mensaje, la dirección del emisor, y una lista
de direcciones destino. ``send_mail`` es un código conveniente que
envuelve a la clase ``EmailMessage`` de Django. Esta clase provee
características avanzadas como adjuntos, mensajes multiparte, y un
control completo sobre los encabezados del mensaje.

Una vez enviado el mensaje con los comentarios, redirigiremos a
nuestro usuario a una página estática de confirmación. La función de
la vista finalizada se ve así::

    from django.http import HttpResponseRedirect
    from django.shortcuts import render_to_response
    from django.core.mail import send_mail
    from forms import ContactForm

    def contact(request):
        if request.method == 'POST':
            form = ContactForm(request.POST)
            if form.is_valid():
                topic = form.clean_data['topic']
                message = form.clean_data['message']
                sender = form.clean_data.get('sender', 'noreply@example.com')
                send_mail(
                    'Feedback from your site, topic: %s' % topic,
                    message, sender,
                    ['administrator@example.com']
                )
                return HttpResponseRedirect('/contact/thanks/')
        else:
            form = ContactForm()
        return render_to_response('contact.html', {'form': form})

.. exhortacion:: Redirigir luego del POST

    Si un usuario selecciona actualizar sobre una página que muestra una
    consulta POST, la consulta se repetirá. Esto probablemente lleve a
    un comportamiento no deseado, por ejemplo, que el registro se
    agregue dos veces a la base de datos. Redirigir luego del POST es
    un patrón útil que puede ayudar a prevenir este escenario. Así que
    luego de que se haya procesado el POST con éxito, redirige al
    usuario a otra página en lugar de retornar HTML directamente.

Nuestras propias reglas de validación
=====================================

Imagina que hemos lanzado al público a nuestro formulario de
comentarios, y los correos electrónicos han empezado a llegar. Nos
encontramos con un problema: algunos mensajes vienen con sólo una o
dos palabras, es poco probable que tengan algo interesante. Decidimos
adoptar una nueva póliza de validación: cuatro palabras o más, por
favor.

Hay varias formas de insertar nuestras propias validaciones en un
formulario de Django. Si vamos a usar nuestra regla una y otra vez,
podemos crear un nuevo tipo de campo. Sin embargo, la mayoría de las
validaciones que agreguemos serán de un solo uso, y pueden agregarse
directamente a la clase del formulario.

En este caso, necesitamos validación adicional sobre el campo
``message``, así que debemos agregar un método ``clean_message`` a
nuestro formulario::

    class ContactForm(forms.Form):
        topic = forms.ChoiceField(choices=TOPIC_CHOICES)
        message = forms.CharField(widget=forms.Textarea())
        sender = forms.EmailField(required=False)

        def clean_message(self):
            message = self.clean_data.get('message', '')
            num_words = len(message.split())
            if num_words < 4:
                raise forms.ValidationError("Not enough words!")
            return message

Este nuevo método será llamado después del validador que tiene el
campo por defecto (en este caso, el validador de un ``CharField``
obligatorio). Dado que los datos del campo ya han sido procesados
parcialmente, necesitamos obtenerlos desde el diccionario
``clean_data`` del formulario.

Usamos una combinación de ``len()`` y ``split()`` para contar la
cantidad de palabras. Si el usuario ha ingresado muy pocas palabras,
lanzamos un error ``ValidationError``. El texto que lleva esta
excepción se mostrará al usuario como un elemento de la lista de
errores.

Es importante que retornemos explícitamente el valor del campo al
final del método. Esto nos permite modificar el valor (o convertirlo a
otro tipo de Python) dentro de nuestro método de validación. Si nos
olvidamos de retornarlo, se retornará ``None`` y el valor original
será perdido.

Una presentación personalizada
==============================

La forma más rápida de personalizar la presentación de un formulario
es mediante CSS. En particular, la lista de errores puede dotarse de
mejoras visuales, y el elemento ``<ul>`` tiene asignada la clase
``errorlist`` para ese propósito. El CSS a continuación hace que
nuestros errores salten a la vista::

    <style type="text/css">
        ul.errorlist {
            margin: 0;
            padding: 0;
        }
        .errorlist li {
            background-color: red;
            color: white;
            display: block;
            font-size: 10px;
            margin: 0 0 3px;
            padding: 4px 5px;
        }
    </style>

Si bien es conveniente que el HTML del formulario sea generado por
nosotros, en muchos casos la disposición por defecto no quedaría bien
en nuestra aplicación. ``{{ form.as_table }}`` y similares son atajos
útiles que podemos usar mientras desarrollamos nuestra aplicación,
pero todo lo que concierne a la forma en que nuestro formulario es
representado puede ser sobreescrito, casi siempre desde la plantilla
misma.

Cada *widget* de un campo (``<input type="text">``, ``<select>``,
``<textarea>``, o similares) puede generarse individualmente
accediendo a ``{{ form.fieldname }}``. Cualquier error asociado con un
campo está disponible como ``{{ form.fieldname.errors }}``.  Podemos
usar estas variables para construir nuestra propia plantilla para el
formulario::

    <form action="." method="POST">
        <div class="fieldWrapper">
            {{ form.topic.errors }}
            <label for="id_topic">Kind of feedback:</label>
            {{ form.topic }}
        </div>
        <div class="fieldWrapper">
            {{ form.message.errors }}
            <label for="id_message">Your message:</label>
            {{ form.message }}
        </div>
        <div class="fieldWrapper">
            {{ form.sender.errors }}
            <label for="id_sender">Your email (optional):</label>
            {{ form.sender }}
        </div>
        <p><input type="submit" value="Submit"></p>
    </form>

``{{ form.message.errors }}`` se muestra como un ``<ul
class="errorlist">`` si se presentan errores y como una cadena de
caracteres en blanco si el campo es válido ( o si el formulario no
está vinculado). También podemos tratar a la variable
``form.message.errors`` como a un booleano o incluso iterar sobre la
misma como en una lista, por ejemplo::

    <div class="fieldWrapper{% if form.message.errors %} errors{% endif %}">
        {% if form.message.errors %}
            <ol>
            {% for error in form.message.errors %}
                <li><strong>{{ error|escape }}</strong></li>
            {% endfor %}
            </ol>
        {% endif %}
        {{ form.message }}
    </div>

En caso de que hubieran errores de validación, se agrega la clase
"errors" al ``<div>`` contenedor y se muestran los errores en una
lista ordenada.

Creando formularios a partir de Modelos
=======================================

Construyamos algo un poquito más interesante: un formulario que
suministre los datos de un nuevo publicista a nuestra aplicación de
libros del `Capítulo 5`_.

Una regla de oro que es importante en el desarrollo de software, a la
que Django intenta adherirse, es: no te repitas (del inglés *Don't
Repeat Yourself*, abreviado DRY). Andy Hunt y Dave Thomas la definen
como sigue, en *The Pragmatic Programmer*:

    Cada pieza de conocimiento debe tener una representación única, no
    ambigua, y de autoridad, dentro de un sistema.

Nuestro modelo de la clase ``Publisher`` dice que un publicista tiene
un nombre, un domicilio, una ciudad, un estado o provincia, un país, y
un sitio web. Si duplicamos esta información en la definición del
formulario, estaríamos quebrando la regla anterior. En cambio, podemos
usar este útil atajo: ``form_for_model()``::

    from models import Publisher
    from django.newforms import form_for_model

    PublisherForm = form_for_model(Publisher)

``PublisherForm`` es una subclase de ``Form``, tal como la clase
``ContactForm`` que creamos manualmente con anterioridad. Podemos
usarla de la misma forma::

    from forms import PublisherForm

    def add_publisher(request):
        if request.method == 'POST':
            form = PublisherForm(request.POST)
            if form.is_valid():
                form.save()
                return HttpResponseRedirect('/add_publisher/thanks/')
        else:
            form = PublisherForm()
        return render_to_response('books/add_publisher.html', {'form': form})

El archivo ``add_publisher.html`` es casi idéntico a nuestra plantilla
``contact.html`` original, así que la omitimos. Recuerda además
agregar un nuevo patrón al URLconf: ``(r'^add_publisher/$',
'mysite.books.views.add_publisher')``.

Ahí se muestra un atajo más. Dado que los formularios derivados de
modelos se emplean a menudo para guardar nuevas instancias del modelo
en la base de datos, la clase del formulario creada por
``form_for_model`` incluye un conveniente método ``save()``. Este
método trata con el uso común; pero puedes ignorarlo si deseas hacer
algo más que tenga que ver con los datos suministrados.

``form_for_instance()`` es un método que está relacionado con el
anterior, y puede crear formularios preinicializados a partir de la
instancia de un modelo. Esto es útil al crear formularios "editar".

---------------------------------------------------------------------------