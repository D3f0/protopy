####
Doff
####

En apartados teóricos se mencionó, entre otras cosas, que la creación de un
framework generalmente surge de la identificación de objetos reusables en
el desarrollo de software. Posteriormente los objetos identificados constituyen
luego componentes que forman parte de una arquitectura. A estos se accede
mediante una API especifica y se añade o modifica su funcionlaidad mediante 
configuración o extensión.


En el desarrollo del framework desconectado, si bien se contaba con Django
como base, muchos aspectos no estabn claramente definidos y algunos componentes
carecían de sentido en el contexto del navegador. Por esta razón
se realizaron dos proyectos [*]_ que sirvieron para identificar las piezas necesarias
del framework y mejorar el enfoque de Protopy, además de permitir crear
nuevos componentes reusables que no estaban presentes en Django.

El framework desconectado, de manera similar a Protopy, se apodó en base
a su padre y a la tarea que este cumple. Se bautizó como **Doff**, tomando
la *d* de Django y *off* de offline (desconectado), su nombre significa por
lo tanto, Django Desconectado:

    | **d** jango + **off** line = **doff**
    
.. [*] Inicialmente se creó una aplicación de *blog*, debido a la popularidad de este tipo de
        aplicaciones, y luego "salesman" (o agente de ventas viajate) 
        que intenta explotar las posiblidades de contar con una aplicación web desconectada.
    
    
Migración de Componetes Básicos
-------------------------------


Doff se inició como un conjunto de modulos para Protopy. Estos módulos implementaban
diferentes componentes de Django sobre el cliente. Debido a que los módulos de 
JavaScript son recursos estáticos, se sirvieron mediante un servidor de archivos
muy simple llamado Aspen, que no requería intervensión de Django [AspenWebServer09]_.

Como se mencionó en el capítulo introductorio, los compoentes que
requerían una migración directa a JavaScript eran el ORM (``django.db.models``) y 
el sistema de templates (``django.templates``). Las vistas y el sistema de URLs
deberían ser adaptadas para el contexto del navegador.

.. [AspenWebServer09] Lawrence Akka, Christopher Baus, Chris Beaven, Steven Brown,
    Chad Whitacre,
    *Servidor Web Aspen*,
    ultimo acceso Diciembre 2008,
    http://www.zetadev.com/software/aspen/


El primer componente de Django migrado fue ``django.db.models``, el cual se realizó
simplificando algunos aspectos como el soporte para múltiples bases de datos, ya
que Gears solo provee SQLite.
La tarea de migración ayudó a perfeccionar el sistema de tipos (clases) y el de módulos. 
El paquete resultante fue ``doff.db.models`` y gracias a implementar progresivamente 
la misma API que Django, fue posible realizar el mismo manejo de datos en el cliente y en el 
servidor.


Las pruebas y depuración del proyecto se realizaron sobre Firebug, cargando
protopy en un archivo estático y realizando los ``require()``s correspondientes
en la consola. Por ejemplo:

.. code-block:: javascript

    // En la consola de firebug
    >>> require('doff.db.models.base');
    


.. Mientras que un cliente se encuentre sin conexion con el servidor web, es capaz
    de generar y almacenar datos usando su base de datos local. Al reestablecer
    la conexion con el servidor web, estos datos deben ser transimitos a la base de
    datos central para su actulizacion y posterior sincronizacion del resto de los
    clientes. Para plantear la tarea de sincronización es necesario contar con
    el framework funcionando desconecatdo, por lo que se postergó su analisis en esta
    etapa.
 
El siguiente componente en ser analizado y migrado fue el sistema de plantillas
(``django.templates``).
La librería de JavaScript Dojo provee un sistema de renderizado de planitllas
basado en la sintaxis de Django [DojoLibDjangoTmpl09]_. Sin embargo se optó 
por portar la propia de Django ya que la implementación de Dojo no está basada
en el sistema de módulos de Protopy. Esta funcionalidad se situó en el módulo 
``doff.templates``.


.. [DojoLibDjangoTmpl09] The Dojo Foundation,
    Documetnación sobre los templates de Django portados a Dojo,
    ultimo acceso Septiembre de 2009,
    http://www.dojotoolkit.org/book/dojo-book-0-9/part-5-dojox/dojox-dtl/ 

Definción de Proyecto y Aplicaciones Desconectadas
--------------------------------------------------

Luego de haber alcanzado un nivel de funcionalidad básico en ``doff.db.models`` y 
``doff.templates`` se definió la interacción básica con Django, mediante
la cual un proyecto en linea sería capaz de transferirse al cliente. Para
este fin se creó una aplicación Django llamada ``offline`` cuyo objetivo incial 
fue servir estáticamente el código JavaScript de Protopy y Doff.

El siguiente paso fue definir un proyecto Django desconectado, es decir, un
proyecto Doff. Se buscó el mayor grado de similitud posible con Django, donde
un proyecto es un paquete Python (con los módulos ``settings.py``, ``manage.py``
y ``urls.py``) y cada aplicación un paquete dentro de la aplicación o localizable
en el ``PYTHONPATH`` (una aplicación cuenta con los módulos ``models.py`` y
``views.py``).

En Doff, un proyecto se definió como un paquete Protopy con un módulo ``settings.js``
con la configuración del proyecto. El módulo de proyecto Django ``manage.py`` carece de 
sentido en el navegador, ya que no se cuenta con una interfase de comandos en 
JavaScript, por lo que se implementaron los comandos como fucniones en el módulo
``doff.core.project``. El módulo ``urls.js`` se reservó para análisis posterior. 

Las aplicaciones de un proyecto Doff se definieron paquetes de Protopy que se encuentran
dentro del proyecto. Constan del módulo ``views.js`` y ``models.js``. 

A diferencia de un proyecto Django, en el contexto del browser, es necesario
generar una instancia de la entidad proyecto y darle el control a ésta, para
tal fin, se implementaron los siguientes métodos en el ``doff.core.project``: 
``bootstrap``, ``syncdb`` e ``install``, ``is_installed``:

 * ``bootstrap`` debe ser llamado cada vez que se quiera ceder el control
    de la navegación a el framework desconectado. Recibe como argumento
    el nombre del poryecto. Mediante este parámetro localiza los recursos
    en el almacenamiento local provisto por gears. Si la aplicación no
    ha sido in
    
 * El método ``install`` se ecarga de
de realizar la istalación, que consiste en la copia del código del framework
Doff, del proyecto con sus aplicaciones, incluyendo plantillas en el almacenamiento
local.

El proyecto desconectado es una entidad de 
JavaScript que recibe como el nombre del proyecto y utiliza este parámetro
para localizar la base de datos y los recursos almacenados del proyecto. 

Para facilitar la instalación de proyectos se creo una etiqueta de plantilla 
(``template tag``) que incluye de manera automática Protopy, Doff y crea
un proyecto con el nombre que se pasa como parámetro. La creación de un proyecto
consitió en esta etapa en almacenar el código del Doff y el proyecto en el clinete
mediante gears.

Estos comandos tienen como finalidad la instalación del proyecto desconectado 
en el navegador del cliente.



Esta aplicación se bautizó ``offline`` e inicialmente contó con tres vistas. La primera 
fue un servidor estático de archivos, que permitía cargar Protopy en el 
navegador dentro del proyecto. Basados en esta vista y utilizando 
el almacenamiento del ``LocalServer`` provisto en Protopy en ``sys.gears``, 
se obtuvo una página desconectada que contaba con el framework Doff.



Las otras dos vistas estaban relacionadas entre si, una realizaba una búsqueda
exahustiva de plantillas en el proyecto [*]_ y la otra servía las plantillas
estáticamente. 
Con estos tres componentes se realizaron las perimers pruebas de aplicación 
desconectada.

.. [*] Utilizando la constate ``TEMPLATE_DIRS`` definida en el 
        módulo ``settings`` del proyecto.
         
A partir de estos componentes se comenzó a implementar el proyecto desconectado 
como un conjunto de aplicaciones que se definían en el módulo ``settings`` de
el proyecto Django en linea.
Las aplicaciones desconectadas consistían en paquetes de Protopy con los módulos
``views.js`` y ``models.js``. Las vistas se ejecutaban de manera manual ya que 
el sistema de URLs no se pudo traducir de manera automática debido a que no 
se cuenta con una implementación de expresiones regulares con recuperación de 
grupos nombrados y los elementos ``HTTPRequest`` requerían una implementación
adecuada a la ausencia de transporte HTTP.

El proyecto desconectado debía pasar por una etapa de instalación, en la cual
se descargaba el framework y el proyecto en el almacencamiento local y se creaban
las tablas de la base de datos.

Los siguientes apartados tratan sobre las implementaciones de la API del ORM

Modelos
=======

Doff implementa la misma API que Django, realizando las adaptaciones
a la sintaxis de JavaScript y la librería Protopy. Por lo que es posible
migrar los modelos de manera manual utilizando las mismas clases con las
que se define en el módulo ``models`` de la aplicación en línea.

A continuación se ejemplifica la implementación  en el cliente del módulo 
``models.js`` de una aplicación que consta con las entidades Libro, Autor y Editor:

.. code-block:: javascript

    // Cargar el módulo del ORM
    var models = require('doff.db.models.base');
    
    // La clase editor (Publisher) extiende de models.Model y por lo tanto
    // se crea como tabla en la base de datos
    var Publisher = type('Publisher', [ models.Model ], {
        name: new models.CharField({ maxlength: 30 }),
        address: new models.CharField({ maxlength: 50 }),
        city: new models.CharField({ maxlength: 60 }),
        state_province: new models.CharField({ maxlength: 30 }),
        country: new models.CharField({ maxlength: 50 }),
        website: new models.URLField()
    });
    
    // La clase autor (Author) extiende de models.Model y por lo tanto
    // se crea como tabla en la base de datos
    var Author = type('Author', [ models.Model ], {
        salutation: new models.CharField({ maxlength: 10 }),
        first_name: new models.CharField({ maxlength: 30 }),
        last_name: new models.CharField({ maxlength: 40 }),
        email: new models.EmailField(),
        headshot: new models.ImageField({ upload_to: '/tmp' })
    });
    
    // La clase libro (Book) extiende de models.Model y por lo tanto
    // se crea como tabla en la base de datos
    var Book = type('Book', [ models.Model ], {
        title: new models.CharField({ maxlength: 100 }),
        authors: new models.ManyToManyField(Author),
        publisher: new models.ForeignKey(Publisher),
        publication_date: new models.DateField()
    });

Cada modelo es representado por un clase de Protopy que extiende a
``doff.db.models.model.Model``. 

Cada modelo se corresponde con una tabla única de la base de datos, y cada
atributo de un modelo con una columna en esa tabla. El nombre de atributo
corresponde al nombre de columna, y el tipo de campo corresponde al tipo de
columna de la base de datos. Por ejemplo, el modelo ``Publisher`` es equivalente
a la siguiente tabla:

.. code-block:: sql

    CREATE TABLE "books_publisher" (
        "id" serial NOT NULL PRIMARY KEY,
        "name" varchar(30) NOT NULL,
        "address" varchar(50) NOT NULL,
        "city" varchar(60) NOT NULL,
        "state_province" varchar(30) NOT NULL,
        "country" varchar(50) NOT NULL,
        "website" varchar(200) NOT NULL
    );

La excepción a la regla de una clase por tabla es el caso de las relaciones
muchos a muchos. En el ejemplo, ``Book`` tiene un ``ManyToManyField`` llamado
``authors``. Esto significa que un libro tiene uno o más autores, pero la tabla
de la base de datos ``Book``  no tiene una columna ``authors``. En su lugar, se
crea una tabla adicional que maneja la correlación entre libros y autores.


Finalmente, no se define explícitamente una clave primaria en ninguno de estos
modelos. A no ser que se le indique lo contrario, Doff dará automáticamente a
cada modelo un campo de clave primaria entera autoincremental llamado ``id``.

Para activar los modelos en el proyecto, la aplicación que los contine debe
estar incluida en la lista de aplicaciones instaladas de Doff. En consonancia
con Django, esta configuración se realiza en el módulo ``settings.js`` en
la variable de configuración ``INSTALLED_APPS``.
Suponiendo que este archivo se encuentre en ``bookstore/models.js``, el nombre de 
la aplicación sería ``bookstore``.



Cuando el usuario instala el proyecto para operación desconectada en su navegador, el
sistema recorre las aplicaciones en ``INSTALLED_APPS`` y genera el SQL para
cada modelo, creando las tablas en la base de datos. 

Además de implementar la API de consultas, el desarrollador puede realizar
``queries`` en SQL sobre la base de datos del cliente mediante las herramientas
de desarrollador provistas por Doff.


Creación y Recuperación de Datos
--------------------------------

Una vez que se creo el modelo, Doff provee automáticamente una API JavaScript
de alto nivel para trabajar con estos modelos muy similar a la de Django:

    >>> require('books.models', 'Publisher');
    >>> p1 = new Publisher({ name: 'Addison-Wesley', address: '75 Arlington Street',
    ...     city: 'Boston', state_province: 'MA', country: 'U.S.A.',
    ...     website: 'http://www.apress.com/'});
    // Guardado de la instancia
    >>> p1.save();
    // Recuperación mediante le Manager
    >>> publisher_list = Publisher.objects.all();
    // Mostrar el resultado de la consulta
    >>> print(array(publisher_list));
    [<Publisher: Publisher object>]
    
    
En la última linea del ejemplo anterior, se ve que en el listado no
aparece una representación adecuada de la instacia de Editor. Esto
responde a que en la definción del modelo no se incluyó un método de 
pasaje a cadena, o ``__str__``. Se puede implementar este método para 
mejorar la depuración.


Inserción y Actualización de Datos
----------------------------------

En el ejemplo presentado anteriormente se mostró la forma de realizar una
inseción de una fila en la base de datos. Primero se crea una instancia del 
modelo pasando argumentos nombrados y 
luego se llama al método ``save()`` de la intancia.

En el caso de ``Publisher`` se usa una clave primaria autoincremental ``id``,
por lo tanto la llamada inicial a ``save()`` hace una cosa más: calcula el valor
de la clave primaria para el registro y lo establece como el valor del atributo
``id``  de la instancia.

Las subsecuentes llamadas a ``save()`` guardarán el registro en su lugar, sin
crear un nuevo registro (es decir, ejecutarán una sentencia SQL ``UPDATE`` en
lugar de un ``INSERT``).

``Managers`` y ``QuerySet``s en el Cliente 
------------------------------------------

La forma de seleccionar y filtrar los datos es la utilización de ``Managers``
o administradores de consultas.

En el ejmplo la linea ``Publisher.objects.all()`` del ejemplo anterior, se solicita
al administrador ``objects`` de Publisher que obtenga todos los registros,
internamente esto genera una consulta SQL::

    SELECT
        id, name, address, city, state_province, country, website
    FROM book_publisher;

Todos los modelos automáticamente obtienen un administrador ``objects`` que debe
ser usado cada vez que se quiera consultar sobre una instancia del modelo.
El metodo ``all()`` es un método del administrador ``objects`` que retorna todas
las filas de la base de datos. Al igual que en Django, el valor retornado
es un ``QuerySet``.

En el caso de requerir una fila o conjunto en particular, se utilzia el método
``filter``. Por ejemplo:

.. code-block:: javascript

    >>> Publisher.objects.filter({name : "Apress Publishing"})
    [<Publisher: Apress Publishing>]

``filter()`` toma argumentos del tipo arreglo asociativo que son traducidos en las
cláusulas SQL ``WHERE`` apropiadas, concatenando con el operador ``AND`` en el 
caso de tener más de un parámetro. El ejemplo anterior sería traducido en la
siguiente consulta:

.. code-block:: sql

    SELECT
        id, name, address, city, state_province, country, website
    FROM book_publisher
    WHERE name = 'Apress Publishing';

En las claves de los parámetros del arreglo asociativo de ``filter`` pueden
contener subargumentos separados por dobles guiones bajos, por ejemplo:

.. code-block:: javascript 

    >>> Publisher.objects.filter({name__contains : "press"})
    [<Publisher: Apress Publishing>]

Busca los Editores en los cuales su nombre contenga la palabra "press".

Esto se traduce en la secuencia SQL:

.. code-block:: sql

    SELECT
        id, name, address, city, state_province, country, website
    FROM book_publisher
    WHERE name LIKE '%press%';

Hay disponibles varios otos tipos de subargumentos de búsqueda, 
incluyendo ``icontains`` (``LIKE`` no sensible a diferencias de mayúsculas/minúsculas), 
``startswith`` y ``endswith``, y ``range`` (consultas SQL ``BETWEEN``). 
El Apéndice C describe en detalle todos esos tipos de búsqueda.

Cuando se requiere obtener un único objeto dada una condición, los
administradores de consutlas brindan el método ``get()``:

.. code-block:: javascript

    >>> Publisher.objects.get({name : "Apress Publishing"})
    <Publisher: Apress Publishing>

En lugar de un ``QuerySet``, este método retorna un objeto
individual. Debido a eso, una consulta cuyo resultado sean múltiples objetos
causará una excepción así mismo como una consulta que no retorne objeto alguno.

Generalmente se requiere que los resultados de los ``QuerySet`` posean un
orden determinaodo por algun campo, para esto está disponible el método 
``order_by()``. Por ejemplo, para un listado de Editores, ordenados por el
campo nombre:

    >>> Publisher.objects.order_by("name")
    [<Publisher: Apress Publishing>, <Publisher: Addison-Wesley>, <Publisher: O'Reilly>]

El ejemplo anterior es similar a la invocación de ``all()``, pero la consulta SQL
incluye un parámetro extra: 

.. code-bloc:: sql

    SELECT
        id, name, address, city, state_province, country, website
    FROM book_publisher
    ORDER BY name;

El ordenamiento puede realizarse por cualquier campo ordenable (cadenas, enteros, 
fechat, esc.) y además por múltiples campos. Si se antepone al nombre del campo
un guión, el ordenamiento es inverso. Por ejemplo:

.. code-block:: javascript

    >>> Publisher.objects.order_by("-name")
    [<Publisher: O'Reilly>, <Publisher: Apress Publishing>, <Publisher: Addison-Wesley>]


Cuando el ordenamiento es frecuente, puede incluirse por defecto en la
definción del modelo mediante la clase interna ``Meta``:

.. code-block:: javascript

    var Publisher = type('Publisher', [ models.Model ], {
        name: new models.CharField({ maxlength: 30 }),
        //...
        
        // Clase interna 
        Meta: {'ordering': ['name']}
    });
    

Las búsquedas y ordenamientos, por ser métodos que devuelven ``QuerySet``, se pueden
encadenar, por lo que serán frecuentes consultas como las siguientes:

.. code-block:: javascript

    >>> Publisher.objects.filter(country="U.S.A.").order_by("-name")
    [<Publisher: O'Reilly>, <Publisher: Apress Publishing>, <Publisher: Addison-Wesley>]


Cuando se requiere acceder a un registro en particular, se puede usar la sintaxis
de arreglo sobre un ``QuerySet``, por ejemplo:

.. code-block:: javascript

    >>> Publisher.objects.all()[0] // Acceder al primer elemento
    <Publisher: Addison-Wesley>

Esto se traduce al siguiente listado SQL:

.. code-block:: sql

    SELECT
        id, name, address, city, state_province, country, website
    FROM book_publisher
    ORDER BY name
    LIMIT 1;


Eliminación de Datos
--------------------

Para eliminar objetos, simplemente se debe llamar al método ``delete()`` 
sobre una instancia:

.. code-block:: javascript

    >>> p = Publisher.objects.get({ name: "Addison-Wesley" });
    >>> p.delete();
    >>> array(Publisher.objects.all());
    []

Los QuerySet pueden recibir también le método ``delete()`` y se traduce
en la eliminiación de todas las filas afectadas por el ``QuerySet``. Por 
ejemplo:

.. code-block:: javascript

    >>> publishers = Publisher.objects.all();
    >>> publishers.delete();
    >>> array(Publisher.objects.all());
    []


Plantillas
==========

Doff brinda soporte al sistema de plantillas de Django. Las plantillas escritas 
para una apilcacion en línea son reutilzables sin modificaciones en la aplicación
desconectada.

Existen sin emabargo algunos factores a tener en cuenta a la hora de
realizar plantillas para aplicaciones offline. Cuando una aplicación se
ejecuta de manera desconectada, el navegador solo realiza una carga de documento
y la navegación se basa manipulaciones de DOM. 
Cada vez que se carga una página, en realidad se suprime la anterior y se anexa
la nueva en un elemento llamado ``fake-body`` y ``fake-header``. Este trabajo
es realizado por Doff y con ayuda del paquete ``dom`` de Protopy.

A continuación se realizará un breve anális de la API de plantillas y 
su utilización en Doff.

Creación de objetos Template
----------------------------

Doff implementa la calse ``Template`` para crear plantillas, y esté
se encuentra en el módulo ``doff.template.base``. El argumento para la
instanciación del objeto es el texto en crudo de la plantilla. 

    >>> require('doff.template.base', 'Template');
    >>> t = new Template("Mi nombre es {{ name }}.");
    >>> print(t);

En este ejemplo ``t`` es un objeto template listo para ser renderizado. En
caso de encontrar errores en el análisis de la plantilla, la instanciación
de ``Template`` falla. Los errores contemplados son:

    * Bloques de etiquetas inválidos
    * Argumentos inválidos de una etiqueta válida
    * Filtros inválidos
    * Argumentos inválidos para filtros válidos
    * Sintaxis de plantilla inválida
    * Etiquetas de bloque sin cerrar (para etiquetas de bloque que requieran la
      etiqueta de cierre)

En todos los casos el sistema lanza una excepción ``TemplateSyntaxError``.

Renderizar una plantilla
------------------------

Para obtener la salida procesada de una instancia de ``Template``, 
es necesario proveer un *contexto*. Un contexto es simplemente un
conjunto de variables y sus valores asociados, en Doff, un arreglo asociativo.
Una plantilla usa las variables para rellenar la plantilla evaluando las 
etiquetas.

El contexto esta representado en el tipo ``Context``, el cual se encuentra en el
módulo ``doff.template.base``. La construccion del objeto toma un argumento
opcional  un arreglo asociativo. La llamada al método ``render()`` del la 
instacia de ``Template`` con el contexto como argumento "rellena" la
plantilla::

    >>> requiere('doff.template.base', 'Context', 'Template');
    >>> t = new Template("Mi nombre es {{ name }}.")
    >>> c = new Context({"name": "Pedro"})
    >>> t.render(c)
    'My name is Pedro.'

El objeto ``Template`` puede ser renderizado con múltiples contextos, obteniendo
así salidas diferentes para la misma plantilla. Por cuestiones de eficiencia es
conveniente crear un objeto ``Template`` y luego llamar a ``render()``
sobre este muchas veces::

    # Código ineficiente
    for each (var name in ['John', 'Julie', 'Pat']) {
        var t = new Template('Hello, {{ name }}');
        print(t.render(new Context({'name': name})));
    }

    # Código eficiente
    t = new Template('Hello, {{ name }}');
    for each (var name in ['John', 'Julie', 'Pat'])
        print(t.render(new Context({'name': name})));

Al igual que en Django el objeto contexto puede contener variables mas complejas
y la forma de inspeccionar dentro de estas es con el operador `.` (punto). Usando el
punto se puede acceder a objetos, atributos, índices, o métodos de un objeto.

Cuando un sistema de plantillas encuentra un punto en una variable el orden de
busqueda es el siguiente:

    * Diccionario (por ej. ``foo["bar"]``)
    * Atributo (por ej. ``foo.bar``)
    * Llamada de método (por ej. ``foo.bar()``)
    * Índice de lista (por ej. ``foo[bar]``)

El sistema utiliza el primer tipo de búsqueda que funcione.

Finalmente, si una variable no existe en el contexto, el
sistema de plantillas renderiza este como una cadena vacía. 
Es posible cambiar este comportamiento modificando el valor de
la variable de configuración ``TEMPLATE_STRING_IF_INVALID`` en el módulo
``settings.js``.

Cargador de Plantillas
----------------------

Si bien en los ejemplos anteriores se mostró la API de plantillas con
cadenas como argumentos, las plantillas suelen estar almacenadas en 
archivos. Para Doff estos son recuros estáticos y existe un sistema
para la carga similar al de Django. Para tal fin en el módulo ``settings.js`` se esablece
el valor ``TEMPLATE_DIRS``.

Se ve a continuación un ejemplo de una vista que retorna HTML generado por una
plantilla::

    require('doff.template.base', 'Template', 'Context');
    require('doff.utils.http', 'HttpResponse');
    require('doff.template.loader', 'get_template');

    function current_datetime(request) {
        var t = get_template('mytemplate.html');
        html = t.render(new Context({'current_date': new Date()}))
        return new HttpResponse(html);
    }

En esta vista se utiliza la API para cargar plantillas, a la cual se accede 
mediante la funcion `get_template()`.

Existen varios cargadores de plantillas que se pueden habilitar en el archivo de 
configuración. Esta
variable le indica al mecanismo de carga de plantillas dónde buscar las
plantillas. Por omisión, ésta es una cadena vacia. El valor para esta varible es
la url del servidor en donde se sirven los templates que se renderizan
localmente, por defecto si no se especifica la variable los archivos se buscan
en la base del soporte off-line /templates/.



Formularios
===========


Si has estado siguiendo el capítulo anterior, ya deberías tener un
sitio completamente funcional, aunque un poco simple. En este capítulo
trataremos con la próxima pieza del juego: cómo construir vistas que
obtienen entradas desde los usuarios.

Comenzaremos haciendo un simple formulario de búsqueda "a mano",
viendo cómo manejar los datos suministrados al navegador. Y a partir
de ahí, pasaremos al uso del *framework* de formularios que trae
Django.

Búsquedas
=========

En la Web todo se trata de búsquedas. Dos de los casos de éxito más
grandes, Google y Yahoo, han construido sus empresas multimillonarias
alrededor de las búsquedas. Casi todos los sitios observan un gran
porcentaje de tráfico viniendo desde y hacia sus páginas de
búsqueda. A menudo, la diferencia entre el éxito y el fracaso de un
sitio, lo determina la calidad de su búsqueda. Así que sería mejor que
agreguemos un poco de búsqueda a nuestro pequeño sitio de libros, ¿no?

Comenzaremos agregando la vista para la búsqueda a nuestro URLconf
(``mysite.urls``). Recuerda que esto se hace agregando algo como
``(r'^search/$', 'mysite.books.views.search')`` al conjunto de URL patterns
(patrones).

A continuación, escribiremos la vista ``search`` en nuestro módulo de vistas
(``mysite.books.views``)::

    from django.db.models import Q
    from django.shortcuts import render_to_response
    from models import Book

    def search(request):
        query = request.GET.get('q', '')
        if query:
            qset = (
                Q(title__icontains=query) |
                Q(authors__first_name__icontains=query) |
                Q(authors__last_name__icontains=query)
            )
            results = Book.objects.filter(qset).distinct()
        else:
            results = []
        return render_to_response("books/search.html", {
            "results": results,
            "query": query
        })

Aquí han surgido algunas cosas que todavía no vimos. La primera, ese
``request.GET``. Así es cómo accedes a los datos del GET desde Django;
Los datos del POST se acceden de manera similar, a través de un objeto
llamado ``request.POST``. Estos objetos se comportan exactamente como
los diccionarios estándar de Python, y tienen además otras
capacidades, que se cubren en el apéndice H.

.. exhortacion:: ¿Qué son estos datos del GET y del POST?

    GET y POST son los dos métodos que emplean los navegadores para
    enviar datos a un servidor. Los encontrarás con frecuencia en los
    elementos *form* de HTML::

        <form action="/books/search/" method="get">

    Esto le indica al navegador que suministre los datos del
    formulario a la URL ``/books/search/`` empleando el método GET.

    Hay diferencias de semántica importantes entre el GET y el POST,
    que no vamos a ver ahora mismo, pero diríjete a
    http://www.w3.org/2001/tag/doc/whenToUseGet.html si quieres
    aprender más.

Así que la línea::

    query = request.GET.get('q', '')

busca un parámetro del GET llamado ``q`` y retorna una cadena de texto
vacía si este parámetro no fue suministrado. Observa que estamos
usando el método ``get()`` de ``request.GET``, algo potencialmente
confuso. Este método ``get()`` es el mismo que posee cualquier
diccionario de Python. Lo estamos usando aquí para ser precavidos:
*no* es seguro asumir que ``request.GET`` tiene una clave ``'q'``, así
que usamos ``get('q', '')`` para proporcionar un valor por omisión,
que es ``''`` (el string vacío). Si hubiéramos intentado acceder a la
variable simplemente usando ``request.GET['q']``, y ``q`` no hubiese
estado disponible en los datos del GET, se habría lanzado un
``KeyError``.

Segundo, ¿qué es ese ``Q``? Los objetos ``Q`` se utilizan para ir
construyendo consultas complejas -- en este caso, estamos buscando los
libros que coincidan en el título o en el nombre con la
consulta. Técnicamente, estos objetos ``Q`` consisten de un QuerySet,
y puede leer más sobre esto en el apéndice C.

En estas consultas, ``icontains`` es una búsqueda en la que no se
distinguen mayúsculas de minúsculas (*case-insensitive*), y que
internamente usa el operador ``LIKE`` de SQL en la base de datos.

Dado que estamos buscando en campos de muchos-a-muchos, es posible que
un libro se obtenga más de una vez (por ej: un libro que tiene dos
autores, y los nombres de ambos concuerdan con la consulta). Al
agregar ``.distinct()`` en el filtrado, se eliminan los resultados
duplicados.

Todavía no hay una plantilla para esta vista. Esto lo solucionará::

    <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
    <html lang="en">
    <head>
        <title>Search{% if query %} Results{% endif %}</title>
    </head>
    <body>
      <h1>Search</h1>
      <form action="." method="GET">
        <label for="q">Search: </label>
        <input type="text" name="q" value="{{ query|escape }}">
        <input type="submit" value="Search">
      </form>

      {% if query %}
        <h2>Results for "{{ query|escape }}":</h2>

        {% if results %}
          <ul>
          {% for book in results %}
            <li>{{ book|escape }}</l1>
          {% endfor %}
          </ul>
        {% else %}
          <p>No books found</p>
        {% endif %}
      {% endif %}
    </body>
    </html>

A esta altura, lo que esto hace debería ser obvio. Sin embargo, hay
unas pocas sutilezas que vale la pena resaltar:

    * *action* es ``.`` en el formulario, esto significa "la URL
      actual". Esta es una buena práctica estándar: no utilices vistas
      distintas para la página que contiene el formulario y para la
      página con los resultados; usa una página única para las dos
      cosas.

    * Volvemos a insertar el texto de la consulta en el
      ``<input>``. Esto permite a los usuarios refinar fácilmente sus
      búsquedas sin tener que volver a teclear todo nuevamente.

    * En todo lugar que aparece ``query`` y ``book``, lo pasamos por
      el filtro ``escape`` para asegurarnos de que cualquier búsqueda
      potencialmente maliciosa sea descartada antes de que se inserte
      en la página

      ¡Es *vital* hacer esto con todo el contenido suministrado por el
      usuario! De otra forma el sitio se abre a ataques de cross-site
      scripting (XSS). El `Capítulo 19`_ discute XSS y la seguridad con
      más detalle.

    * En cambio, no necesitamos preocuparnos por el contenido
      malicioso en las búsquedas de la base de datos -- podemos pasar
      directamente la consulta a la base de datos. Esto es posible
      gracias a que la capa de base de datos de Django se encarga de
      manejar este aspecto de la seguridad por ti.

Ahora ya tenemos la búsqueda funcionando. Se podría mejorar más el
sitio colocando el formulario de búsqueda en cada página (esto es, en
la plantilla base). Dejaremos esto de tarea para el hogar.

A continuación veremos un ejemplo más complejo. Pero antes de hacerlo,
discutamos un tópico más abstracto: el "formulario perfecto".

El "formulario perfecto"
========================

Los formularios pueden ser a menudo una causa importante de
frustración para los usuarios de tu sitio. Consideremos el
comportamiento de un hipotético formulario perfecto:

    * Debería pedirle al usuario cierta información, obviamente. La
      accesibilidad y la usabilidad importan aquí. Así que es
      importante el uso inteligente del elemento ``<label>`` de HTML,
      y también lo es proporcionar ayuda contextual útil.

    * Los datos suministrados deberían ser sometidos a una validación
      extensiva. La regla de oro para la seguridad de una aplicación
      web es "nunca confíes en la información que ingresa". Así que la
      validación es esencial.

    * Si el usuario ha cometido algún error, el formulario debería
      volver a mostrarse, junto a mensajes de error detallados e
      informativos. Los campos deberían rellenarse con los datos
      previamente suministrados, para evitarle al usuario tener que
      volver a tipear todo nuevamente.

    * El formulario debería volver a mostrarse una y otra vez, hasta
      que todos los campos se hayan rellenado correctamente.

¡Construir el formulario perfecto pareciera llevar mucho trabajo! Por
suerte, el *framework* de formularios de Django está diseñado para
hacer la mayor parte del trabajo por ti. Se le proporciona una
descripción de los campos del formulario, reglas de validación, y una
simple plantilla, y Django hace el resto. El resultado es un
"formulario perfecto" que requiere de muy poco esfuerzo.

Creación de un formulario para comentarios
==========================================

La mejor forma de construir un sitio que la gente ame es atendiendo a
sus comentarios. Muchos sitios parecen olvidar esto; ocultan los
detalles de su contacto en *FAQs*, y parecen dificultar lo más posible
el encuentro con las personas.

Cuando tu sitio tiene millones de usuarios, esto puede ser una
estrategia razonable. En cambio, cuando intentas formarte una
audiencia, deberías pedir comentarios cada vez que se presente la
oportunidad. Escribamos entonces un simple formulario para
comentarios, y usémoslo para ilustrar al *framework* de Django en
plena acción.

Comenzaremos agregando ``(r'^contact/$',
'mysite.books.views.contact')`` al URLconf, y luego definamos nuestro
formulario. Los formularios en Django se crean de una manera similar a
los modelos: declarativamente, empleando una clase de Python. He aquí
la clase para nuestro simple formulario. Por convención, lo
insertaremos en un nuevo archivo ``forms.py`` dentro del directorio de
nuestra aplicación::

    from django import newforms as forms

    TOPIC_CHOICES = (
        ('general', 'General enquiry'),
        ('bug', 'Bug report'),
        ('suggestion', 'Suggestion'),
    )

    class ContactForm(forms.Form):
        topic = forms.ChoiceField(choices=TOPIC_CHOICES)
        message = forms.CharField()
        sender = forms.EmailField(required=False)

.. exhortacion:: *¿"New" Forms?* ¿Qué?

    Cuando Django fue lanzado al público por primera vez, poseía un
    sistema de formularios complicado y confuso. Como hacía muy
    dificultosa la producción de formularios, fue rescrito y ahora se
    llama *"newforms"* (nuevos formularios). Sin embargo, como todavía
    hay cierta cantidad de código que depende del "viejo" sistema de
    formularios, Django actualmente viene con ambos paquetes.

    Al momento de escribir ese libro, el viejo sistema de formularios
    de Django sigue disponible como ``django.forms``, y el nuevo
    paquete como ``django.newforms``. En algún momento esto va a
    cambiar, y ``django.forms`` hará referencia al nuevo paquete de
    formularios. Sin embargo, para estar seguros de que los ejemplos
    de este libro funcionen lo más ampliamente posible, todos harán
    referencia a ``django.newforms``.

Un formulario de Django es una subclase de ``django.newforms.Form``,
tal como un modelo de Django es una subclase de
``django.db.models.Model``. El módulo ``django.newforms`` también
contiene cierta cantidad de clases ``Field`` para los campos. Una
lista completa de éstas últimas se encuentra disponible en la
documentación de Django, en
http://www.djangoproject.com/documentation/0.96/newforms/.

Nuestro ``ContactForm`` consiste de tres campos: un tópico, que se
puede elegir entre tres opciones; un mensaje, que es un campo de
caracteres; y un emisor, que es un campo de correo electrónico y es
opcional (porque incluso los comentarios anónimos pueden ser
útiles). Hay una cantidad de otros tipos de campos disponibles, y
puedes escribir nuevos tipos si ninguno cubre tus necesidades.

El objeto formulario sabe cómo hacer una cantidad de cosas útiles por
sí mismo. Puede validar una colección de datos, puede generar sus
propios *"widgets"* de HTML, puede construir un conjunto de mensajes
de error útiles. Y si estás en perezoso, puede incluso dibujar el
formulario completo por ti. Incluyamos esto en una vista y veámoslo en
acción. En ``views.py``:

.. literal-evaluado::

    from django.db.models import Q
    from django.shortcuts import render_to_response
    from models import Book
    **from forms import ContactForm**

    def search(request):
        query = request.GET.get('q', '')
        if query:
            qset = (
                Q(title__icontains=query) |
                Q(authors__first_name__icontains=query) |
                Q(authors__last_name__icontains=query)
            )
            results = Book.objects.filter(qset).distinct()
        else:
            results = []
        return render_to_response("books/search.html", {
            "results": results,
            "query": query
        })

    **def contact(request):**
        **form = ContactForm()**
        **return render_to_response('contact.html', {'form': form})**

y en ``contact.html``::

    <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
    <html lang="en">
    <head>
        <title>Contact us</title>
    </head>
    <body>
        <h1>Contact us</h1>
        <form action="." method="POST">
            <table>
                {{ form.as_table }}
            </table>
            <p><input type="submit" value="Submit"></p>
        </form>
    </body>
    </html>

La línea más interesante aquí es ``{{ form.as_table }}``. ``form`` es
nuestra instancia de ContactForm, que fue pasada al
``render_to_response``. ``as_table`` es un método de ese objeto que
reproduce el formulario como una secuencia de renglones de una tabla
(también pueden usarse ``as_ul`` y ``as_p``). El HTML generado se ve
así::

    <tr>
        <th><label for="id_topic">Topic:</label></th>
        <td>
            <select name="topic" id="id_topic">
                <option value="general">General enquiry</option>
                <option value="bug">Bug report</option>
                <option value="suggestion">Suggestion</option>
            </select>
        </td>
    </tr>
    <tr>
        <th><label for="id_message">Message:</label></th>
        <td><input type="text" name="message" id="id_message" /></td>
    </tr>
    <tr>
        <th><label for="id_sender">Sender:</label></th>
        <td><input type="text" name="sender" id="id_sender" /></td>
    </tr>

Observa que las etiquetas ``<table>`` y ``<form>`` no se han incluido;
debes definirlas por tu cuenta en la plantilla. Esto te da control
sobre el comportamiento del formulario al ser suministrado. Los
elementos *label* sí se incluyen, y proveen a los formularios de
accesibilidad "desde fábrica".

Nuestro formulario actualmente utiliza un *widget* ``<input
type="text">`` para el campo del mensaje. Pero no queremos restringir
a nuestros usuarios a una sola línea de texto, así que la cambiaremos
por un *widget* ``<textarea>``:

.. literal-evaluado::

    class ContactForm(forms.Form):
        topic = forms.ChoiceField(choices=TOPIC_CHOICES)
        message = forms.CharField(**widget=forms.Textarea()**)
        sender = forms.EmailField(required=False)

El *framework* de formularios divide la lógica de presentación para
cada campo, en un conjunto de *widgets*. Cada tipo de campo tiene un
*widget* por defecto, pero puedes sobreescribirlo fácilmente, o
proporcionar uno nuevo de tu creación.

Por el momento, si se suministra el formulario, no sucede
nada. Agreguemos nuestras reglas de validación::

    def contact(request):
        if request.method == 'POST':
            form = ContactForm(request.POST)
        else:
            form = ContactForm()
        return render_to_response('contact.html', {'form': form})

Una instancia de formulario puede estar en uno de dos estados: *bound*
(vinculado) o *unbound* (no vinculado). Una instancia *bound* se
construye con un diccionario (o un objeto que funcione como un
diccionario) y sabe cómo validar y volver a representar sus datos. Un
formulario *unbound* no tiene datos asociados y simplemente sabe cómo
representarse a sí mismo.

Intenta hacer clic en *Submit* en el formulario vacío. La página se
volverá a cargar, mostrando un error de validación que informa que
nuestro campo de mensaje es obligatorio.

Intenta también ingresar una dirección de correo electrónico
inválida. El ``EmailField`` sabe cómo validar estas direcciones, por
lo menos a un nivel razonable.

.. exhortacion:: Cómo especificar datos iniciales

    Al pasar datos directamente al constructor del formulario, estos
    se vinculan, y se indica que la validación debe ser efectuada. A
    menudo, necesitamos mostrar un formulario inicial con algunos
    campos previamente rellenados -- por ejemplo, en un formulario
    "editar". Podemos hacerlo con el argumento de palabras claves
    ``initial``::

        form = CommentForm(initial={'sender': 'user@example.com'})

    Si nuestro formulario *siempre* usará los mismos valores por
    defecto, podemos configurarlos en la definición misma del
    formulario:

    .. literal-evaluado::

        message = forms.CharField(widget=forms.Textarea(),
                                  **initial="Replace with your feedback"**)

Procesamiento de los datos suministrados
========================================

Una vez que el usuario ha llenado el formulario al punto de que pasa
nuestras reglas de validación, necesitamos hacer algo útil con los
datos. En este caso, deseamos construir un correo electrónico que
contenga los comentarios del usuario, y enviarlo. Para esto, usaremos
el paquete de correo electrónico de Django.

Pero antes, necesitamos saber si los datos son en verdad válidos, y si
lo son, necesitamos una forma de accederlos. El *framework* de
formularios hace más que validar los datos, también los convierte a
tipos de datos de Python. Nuestro formulario para comentarios sólo
trata con texto, pero si estamos usando campos como ``IntegerField`` o
``DateTimeField``, el *framework* de formularios se encarga de que se
devuelvan como un valor entero de Python, o como un objeto
``datetime``, respectivamente.

Para saber si un formulario está vinculado (*bound*) a datos válidos,
llamamos al método ``is_valid()``::

    form = ContactForm(request.POST)
    if form.is_valid():
        # Process form data

Ahora necesitamos acceder a los datos. Podríamos sacarlos directamente
del ``request.POST``, pero si lo hiciéramos, no nos estaríamos
beneficiando de la conversión de tipos que realiza el *framework* de
formularios. En cambio, usamos ``form.clean_data``::

    if form.is_valid():
        topic = form.clean_data['topic']
        message = form.clean_data['message']
        sender = form.clean_data.get('sender', 'noreply@example.com')
        # ...

Observa que dado que ``sender`` no es obligatorio, proveemos un valor
por defecto por si no fue proporcionado. Finalmente, necesitamos
registrar los comentarios del usuario. La manera más fácil de hacerlo
es enviando un correo electrónico al administrador del sitio. Podemos
hacerlo empleando la función::

    from django.core.mail import send_mail

    # ...

    send_mail(
        'Feedback from your site, topic: %s' % topic,
        message, sender,
        ['administrator@example.com']
    )

La función ``send_mail`` tiene cuatro argumentos obligatorios: el
asunto y el cuerpo del mensaje, la dirección del emisor, y una lista
de direcciones destino. ``send_mail`` es un código conveniente que
envuelve a la clase ``EmailMessage`` de Django. Esta clase provee
características avanzadas como adjuntos, mensajes multiparte, y un
control completo sobre los encabezados del mensaje.

Una vez enviado el mensaje con los comentarios, redirigiremos a
nuestro usuario a una página estática de confirmación. La función de
la vista finalizada se ve así::

    from django.http import HttpResponseRedirect
    from django.shortcuts import render_to_response
    from django.core.mail import send_mail
    from forms import ContactForm

    def contact(request):
        if request.method == 'POST':
            form = ContactForm(request.POST)
            if form.is_valid():
                topic = form.clean_data['topic']
                message = form.clean_data['message']
                sender = form.clean_data.get('sender', 'noreply@example.com')
                send_mail(
                    'Feedback from your site, topic: %s' % topic,
                    message, sender,
                    ['administrator@example.com']
                )
                return HttpResponseRedirect('/contact/thanks/')
        else:
            form = ContactForm()
        return render_to_response('contact.html', {'form': form})

.. exhortacion:: Redirigir luego del POST

    Si un usuario selecciona actualizar sobre una página que muestra una
    consulta POST, la consulta se repetirá. Esto probablemente lleve a
    un comportamiento no deseado, por ejemplo, que el registro se
    agregue dos veces a la base de datos. Redirigir luego del POST es
    un patrón útil que puede ayudar a prevenir este escenario. Así que
    luego de que se haya procesado el POST con éxito, redirige al
    usuario a otra página en lugar de retornar HTML directamente.

Nuestras propias reglas de validación
=====================================

Imagina que hemos lanzado al público a nuestro formulario de
comentarios, y los correos electrónicos han empezado a llegar. Nos
encontramos con un problema: algunos mensajes vienen con sólo una o
dos palabras, es poco probable que tengan algo interesante. Decidimos
adoptar una nueva póliza de validación: cuatro palabras o más, por
favor.

Hay varias formas de insertar nuestras propias validaciones en un
formulario de Django. Si vamos a usar nuestra regla una y otra vez,
podemos crear un nuevo tipo de campo. Sin embargo, la mayoría de las
validaciones que agreguemos serán de un solo uso, y pueden agregarse
directamente a la clase del formulario.

En este caso, necesitamos validación adicional sobre el campo
``message``, así que debemos agregar un método ``clean_message`` a
nuestro formulario::

    class ContactForm(forms.Form):
        topic = forms.ChoiceField(choices=TOPIC_CHOICES)
        message = forms.CharField(widget=forms.Textarea())
        sender = forms.EmailField(required=False)

        def clean_message(self):
            message = self.clean_data.get('message', '')
            num_words = len(message.split())
            if num_words < 4:
                raise forms.ValidationError("Not enough words!")
            return message

Este nuevo método será llamado después del validador que tiene el
campo por defecto (en este caso, el validador de un ``CharField``
obligatorio). Dado que los datos del campo ya han sido procesados
parcialmente, necesitamos obtenerlos desde el diccionario
``clean_data`` del formulario.

Usamos una combinación de ``len()`` y ``split()`` para contar la
cantidad de palabras. Si el usuario ha ingresado muy pocas palabras,
lanzamos un error ``ValidationError``. El texto que lleva esta
excepción se mostrará al usuario como un elemento de la lista de
errores.

Es importante que retornemos explícitamente el valor del campo al
final del método. Esto nos permite modificar el valor (o convertirlo a
otro tipo de Python) dentro de nuestro método de validación. Si nos
olvidamos de retornarlo, se retornará ``None`` y el valor original
será perdido.

Una presentación personalizada
==============================

La forma más rápida de personalizar la presentación de un formulario
es mediante CSS. En particular, la lista de errores puede dotarse de
mejoras visuales, y el elemento ``<ul>`` tiene asignada la clase
``errorlist`` para ese propósito. El CSS a continuación hace que
nuestros errores salten a la vista::

    <style type="text/css">
        ul.errorlist {
            margin: 0;
            padding: 0;
        }
        .errorlist li {
            background-color: red;
            color: white;
            display: block;
            font-size: 10px;
            margin: 0 0 3px;
            padding: 4px 5px;
        }
    </style>

Si bien es conveniente que el HTML del formulario sea generado por
nosotros, en muchos casos la disposición por defecto no quedaría bien
en nuestra aplicación. ``{{ form.as_table }}`` y similares son atajos
útiles que podemos usar mientras desarrollamos nuestra aplicación,
pero todo lo que concierne a la forma en que nuestro formulario es
representado puede ser sobreescrito, casi siempre desde la plantilla
misma.

Cada *widget* de un campo (``<input type="text">``, ``<select>``,
``<textarea>``, o similares) puede generarse individualmente
accediendo a ``{{ form.fieldname }}``. Cualquier error asociado con un
campo está disponible como ``{{ form.fieldname.errors }}``.  Podemos
usar estas variables para construir nuestra propia plantilla para el
formulario::

    <form action="." method="POST">
        <div class="fieldWrapper">
            {{ form.topic.errors }}
            <label for="id_topic">Kind of feedback:</label>
            {{ form.topic }}
        </div>
        <div class="fieldWrapper">
            {{ form.message.errors }}
            <label for="id_message">Your message:</label>
            {{ form.message }}
        </div>
        <div class="fieldWrapper">
            {{ form.sender.errors }}
            <label for="id_sender">Your email (optional):</label>
            {{ form.sender }}
        </div>
        <p><input type="submit" value="Submit"></p>
    </form>

``{{ form.message.errors }}`` se muestra como un ``<ul
class="errorlist">`` si se presentan errores y como una cadena de
caracteres en blanco si el campo es válido ( o si el formulario no
está vinculado). También podemos tratar a la variable
``form.message.errors`` como a un booleano o incluso iterar sobre la
misma como en una lista, por ejemplo::

    <div class="fieldWrapper{% if form.message.errors %} errors{% endif %}">
        {% if form.message.errors %}
            <ol>
            {% for error in form.message.errors %}
                <li><strong>{{ error|escape }}</strong></li>
            {% endfor %}
            </ol>
        {% endif %}
        {{ form.message }}
    </div>

En caso de que hubieran errores de validación, se agrega la clase
"errors" al ``<div>`` contenedor y se muestran los errores en una
lista ordenada.

Creando formularios a partir de Modelos
=======================================

Construyamos algo un poquito más interesante: un formulario que
suministre los datos de un nuevo publicista a nuestra aplicación de
libros del `Capítulo 5`_.

Una regla de oro que es importante en el desarrollo de software, a la
que Django intenta adherirse, es: no te repitas (del inglés *Don't
Repeat Yourself*, abreviado DRY). Andy Hunt y Dave Thomas la definen
como sigue, en *The Pragmatic Programmer*:

    Cada pieza de conocimiento debe tener una representación única, no
    ambigua, y de autoridad, dentro de un sistema.

Nuestro modelo de la clase ``Publisher`` dice que un publicista tiene
un nombre, un domicilio, una ciudad, un estado o provincia, un país, y
un sitio web. Si duplicamos esta información en la definición del
formulario, estaríamos quebrando la regla anterior. En cambio, podemos
usar este útil atajo: ``form_for_model()``::

    from models import Publisher
    from django.newforms import form_for_model

    PublisherForm = form_for_model(Publisher)

``PublisherForm`` es una subclase de ``Form``, tal como la clase
``ContactForm`` que creamos manualmente con anterioridad. Podemos
usarla de la misma forma::

    from forms import PublisherForm

    def add_publisher(request):
        if request.method == 'POST':
            form = PublisherForm(request.POST)
            if form.is_valid():
                form.save()
                return HttpResponseRedirect('/add_publisher/thanks/')
        else:
            form = PublisherForm()
        return render_to_response('books/add_publisher.html', {'form': form})

El archivo ``add_publisher.html`` es casi idéntico a nuestra plantilla
``contact.html`` original, así que la omitimos. Recuerda además
agregar un nuevo patrón al URLconf: ``(r'^add_publisher/$',
'mysite.books.views.add_publisher')``.

Ahí se muestra un atajo más. Dado que los formularios derivados de
modelos se emplean a menudo para guardar nuevas instancias del modelo
en la base de datos, la clase del formulario creada por
``form_for_model`` incluye un conveniente método ``save()``. Este
método trata con el uso común; pero puedes ignorarlo si deseas hacer
algo más que tenga que ver con los datos suministrados.

``form_for_instance()`` es un método que está relacionado con el
anterior, y puede crear formularios preinicializados a partir de la
instancia de un modelo. Esto es útil al crear formularios "editar".

---------------------------------------------------------------------------