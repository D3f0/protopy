***************
Sitios Remotos
***************

El presente capítulo profundiza sobre el soporte en el servidor para lograr
la desconexión de proyectos basados en Django. Este soporte se realiza mediante
la aplicación genérica ``offline``. Sus objetivos son brindar las facilidades
para la "desconexión", es decir, instalar el proyecto Doff en el cliente y
un mecanismo básico de socronización de datos [*]_.

.. [*] La sincronización de datos se aborda en el capítulo siguiente

Hasta este momento se habló de que un proyecto Doff se compone de un conjunto
de módulos JavaScript y que son publicados estáticamente.

.. Se debe recordar que un proyecto Doff, de la misma manera que un 
   proyecto Django, se compone de módulos de modelos, vistas y asociaciones de urls, 
   además de un conjunto de templates.

Con el objeto de evaluar una técnica que permita mantener consistencia 
entre la aplicación en línea y la aplicación desconectada se
realizó el siguiente análisis sobre los módulos que componen al proyecto desconectado:

    * Modelos
    
      Al contar con la misma API de ORM que Django, los modelos de proyecto Doff
      pueden ser generados a partir del análisis de las definiciones de los
      modelos del proyecto en línea. Es decir, a través de una vista se puede generar
      la salida en código JavaScript de la definición de los modelos de las
      aplicaciones que compongan al proyecto Django.   
       
    * Plantillas
    
      El sistema de plantillas de Doff es muy similar al de Django. Es decir,
      una plantilla utilizada en una aplicación Django se puede utilizar en
      un proyecto Doff.
      En este caso, no hace falta ningun tipo de introspección, como en el caso
      anterior de los modelos, para lograr consistencia entre los proyectos
      simplemente se debe publicar las plantillas como parte del 
      proyecto.
      
Sin embargo existen dos elementos que requieren la reescritura por parte del 
programador:

    * URLs
    
      Las URLs deben ser reescritas utilizando la sintaxis de JavaScript, que
      si bien es similar no permite la recuperación de grupos nombrados.
    
    * Vistas
    
      Las vistas deben ser reescritas en JavaScript adaptando la sintaxis
      a Doff y Protopy.

Se creó una entidad en ``offline`` denominada sitio remoto con el objeto de
publicar el proyecto desconectado para su instalación en el navegador y poveer
las vistas especiales para los modelos y las plantillas antes mencionados.

A continuación se describe la mecánica de migración de proyectos Django a su
versión desconectada utilzando los sitios remotos.
 
RemoteSite
----------

La clase ``RemoteSite`` define un proyecto desconectado. Tiene varias 
responsabilidades, entre ellas, servir el código JavaScript del framework Doff,
el del proyecto, publicar los templates, generar la definición de los modelos
mediante introspección y permitir la sincornización. Esta clase se impleentó en 
``offline.sites.RemoteSite``.

Un ``RemoteSite`` representa *una migración* [*]_ del proyecto en línea. Es decir,
para un mismo proyecto en línea, pueden existir una o más migraciones.

Su interfase está basada en la adminstración que provee Django 
(``django.contrib.admin``), donde un 
sitio de administración se encarga de las operaciones de CRUD sobre 
los modelos que le son registrados. Pueden existir múltiples sitios de
administración en un proyecto. Cada sitio se publica en una 
URL dentro del proyecto [DjangoNewFormsAdminBranch09]_. De la misma
manera, un sitio remoto se publica en una URL en el poryecto.

.. [DjangoNewFormsAdminBranch09] Brian Rosner, Django Trac,
   *The newforms-admin branch*,
   último acceso Octubre 2009,
   http://code.djangoproject.com/wiki/NewformsAdminBranch,
   http://code.djangoproject.com/changeset/7967

.. [*] No confundir con migración de esquema, termino bajo el cual se agrupan
    las herramientas que permiten el pasaje de una definción de base de datos
    de alto nivel (ORM) a otro.

A diferencia de los sitios de administración de ``django.contrib.admin``, los
sitios remotos están publicados bajo una URL base común. Esta debe ser definida
por el usuario en el módulo ``settings.py`` del proyecto en línea con el nombre
``OFFLINE_BASE``. La URL de un sitio remoto es la concatenación de ``OFFLINE_BASE``
y el nombre del sitio remoto. Debido a que el nombre de el sitio remoto es único en
el proyecto, su URL también lo es. Esta URL es generada automáticamente en 
la propiedad ``urlregex`` de las instancias de ``RemoteSite``. Por ejemplo:

.. code-block:: python
    
    # En settings.py
    OFFLINE_BASE = "off"
    
    # Definción del sitio remoto
    site = RemoteSite('ventas')
    
    # La URL del sitio es
    >>> site.urlregex
    "/off/ventas"
    
La finalidad de la propiedad ``urlregex`` es definir el patrón con el cual se 
publica un sito remoto dentro del archivo ``urls.py``. Además se definió que 
estas publicaciones deben hacerse en el nivel raíz de un proyecto Django, es
decir, en el módulo apuntado por ``ROOT_URLCONF`` del módulo ``settings.py``.    
     


Además de la definción en Python, cada proyecto desconectado o *migración* posee
un conjunto de módulos JavaScript. El directorio donde se deben almacenar esta
dado también por el valor de ``OFFLINE_BASE`` y el nombre del sitio remoto.


 sitio remoto posee una serie de modelos registrados, sobre los cuales
se puede definir cuales son de solo lectura y cuales de lectura-escritura
(en la sincronización).
Mediante el mecanismo de autenticación y autorización de Django 
(``django.contrib.auth``) se puede restringir que usuario o rol
accede a cada sitio remoto. 

La creación de un sitio remoto no se realiza manualmente. Cuando se instala
la aplicación ``offline`` en el proyecto en línea, se añade un comando para 
la creación automatizada. Este comando se encarga de crear
un directorio (que también es un módulo Python) donde se almacena
los módulo que define los sitio remoto. Cada sitio remoto posee un 
nombre único. El nombre de este directorio se define en el módulo ``settings.py``
del proyecto como una constante de cadena con el nombre ``OFFLINE_BASE``.

Por cada sitio remoto existe un subdirectorio donde se almacena el código
JavaScript del proyecto y sus aplicaciones: ``OFFLINE_BASE/<nombre_sitio_remoto>``. 
En su nivel base se cuenta con los módulos ``settings.js``, ``urls.js``.
Cada aplicación es un subdirectorio y cuenta con módulos ``views.js``, 
``mixins.js``, ``tests.js`` y ``urls.js``.

Desde el punto de vista de Django, un sitio
remoto publica sus métodos como vistas [*]_ y se comporta como un módulo de
``urls``, pero a diferencia de una vista de usuario, la URL (patrón) donde se publica
está definida.
El patrón que se debe utilizar es una propiedad de la instacia
llamada ``urlregex``, es decir que el programador no define donde se publica el sitio
sino que está definido por el sito [*]_ (internamente en función del nombre del sitio remoto
y del parámetro ``OFFLINE_BASE``). Por ejemplo:

.. code-block:: python
    
    from soporte_offline.remote_mi_sitio import site as mi_sitio
    
    urlpatterns = patterns('',
        # Las primeras dos asocaiciones utilizan una cadena 
        (r'^$', index,)
        (r'^vendedores/(?P<id>\d)/$', vista_vendedores),
        
        # En el caso de los sitios remotos, la URL está indicada por el atributo
        # urlregex
        (r'^%s/(.*)' % mi_sitio.urlregex, mi_sitio.root ),
    )
         
En el caso anterior la propiedad ``urlregex`` es ``/soporte_offline/mi_sitio`` y
en ese lugar se encuentra el punto de entrada para la ejecución del proyecto 
desconectado. Al acceder a esta URL el navegador se encuentra con:

.. code-block:: html
    :linenos:
    
    <html>
    <head>
        <!-- El sitio remoto publica la librería Protopy, como JavaScript 1.7 -->
        <script type="text/javascript;version=1.7" 
            src="/soporte_offline/mi_sitio/lib/protopy.js"></script>
        <!-- Creación de la instancia del proyecto desconectado -->
        <script type="text/javascript;version=1.7">
            <!-- Requerir del módulo de proyectos, la función new_project -->
            require('doff.core.project', 'new_project');
            <!-- Instanciación  del proyecto --> 
            var mi_sitio = new_project('mi_sitio', '/soporte_offline/mi_sitio');
            <!-- Darle el control del navegador a la instancia del proyecto -->
            mi_sitio.bootstrap();
        </script>
    </head>
    <body>
    </body>
    
    </html>
        
.. [*] Tomado de TurboGears y Pylons. 

Como se pudo observar en el ejemplo anterior, el código del Protopy se encuentra
en ``lib/protopy.js`` (línea 4 y 5), y como se deinfinió en el capítulo anterior, el códgo
de Doff se encuentra en ``lib/packages/``. En la línea 10, se crea una entrada
en ``sys.path`` de Protopy, definiendo que el paquete ``mi_sitio`` se encuentra en la
URL ``/soporte_offline/mi_sitio``. En este caso ``mi_sitio`` es el paquete que define
al proyecto. Para cargar el módulo ``settings`` mediante 
``require("mi_sitio.settings")`` se está realizando una petición a
``/soporte_offline/mi_sitio/js/settings.js``.

.. [*] Si bien no se recomienda modificar la URL en la cual se publica un sitio remoto,
       el desarrollador puede modificarla.

Además de las URLs descritas, el sitio remoto publica otras de dónde 
Doff descarga los modulos y recursos que componen a la aplicación, 
para almacenarlos localmente y poder ejecutar el proyecto cuando el cliente 
se encuentre sin conexión. Una de estas URLs es ``manifest.json``, en la cual
se encuentra una lista completa de los archivos que componen al proyecto.
Durante la instalación del proyecto se utiliza esta lista para alamacenar
los recursos que componen al proyecto.

A continuación se realiza una descripción del método de migración de proyectos.

Migración de un Proyecto
------------------------

La migración de un proyecto a través de los sitios remotos consiste
de los siguientes pasos:
 
    #. Instalación de la aplicación de soporte (``offline``), este paso es necesario
       solo una vez.
       
    #. Agregado de ``OFFLINE_BASE`` a ``settings.py``
        
    #. Creación de un sitio remoto

    #. Migración de una aplicación
    
    #. Registro de modelos en el RemoteSite
    
    #. Publicación del sitio remoto
    
    #. Creación del ``manifest.json``, este paso se considera el paso a
       producción de la aplicación desconectada.

El siguiente gráfico resume la mecánica de migración:

.. figure:: ../_svg/esquema_utilizacion_offline.png

    Esquema de trabajo con la aplicación offline

El primer paso de la migración consiste en la instalación de la
aplicación de soporte ``offline`` al proyecto. Para esto
se la descarga y añade al ``PYTHONPATH``. Posteriormente se debe agregar a
``INSTALLED_APPS`` del proyecto en linea. 

Una vez realizado este paso se habilitan varios comandos para la administración 
de proyectos desconectados al módulo ``manage.py``. 
Paso seguido es necesario agregar la constante ``OFFLINE_BASE`` al módulo
``settings.py``. El valor de esta constante se utiliza para definir el directorio
donde se almacenan los sitios remotos y sus recursos y también la base común
de la URL en la que se publican. Este paso se realiza por única vez, por 
ejemplo:
    
code-block:: python

    OFFLINE_BASE = "off"
    
De crearse un sitio remoto llamado, por ejemplo, ``"ventas", los recursos 
que lo componen se almacenarán en ``<ruta_del_proyecto>/off/ventas`` y la 
URL en la cual se publicará será ``http://misitio.com/off/ventas``.     

 
Creación de un Sitio Remoto
****************************

Este paso se realiza mediante la ejecución del comando ``start_remotesite``, su
sintaxis es la siguiente:

    ``start_remotesite <nombre_sitio_remoto>``

Este comando crea la estructura de directorios del sitio remoto y la definicón
de la instancia del ``RemoteSite`` en un módulo Python.
Si no exite el directorio ``OFFLINE_BASE`` en el proyecto en
línea lo crea.
Dentro del directorio antes mencionado, añade el módulo ``remote_<nombre_sitio>.py``
en el cual define la instancia de ``RemoteSite`` con el nombre dado. Por ejemplo,
al crear la aplicación ``ventas`` dentro de un proyecto llamado ``salesman``, con
``OFFLINE_BASE`` igual a ``"off"``, la definción del módulo sería la siguiente:





 Utiliza
también el nombre para crear un subdirectorio en ``OFFLINE_BASE`` donde
crea el esqueleto del proyecto desconetado (crando ``settings.js`` y ``urls.js`` 
a partir de plantillas que son rellenadas con la configuración disponible 
de la aplicación en linea).

    Por ejemplo:
    
    .. code-block:: bash
    
        $ manage.py start_remotesite vendedor_viajante
        
    Esto crea en el directorio de la aplicación la siguiente estuctura (suponiendo
    que ``OFFLINE_BASE`` sea la cadena ``soporte_offline``)::
        
        soporte_offline/
            remote_vendedor_viajante.py
            vendedor_viajante/
                settings.js
                urls.js
                logging.js
    
    
 
 * ``list_remotesites``
    
    Este comando lista los ``RemoteSites`` de un proyecto en línea. Verifica
    además si estos se encuentran publicados. No recibe argumentos.
   
 
 * ``migrate_app``
 
    Migra una aplicación conectada a un ``RemoteSite``. Recibe como argumentos
    el nombre del sitio remoto y el nombre de la aplicación. Dentro
    de ``OFFLINE_BASE/<nombre-site>/<nombre-app>`` crea la estructura de la 
    aplicación (crea los módulos ``views.js`` y ``models.js`` a partir de plantillas).
    
    Por ejemplo:
    
    .. code-block:: bash
    
        $ manage.py migrate_app vendedor_viajante catalogo
        
    Basados en el ejemplo del comando ``start_remotesite``, 
    produciría la siguiente estructura de archivos::
    
        soporte_offline/
            remote_vendedor_viajante.py
            vendedor_viajante/
                settings.js
                urls.js
                logging.js
                catalogo/
                    views.js
                    mixins.js
                    tests.js
                    urls.js
    
    
 * ``manifest_update``
 
    Acutaliza los recursos que componen al proyecto desconectado: vistas,
    plantillas, modelos y recursos estáticos. 
    


La definción de un remotesite dentro de ``OFFLINE_BASE/remote_<nombre-site>.py``,
resultado del comando ``manage.py create_remotesite <nombre-site>`` tiene 
la siguiente estructura:

.. code-block:: python

    from offline.sites import RemoteSite 

    site = LibrarianRemoteSite('librarian')
    
Cada aplicación migrada mediante el comando ``migrate_app`` es creada a partir
de una esqueleto genérico, donde el programador deberá implementar las URLs 
y vistas. Si bien esta tarea podría parecer tediosa en primera intancia, el
grado de similitud entre Protopy con Python y el hecho de que Doff implemente
la misma API que Django facilita mucho la tarea.

Las plantillas y los modelos son provistos autmáticamente por el sitio remoto.
A continuación se analiza la forma en la que se exponen los modelos y como
se puede modificar.


Publicación de Modelos
======================

Como se mencionó en el capítulo introductorio, es deseable contar con 
un mecanismo de separación de los datos a los cuales accede al cliente
por seguridad y eficiencia. 

Para lograr este objetivo se creó una entidad encargada de arbitrar el 
acceso a los modelos. Este recubrimiento o *porxy* permite definir a 
que datos accede el cliente de dos maneras: defineindo a que campos accede
(columnas de la base de datos) y a que elementos meidnate la definición
de un manager (a que filas accede).

Esta entidad se denominó ``RemoteModelProxy`` o proxy.
Se adoptó como política que por defecto, ningún modelo se encuentra visible
al cliente. Para poder acceder a un modelo es necesario publicarlo explícitamente
en el sitio remoto. Para esta tarea el ``RemoteSite`` cuenta con el método
``register(model, proxy = None)`` [*]_.

.. [*] Esta idea también fue tomada de la aplicación genérica ``django.contrib.admin``
       antes mencionada. 

El método ``register`` recibe como primer argumetno el modelo a publicar y 
opcionalmente una instancia de ``RemoteModelProxy``. Cuando el método es llamado
sin el parámetro ``proxy``, el sitio remoto genera automáticamente un proxy 
que publica todos los campos del modelo y todas sus filas.

Por ejemplo, sobre un sitio remoto llamado ``librarian``, con los modelos
definidos en el capítulo de Doff (autor, libro, editor), el código sería
el siguiente:

.. code-block:: python
    
    # Importación el sitio remoto
    from offline.sites import RemoteSite
    # Importación el libro
    from bookstore.core.models import Book, Author  
    
    # Creación del sitio remoto
    site = LibrarianRemoteSite('librarian')
    
    # Registro de modelos
    site.register(Book)
    site.register(Author)
    
De esta manera las vistas del proyecto desconectado tendrán disponible los 
modelos ``Book`` y ``Author``. 

Para personalizar la definición y acceso a datos de un modelo, se debe 
crear una subclase de ``RemoteModelProxy``. Dentro de esta subclase se
pueden definir los campos a publicar mediante (``fields``, ``include``,
``exclude``) y el ``Manager`` del modelo a utilizar [*]_. Por ejemplo:

.. code-block:: python

    from offline.sites import RemoteSite
    from bookstore.core.models import Book, Author  

    site = LibrarianRemoteSite('librarian')

    class BookRemote(RemoteModelProxy):
        class Meta:
            model = Book # Este campo es opcional
            exclude = ('author', ) # Se excluye el campo autor
            manager = Book.objects # El managers es el manager por defecto
    
    site.register(Book, BookRemote) # Registro
    
.. [*] Se pueden definir campos que no existen en el modelo que deberán ser provistos
       por el Manager a la hora de la sincronización.

El Manager permite filtrar las entidades que son accedidas por el cliente.
Si el cliente es un usuario autenticado en el proyecto, mediante la implementación de un
``Manager`` que discrimine usuarios autenticados [*]_, se puede limitar la visión
de las instancias de un modelo (o filas sobre la base de datos).

.. [*] El usuario se ha autenticado en la aplicación en línea contra las entidades
       de ``django.contrib.auth.models.User``.

Cuando se migra una aplicación al cliente, mediante el comando ``migrate_app``,
no se crea un módulo ``models.js`` como podría esperarse. El sitio remoto lo
genera automáticamente en función de los modelos que hallan sido registrados y
los publica en cada aplicación del sitio remoto (es decir, los modelos son
globales al proyecto desconectado).

El sitio remoto solo se encarga de publicar la estrcutra del proxy de modelos,
los métodos opcionales con los que el desarrollador desee contar se deben 
implementar en un mixin. Para este fin existe una archivo por cada aplicación
migrada llamado ``mixins.js`` donde se definen los métodos de los modelos
como un arreglo asociativo. El nombre del arreglo debe conincidir con el nombre
del modelo. Por ejemplo, para el modelo de ``Book``:

.. code-block:: javascript

    var Book = {
        // Representación en cadena del modelo
        __str__: function () {
            return this.nombre;
        }
    };
    
    publish({
        Book: Book
    })


En Django los modelos suelen tener métodos de utilidad, como ``__unicode__`` (
en el cliente ``__str__`` [*]_). Estos métodos se deben implementar en un arreglo
asociativo que se utiliza a modo de ``Mixin``. Como se mencionó en el capítulo
sobre Protopy, la impmentación de clases soporta herencia múltiple, cuando
se requiere la url con la definción del modelo, se requieren automáticamente
los Mixins definidos.


.. [*] Una epxplicación sobre los detalles sobre este método se encuentra


Durante la instalación del proyecto, cuando el ``ManagedLocalStore`` descarga
el recurso, el sitio remoto provee automaticamente la conjunción de la introspección
realizada sobre los modelos con los métodos agregados en el mixin.

En el siguiente esquema se muestra la intreacción entre el sitio remoto, los modelos
de una apicacción, sus managers y los proxies de modelos.

.. figure:: ../_svg/esquema_remotemodelproxy.png
	
	Modelos de una aplicación desconectada
	
Por ejemplo, para una definción de un modelo como sigue:

.. code-block:: python

    # ---------------------------------------------------
    # Definción del modelo en models.py
    # ---------------------------------------------------
    
    from django.db import models
    
    class Persona(model.Model):
        nombre = models.CharField(max_length = 40)
        apellido = models.CharField(max_length = 40)
        
        # Representación en cadena Unicode
        def __unicode__(self):
            reutrn u"%s %s" % (self.nombre, self.apellido)
    
    # ---------------------------------------------------
    # Definción del RemoteSite
    # ---------------------------------------------------
    
    site = RemoteSite('personas')
    site.register(Persona) # Sin proxy

Luego de haber ejecutado el comando ``migrate_app`` el código del Mixin
para implementar la funcionalidad de ``__unicode__`` sería:

.. code-block:: javascript
    
    // El Mixin es simplemente un arreglo asociativo, donde
    // se pueden incorporar más métodos.
    
    var Persona = {
        // En el servidor la salida del modelo se transforma en el encoding
        // del template, en cambio, en el cliente la codificación ya está
        // establecida, por lo que se utiliza el método __str__
        __str__: function() {
            return "%s %s".subs(this.nombre, this.apellido);
        }
    }

Modelos de Solo Lectura
***********************

Si bien se tratará la sincronización en un apartado posterior, se ha mencionado
que existe un mecanismo para sincroizar los datos de los modelos.
La sincronización puede ocurrir del servidor al cliente, la cual es probablemente
necesaria en la instalación y en sentido inverso para sincronizar los datos
generados o modificados durante la ejecución desconectada del proyecto.

Cuando un modelo se registra en un sitio remoto, se concede permiso de modificación
a los campos definidos en el proxy de modelos (tomados automáticamente del modelo).
Si se registra una modelo que posee claves foraneas, y los modelos referenciados
no son registrados, se genera un registro implícito de estos modelos como
solo lectura.

Es decir, si contamos con un modelo como el siguiente:

.. code-block:: python

    from django.db import models
    
    class Pais(models.Model):
        nombre = models.CharField(max_length = 40)
        
    class Provincia(models.Model)
        provincia = models.ForeignKey(Provincia) # Referencia a Provincia
        nombre = models.CharField(max_length = 40)
        habitantes = models.PositiveIntegerField(default = 0)
        
continuando el ejemplo, si en la definición del sitio remoto solo se 
registra la entidad ``Provincia``:

.. code-block:: python

    site.register(Provincia)
            
la entidad ``Pais`` se registra implicitamente como un modelo de solo lectura.
Durante la sincronización los datos solo se transfieren del servidor al cliente.
Los unicos campos transferidos son el ``pk`` (o ``id``) y la representación
en cadena del modelo (``__unicode__``).         

Publicación de un Sitio Remoto
==============================

La publicación de un sitio remoto es explícita y consiste en agregar al
módulo ``urls.py`` del proyecto un patrón como el siguiente (suponiendo 
que ``OFFLINE_BASE`` sea "soporte_offline" y el nombre del sitio remoto
sea "bookstore"):

.. code-block:: python

    from soporte_offline.bookstore import bookstore_site
    
    (r'^%s/(.*)' % bookstore_site.urlregex, bookstore_site.root )
    
El atributo ``urlregex`` del sitio remoto calcula automáticamente la URL
del sitio como la concatenación de ``OFFLINE_BASE`` y el nombre del sitio.
En el caso anterior, para acceder al sitio desconectado se debe acceder a la URL::

    http://misitio.com/soporte_offline/bookstore
    
Esta URL genera automáticamente la instancia del proyecto en el cliente.

Finalmente, podemos resumir el ciclo de migración mediante la siguiente figura:

    
 