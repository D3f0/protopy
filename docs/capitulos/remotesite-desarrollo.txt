****************
La aplicación
****************

Una vez lograda la implementación de Django en el clinete sobre el framework
de aplicaciones Doff, se comenzó a trabajar en la integración con los proyectos
en línea.


Doff fue desarrollado con el objetivo de realizar la menor cantidad de 
reescritura posible de las aplicaciones Django al momento de ser ejecutadas de manera
desconectada. Si bien fue intecinalmente omitido en el capítulo sobre el
framework desconectado, el hecho de contar con la misma API de ORM posibilita la generación de 
modelos del cliente de manera autónoma a partir del análisis
de las definciones de los modelos de la aplicación en linea.

De la misma manera, las plantillas del proyecto conectado, no requieren
adaptaciones (en el caso de que utilicen JavaScrpipt, deben adecuarlo
a las normativas de Doff y las etiquetas de templates no estándares
deben ser reescritas en Doff).

Las vistas y las URLs deben ser reescritas, ya que por
no contarse con el mismo soporte para expresiones regulares, y debido
a que las vistas en Django son funciones escritas en Python, estas 
no pueden ser traducidas a JavaScript sin la intervensión del programador.

En el capítulo sobre Doff se introdujo vagamente una aplicación Django llamada
``offline`` que tenía como objetivo servir estáticamente al cliente con
el código de Doff y Protopy. En el presente capítulo se crea dentro de 
dicha aplicación una entidad especial, el RemoteSite con el objetivo de
crear el proyecto en el browser de una manera automatizada, brindar seguridad
sobre los datos y proveer mecanismos extensibles para sincronización.

RemoteSite
----------

Se creó la entidad RemoteSite como definición del proyecto desconectado
dentro de la aplicación en línea que le da origen. 
Un proyecto puede tener uno o más RemoteSites. Cada sitio remoto está 
publicado en una URL.

Para esta tarea se tomó el equema propuesto por ``django.contrib.admin`` de 
generar clases encargadas de trabajar con los modelos. 

Cada ``RemoteSite``, como proyecto desconectado, cuenta con los módulos
``settings.js``, ``urls.js`` y las aplicaciones con módulos ``views.js``, 
``models.js``. Todos estos módulos son recursos estáticos que son servidos
por el ``RemoteSite`` y son almacenados en un subdirectorio del proyecto
desconectado. Este directorio se define en la variable de configuración
``OFFLINE_BASE`` en el módulo ``settings.py``.

Las instancias de RemoteSite poseen un nombre único en el proyecto, que
conjugado con la variable ``OFFLINE_BASE`` definen la URL de publicación del sitio.

El sitio remoto sirve además del proyecto, el código del framework y de 
Doff. La instancia de ``doff.core.project.Project`` conoce las URLs donde
el ``RemoteSite`` publica estos recursos.

Migración de una Proyecto
-------------------------

La migración de un proyecto a través de los sitios remotos consiste
de los siguientes pasos:
 
    #. Instalación de la aplicación de soporte (``offline``), este paso es necesario
       solo una vez.
     
    #. Creación de un sitio remoto

    #. Migración de una aplicación
    
    #. Registro de modelos en el RemoteSite
    
    #. Publicación del sitio remoto
    


El primer paso para la migración consiste en la instalación de la
aplicación de soporte ``offline`` al proyecto. Para esto
se la descarga y al ``PYTHONPATH`` y luego se la incluye en ``INSTALLED_APPS`` 
del proyecto en linea. 

Una vez realizado este paso se habilitan varios comandos para la administración 
de proyectos desconectados al 
módulo ``manage.py``. Estos comandos permiten realizar varios de los pasos
antes mencionados. Los comandos implementados son los siguientes:

 * ``start_remotesite``
	
    Este comando recibe como argumento el nombre de sitio remoto que se desea
    crear. Si no exite el directorio ``OFFLINE_BASE`` en el proyecto en
    línea lo crea y dentro de el añade el módulo ``remote_<nombre-site>.py``
    en el cual define la instancia de ``RemoteSite`` con el nombre dado. Utiliza
    también el nombre para crear un subdirectorio en el ``OFFLINE_BASE`` donde
    crea el esqueleto del proyecto desconetado (``settings.js`` y ``urls.js`` 
    que son rellenados con la configuración de la aplicación en linea).
    
    Por ejemplo:
    
    .. code-block:: bash
    
        $ manage.py start_remotesite soporte_offline
        
 
 * ``list_remotesites``
    
    Este comando lista los ``RemoteSites`` de un proyecto en línea. Verifica
    además si estos se encuentran publicados. No recibe argumentos.
   
 
 * ``migrate_app``
 
    Migra una aplicación conectada a un ``RemoteSite``. Recibe como argumentos
    el nombre del sitio remoto y el nombre de la aplicación. Dentro
    de ``OFFLINE_BASE/<nombre-site>/<nombre-app>`` crea la estructura de la 
    aplicación (módulos ``views.js`` y ``models.js``).
    
    Por ejemplo:
    
    .. code-block:: bash
    
        $ manage.py migrate_app soporte_offline bookstore
    
 * ``manifest_update``
 
    Acutaliza los recursos que componen al proyecto desconectado: vistas,
    templates, modelos y recursos estáticos. 
    
Una vez creado un sitio remoto, sus recuros estáticos que lo componen
se ubican en ``OFFLINE_BASE/<nombre-site>/``. 

La definción de un remotesite dentro de ``OFFLINE_BASE/remote_<nombre-site>.py``,
resultado del comando ``manage.py create_remotesite <nombre-site>`` tiene 
la siguiente estructura:

.. code-block:: python

    from offline.sites import RemoteSite 

    site = LibrarianRemoteSite('librarian')     

Registro de Modelos
-------------------

Como se mencionó en el capítulo introductorio, es deseable contar con 
un mecanismo de separación de los datos a los cuales accede al cliente
por seguridad y eficiencia. Esta tarea fue asingada a los ``RemoteSites``.

Por defecto ningún modelo es visible para el cliente. Se deben publicar
explicitamente mediante un método llamado ``register()``. Esta idea también
fue tomada de la extensión ``django.contrib.admin`` antes mencionada. 

El método ``register`` debe ser llamado sobre la instancia definida en el módulo 
``OFFLINE_BASE.remote_<nombre-modulo>`` (en el sistema de archivos 
OFFLINE_BASE.remote_<nombre-modulo>.py).

Opcionalmente ee puede modificar la forma en la que el cliente ve el modelo 
mediante la definición de una clase ``RemoteModelProxy``.

Por ejemplo, la definción del sitio remoto quedaría como sigue para el ejemplo
anterior:

.. code-block:: python
    
    from offline.sites import RemoteSite
    from offline.sites import RemoteModelProxy
    from bookstore.core.models import Book, Author  

    site = LibrarianRemoteSite('librarian')
    site.register(Book)
    site.register(Author)
    
De esta manera las vistas del sitio remoto tendrán disponible los 
modelos ``Book`` y ``Author``.

Internamnte el método ``register(model, proxy)`` cuando es llamado sin 
una instancia de ``RemoteModelProxy`` como segundo argumento, genera un
proxy que publica toda la especificación del modelo.

Proxies de Modelos
------------------

Los ``RemoteModelProxy`` son clases que definen la forma en la que se expone
un modelo en un ``RemoteSite``. Sus atributos definen el modelo al que están asociados, 
los campos que publican y el manager con el cual se presental al cliente.
Por ejemplo:

.. code-block:: python
    
    
    class TagRemote(RemoteModelProxy):
        class Meta:
            model = Tag
            exclude = ('title', )
            manager = Tag.objects
    
    site.register(Tag, TagRemote) # Registro

El manager permite filtrar las entidades que son accedidas por el cliente.
Si el cliente es un usuario de la aplicación, mediante la implementación de un
``Manager`` que discrimine usuarios autenticados [*]_, se puede limitar la visión
de las instancias de un modelo


.. [*] El usuario se ha autenticado en la aplicación en línea contra las entidades
       de ``django.contrib.auth.models.User``.



.. figure:: ../_svg/esquema_offline_simple.png
	
	Análisis inicial de elementos a transferir para lograr una versión offline de un proyecto


Bootstrap
---------

Transferencia de los modelos
----------------------------


Debido a que la API de base de datos posee diferencias mínimas,
la transferencia de la definición de los modelos al cliente se ideó de tal forma
que sea posible mediante introspección. 

Para que el clinete conozca la definción de un modelo, realiza una 


Ciclo de Trabajo
----------------

.. figure:: ../_svg/esquema_utilizacion_offline.png

	Esquema de trabajo con la aplicación offline
	
Comunicación Entre el RemoteSite y el Proyecto del Cliente
----------------------------------------------------------


^$')                                    
^network_check/?$')
^rpc/?$')
^rpc/data/(?P<app_label>\w+)/(?P<model_name>\w+)/$')
manifest.json$')
^templates/(.*)$')
^template_list/$')
system/(.*)$')
project/(.*)$')
^network_check/?$')
^jsonrpc/?$')
^manifests/system.json$')
^manifests/project.json$')
^export/(?P<app_name>.*)/models.js$')
^export_/(?P<app_name>.*)/models.js$')