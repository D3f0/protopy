****************
La aplicación
****************

Una vez lograda la implementación de Django en el cliente, el framework
de aplicaciones Doff, se comenzó a trabajar en la integración con los proyectos
en línea.


Doff fue desarrollado con el objetivo de realizar la menor cantidad de 
reescritura posible de las aplicaciones Django al momento de ser ejecutadas de manera
desconectada. Si bien fue intecinalmente omitido en el capítulo sobre el
framework desconectado, contar con la misma API de ORM hace posible la generación de 
modelos del cliente de manera autónoma a partir del análisis
de las definciones de los modelos de la aplicación en línea.

De la misma manera, las plantillas del proyecto conectado, no requieren
adaptaciones (en el caso de que utilicen JavaScrpipt, deben adecuarlo
a las normativas de Doff y las etiquetas de templates no estándares
deben ser reescritas en Doff).

Las vistas y las URLs deben ser reescritas, ya que por
no contarse con el mismo soporte para expresiones regulares, y debido
a que las vistas en Django son funciones escritas en Python, estas 
no pueden ser traducidas a JavaScript sin la intervensión del programador.

En el capítulo sobre Doff se introdujo vagamente una aplicación Django llamada
``offline`` que tenía como objetivo servir estáticamente al cliente con
el código de Doff y Protopy. El presente capítulo se centra sobre la 
utilidad de dicha aplicación.

Se introduce la entidad ``RemoteSite`` que tiene como objetivo 
vincular la aplicación desconectada con la aplicación en línea 
y brindar mecanismos para seguridad y sincronización de datos.

El mecanismo de comunicación con Django es la lína de comandos (CLI) [*]_, y
brinda una API para la generación de comandos presonalizados que se aprovechó
para automatizar varios pasos de la migración de un proyecto.


.. [*] Tal como se mencionó en el capítulo teórico sobre las tecnologías del servidor.
 
RemoteSite
----------

La clase ``RemoteSite`` o sitio remoto define un proyecto desconectado. Tiene varias 
responsabilidades, entre ellas, servir el código JavaScript del framework Doff,
el del proyecto, administrar la forma en que el cliente accede a los
datos y permitir la sincornización. Esta clase se impleentó en 
``offline.sites.RemoteSite``.

Su interfase está basada en la adminstración que provee Django 
(``django.contrib.admin``), donde un 
sitio de administración se encarga de las operaciones de CRUD sobre 
los modelos que le son registrados. Pueden existir múltiples sitios de
administración en un proyecto. Cada sitio se publica en una 
URL dentro del proyecto [DjangoNewFormsAdminBranch09]_.

.. [DjangoNewFormsAdminBranch09] Brian Rosner, Django Trac,
   *The newforms-admin branch*,
   último acceso Octubre 2009,
   http://code.djangoproject.com/wiki/NewformsAdminBranch,
   http://code.djangoproject.com/changeset/7967

Un ``RemoteSite`` representa *una* migración del proyecto. Es decir,
para un mismo proyecto en línea, pueden existir una o más migraciones.
Cada sitio remoto se encuentra publicado en alguna URL en el proyecto.
Cada sitio remoto posee una serie de modelos registrados, sobre los cuales
se puede definir cuales son de solo lectura y cuales de lectura-escritura
(en la sincronización).
Mediante el mecanismo de autenticación y autorización de Django 
(``django.contrib.auth``) se puede restringir que usuario o rol
accede a cada sitio remoto. 

La creación de un sitio remoto no se realiza manualmente. Cuando se instala
la aplicación ``offline`` en el proyecto en línea, se añade un comando para 
la creación automatizada. Este comando se encarga de crear
un directorio (que también es un módulo Python) donde se almacena
los módulo que define los sitio remoto. Cada sitio remoto posee un 
nombre único. El nombre de este directorio se define en el módulo ``settings.py``
del proyecto como una constante de cadena con el nombre ``OFFLINE_BASE``.

Por cada sitio remoto existe un subdirectorio donde se almacena el código
JavaScript del proyecto y sus aplicaciones: ``OFFLINE_BASE/<nombre_sitio_remoto>``. 
En su nivel base se cuenta con los módulos ``settings.js``, ``urls.js``.
Cada aplicación es un subdirectorio y cuenta con módulos ``views.js``, 
``mixins.js``, ``tests.js`` y ``urls.js``.

Desde el punto de vista de Django, un sitio
remoto publica sus métodos como vistas [*]_ y se comporta como un módulo de
``urls``, pero a diferencia de una vista de usuario, la URL (patrón) donde se publica
está definida.
El patrón que se debe utilizar es una propiedad de la instacia
llamada ``urlregex``, es decir que el programador no define donde se publica el sitio
sino que está definido por el sito [*]_ (internamente en función del nombre del sitio remoto
y del parámetro ``OFFLINE_BASE``). Por ejemplo:

.. code-block:: python
    
    from soporte_offline.remote_mi_sitio import site as mi_sitio
    
    urlpatterns = patterns('',
        # Las primeras dos asocaiciones utilizan una cadena 
        (r'^$', index,)
        (r'^vendedores/(?P<id>\d)/$', vista_vendedores),
        
        # En el caso de los sitios remotos, la URL está indicada por el atributo
        # urlregex
        (r'^%s/(.*)' % mi_sitio.urlregex, mi_sitio.root ),
    )
         
En el caso anterior la propiedad ``urlregex`` es ``/soporte_offline/mi_sitio`` y
en ese lugar se encuentra el punto de entrada para la ejecución del proyecto 
desconectado. Al acceder a esta URL el navegador se encuentra con:

.. code-block:: html
    :linenos:
    
    <html>
    <head>
        <!-- El sitio remoto publica la librería Protopy, como JavaScript 1.7 -->
        <script type="text/javascript;version=1.7" 
            src="/soporte_offline/mi_sitio/lib/protopy.js"></script>
        <!-- Creación de la instancia del proyecto desconectado -->
        <script type="text/javascript;version=1.7">
            <!-- Requerir del módulo de proyectos, la función new_project -->
            require('doff.core.project', 'new_project');
            <!-- Instanciación  del proyecto --> 
            var mi_sitio = new_project('mi_sitio', '/soporte_offline/mi_sitio');
            <!-- Darle el control del navegador a la instancia del proyecto -->
            mi_sitio.bootstrap();
        </script>
    </head>
    <body>
    </body>
    
    </html>
        
.. [*] Tomado de TurboGears y Pylons. 

Como se pudo observar en el ejemplo anterior, el código del Protopy se encuentra
en ``lib/protopy.js`` (línea 4 y 5), y como se deinfinió en el capítulo anterior, el códgo
de Doff se encuentra en ``lib/packages/``. En la línea 10, se crea una entrada
en ``sys.path`` de Protopy, definiendo que el paquete ``mi_sitio`` se encuentra en la
URL ``/soporte_offline/mi_sitio``. En este caso ``mi_sitio`` es el paquete que define
al proyecto. Para cargar el módulo ``settings`` mediante 
``require("mi_sitio.settings")`` se está realizando una petición a
``/soporte_offline/mi_sitio/js/settings.js``.

.. [*] Si bien no se recomienda modificar la URL en la cual se publica un sitio remoto,
       el desarrollador puede modificarla.

Además de las URLs descritas, el sitio remoto publica otras de dónde 
Doff descarga los modulos y recursos que componen a la aplicación, 
para almacenarlos localmente y poder ejecutar el proyecto cuando el cliente 
se encuentre sin conexión. Una de estas URLs es ``manifest.json``, en la cual
se encuentra una lista completa de los archivos que componen al proyecto.
Durante la instalación del proyecto se utiliza esta lista para alamacenar
los recursos que componen al proyecto.

A continuación se realiza una descripción del método de migración de proyectos.

Migración de un Proyecto
------------------------

La migración de un proyecto a través de los sitios remotos consiste
de los siguientes pasos:
 
    #. Instalación de la aplicación de soporte (``offline``), este paso es necesario
       solo una vez.
     
    #. Creación de un sitio remoto

    #. Migración de una aplicación
    
    #. Registro de modelos en el RemoteSite
    
    #. Publicación del sitio remoto
    
    #. Creación del ``manifest.json``, este paso se considera el paso a
       producción de la aplicación desconectada.


El primer paso para la migración consiste en la instalación de la
aplicación de soporte ``offline`` al proyecto. Para esto
se la descarga y añade al ``PYTHONPATH``. Posteriormente se debe agregar a
``INSTALLED_APPS`` del proyecto en linea. 

Una vez realizado este paso se habilitan varios comandos para la administración 
de proyectos desconectados al 
módulo ``manage.py``. Estos comandos permiten realizar varios de los pasos
antes mencionados. Los comandos implementados son los siguientes:

 * ``start_remotesite``
	
    Este comando recibe como argumento el nombre de sitio remoto que se desea
    crear. Si no exite el directorio ``OFFLINE_BASE`` en el proyecto en
    línea lo crea y dentro de el añade el módulo ``remote_<nombre-site>.py``
    en el cual define la instancia de ``RemoteSite`` con el nombre dado. Utiliza
    también el nombre para crear un subdirectorio en ``OFFLINE_BASE`` donde
    crea el esqueleto del proyecto desconetado (crando ``settings.js`` y ``urls.js`` 
    a partir de plantillas que son rellenadas con la configuración disponible 
    de la aplicación en linea).
    
    Por ejemplo:
    
    .. code-block:: bash
    
        $ manage.py start_remotesite vendedor_viajante
        
    Esto crea en el directorio de la aplicación la siguiente estuctura (suponiendo
    que ``OFFLINE_BASE`` sea la cadena ``soporte_offline``)::
        
        soporte_offline/
            remote_vendedor_viajante.py
            vendedor_viajante/
                settings.js
                urls.js
                logging.js
    
    
 
 * ``list_remotesites``
    
    Este comando lista los ``RemoteSites`` de un proyecto en línea. Verifica
    además si estos se encuentran publicados. No recibe argumentos.
   
 
 * ``migrate_app``
 
    Migra una aplicación conectada a un ``RemoteSite``. Recibe como argumentos
    el nombre del sitio remoto y el nombre de la aplicación. Dentro
    de ``OFFLINE_BASE/<nombre-site>/<nombre-app>`` crea la estructura de la 
    aplicación (crea los módulos ``views.js`` y ``models.js`` a partir de plantillas).
    
    Por ejemplo:
    
    .. code-block:: bash
    
        $ manage.py migrate_app vendedor_viajante catalogo
        
    Basados en el ejemplo del comando ``start_remotesite``, 
    produciría la siguiente estructura de archivos::
    
        soporte_offline/
            remote_vendedor_viajante.py
            vendedor_viajante/
                settings.js
                urls.js
                logging.js
                catalogo/
                    views.js
                    mixins.js
                    tests.js
                    urls.js
    
    
 * ``manifest_update``
 
    Acutaliza los recursos que componen al proyecto desconectado: vistas,
    plantillas, modelos y recursos estáticos. 
    
.. Una vez creado un sitio remoto, el programador los recuros estáticos que lo componen
   se ubican en ``OFFLINE_BASE/<nombre-site>/``. 

La definción de un remotesite dentro de ``OFFLINE_BASE/remote_<nombre-site>.py``,
resultado del comando ``manage.py create_remotesite <nombre-site>`` tiene 
la siguiente estructura:

.. code-block:: python

    from offline.sites import RemoteSite 

    site = LibrarianRemoteSite('librarian')
    
Cada aplicación migrada mediante el comando ``migrate_app`` es creada a partir
de una esqueleto genérico, donde el programador deberá implementar las URLs 
y vistas. Si bien esta tarea podría parecer tediosa en primera intancia, el
grado de similitud entre Protopy con Python y el hecho de que Doff implemente
la misma API que Django facilita mucho la tarea.

Las plantillas y los modelos son provistos autmáticamente por el sitio remoto.
A continuación se analiza la forma en la que se exponen los modelos y como
se puede modificar.


Publicación de Modelos
----------------------

Como se mencionó en el capítulo introductorio, es deseable contar con 
un mecanismo de separación de los datos a los cuales accede al cliente
por seguridad y eficiencia.

Para tal fin se creó la clase ``RemoteModelProxy`` o proxy de modelos que 
envuelve a los modelos de las aplicaciones.
Por defecto ningún modelo es visible para el cliente. Se deben publicar
explicitamente mediante un método llamado ``register(model, proxy = None)`` [*]_.

.. [*] Esta idea también fue tomada de la aplicación genérica ``django.contrib.admin`` antes mencionada. 

El método ``register`` debe ser llamado sobre la instancia del remote site (definida en el módulo 
``OFFLINE_BASE.remote_<nombre-modulo>`` - en el sistema de archivos 
OFFLINE_BASE.remote_<nombre-modulo>.py). Este método recibe una instancia 
opcional de ``RemoteModelProxy`` que en el caso de no ser provista se genera 
internamente.

Por ejemplo, la definción del sitio remoto quedaría como sigue para el ejemplo
anterior:

.. code-block:: python
    
    from offline.sites import RemoteSite
    from bookstore.core.models import Book, Author  

    site = LibrarianRemoteSite('librarian')
    site.register(Book)
    site.register(Author)
    
De esta manera las vistas del proyecto desconectado tendrán disponible los 
modelos ``Book`` y ``Author``. 

Para personalizar la definición y acceso a datos de un modelo, se debe 
crear una subclase de ``RemoteModelProxy``. Dentro de esta subclase se
pueden definir los campos a publicar mediante (``fields``, ``include``,
``exclude``) y el ``Manager`` del modelo a utilizar [*]_. Por ejemplo:

.. code-block:: python

    from offline.sites import RemoteSite
    from bookstore.core.models import Book, Author  

    site = LibrarianRemoteSite('librarian')

    class BookRemote(RemoteModelProxy):
        class Meta:
            model = Book # Este campo es opcional
            exclude = ('author', )
            manager = Book.objects
    
    site.register(Book, BookRemote) # Registro
    
.. [*] Se pueden definir campos que no existen en el modelo que deberán ser provistos
       por el Manager a la hora de la sincronización.

El Manager permite filtrar las entidades que son accedidas por el cliente.
Si el cliente es un usuario autenticado en el proyecto, mediante la implementación de un
``Manager`` que discrimine usuarios autenticados [*]_, se puede limitar la visión
de las instancias de un modelo (o filas sobre la base de datos).

.. [*] El usuario se ha autenticado en la aplicación en línea contra las entidades
       de ``django.contrib.auth.models.User``.

Cuando se migra una aplicación al cliente, mediante el comando ``migrate_app``,
no se crea un módulo ``models.js`` como podría esperarse. El sitio remoto lo
genera automáticamente en función de los modelos que hallan sido registrados y
los publica en cada aplicación del sitio remoto (es decir, los modelos son
globales al proyecto desconectado).

El sitio remoto solo se encarga de publicar la estrcutra del proxy de modelos,
los métodos opcionales con los que el desarrollador desee contar se deben 
implementar en un mixin. Para este fin existe una archivo por cada aplicación
migrada llamado ``mixins.js`` donde se definen los métodos de los modelos
como un arreglo asociativo. El nombre del arreglo debe conincidir con el nombre
del modelo. Por ejemplo, para el modelo de ``Book``:

.. code-block:: javascript

    var Book = {
        // Representación en cadena del modelo
        __str__: function () {
            return this.nombre;
        }
    };
    
    publish({
        Book: Book
    })


En Django los modelos suelen tener métodos de utilidad, como ``__unicode__`` (
en el cliente ``__str__`` [*]_). Estos métodos se deben implementar en un arreglo
asociativo que se utiliza a modo de ``Mixin``. Como se mencionó en el capítulo
sobre Protopy, la impmentación de clases soporta herencia múltiple, cuando
se requiere la url con la definción del modelo, se requieren automáticamente
los Mixins definidos.


.. [*] Una epxplicación sobre los detalles sobre este método se encuentra


Durante la instalación del proyecto, cuando el ``ManagedLocalStore`` descarga
el recurso, el sitio remoto provee automaticamente la conjunción de la introspección
realizada sobre los modelos con los métodos agregados en el mixin.

En el siguiente esquema se muestra la intreacción entre el sitio remoto, los modelos
de una apicacción, sus managers y los proxies de modelos.

.. figure:: ../_svg/esquema_remotemodelproxy.png
	
	Modelos de una aplicación desconectada
	
Por ejemplo, para una definción de un modelo como sigue:

.. code-block:: python

    # ---------------------------------------------------
    # Definción del modelo en models.py
    # ---------------------------------------------------
    
    from django.db import models
    
    class Persona(model.Model):
        nombre = models.CharField(max_length = 40)
        apellido = models.CharField(max_length = 40)
        
        # Representación en cadena Unicode
        def __unicode__(self):
            reutrn u"%s %s" % (self.nombre, self.apellido)
    
    # ---------------------------------------------------
    # Definción del RemoteSite
    # ---------------------------------------------------
    
    site = RemoteSite('personas')
    site.register(Persona) # Sin proxy

Luego de haber ejecutado el comando ``migrate_app`` el código del Mixin
para implementar la funcionalidad de ``__unicode__`` sería:

.. code-block:: javascript
    
    // El Mixin es simplemente un arreglo asociativo, donde
    // se pueden incorporar más métodos.
    
    var Persona = {
        // En el servidor la salida del modelo se transforma en el encoding
        // del template, en cambio, en el cliente la codificación ya está
        // establecida, por lo que se utiliza el método __str__
        __str__: function() {
            return "%s %s".subs(this.nombre, this.apellido);
        }
    }

Modelos de Solo Lectura
=======================

Si bien se tratará la sincronización en un apartado posterior, se ha mencionado
que existe un mecanismo para sincroizar los datos de los modelos.
La sincronización puede ocurrir del servidor al cliente, la cual es probablemente
necesaria en la instalación y en sentido inverso para sincronizar los datos
generados o modificados durante la ejecución desconectada del proyecto.

Cuando un modelo se registra en un sitio remoto, se concede permiso de modificación
a los campos definidos en el proxy de modelos (tomados automáticamente del modelo).
Si se registra una modelo que posee claves foraneas, y los modelos referenciados
no son registrados, se genera un registro implícito de estos modelos como
solo lectura.

Es decir, si contamos con un modelo como el siguiente:

.. code-block:: python

    from django.db import models
    
    class Pais(models.Model):
        nombre = models.CharField(max_length = 40)
        
    class Provincia(models.Model)
        provincia = models.ForeignKey(Provincia) # Referencia a Provincia
        nombre = models.CharField(max_length = 40)
        habitantes = models.PositiveIntegerField(default = 0)
        
continuando el ejemplo, si en la definición del sitio remoto solo se 
registra la entidad ``Provincia``:

.. code-block:: python

    site.register(Provincia)
            
la entidad ``Pais`` se registra implicitamente como un modelo de solo lectura.
Durante la sincronización los datos solo se transfieren del servidor al cliente.
Los unicos campos transferidos son el ``pk`` (o ``id``) y la representación
en cadena del modelo (``__unicode__``).         

Publicación de un Sitio Remoto
------------------------------

La publicación de un sitio remoto es explícita y consiste en agregar al
módulo ``urls.py`` del proyecto un patrón como el siguiente (suponiendo 
que ``OFFLINE_BASE`` sea "soporte_offline" y el nombre del sitio remoto
sea "bookstore"):

.. code-block:: python

    from soporte_offline.bookstore import bookstore_site
    
    (r'^%s/(.*)' % bookstore_site.urlregex, bookstore_site.root )
    
El atributo ``urlregex`` del sitio remoto calcula automáticamente la URL
del sitio como la concatenación de ``OFFLINE_BASE`` y el nombre del sitio.
En el caso anterior, para acceder al sitio desconectado se debe acceder a la URL::

    http://misitio.com/soporte_offline/bookstore
    
Esta URL genera automáticamente la instancia del proyecto en el cliente.

Finalmente, podemos resumir el ciclo de migración mediante la siguiente figura:

.. figure:: ../_svg/esquema_utilizacion_offline.png

    Esquema de trabajo con la aplicación offline

A continuación se trata uno de los objetivos 

.. note::
    HASTA ACÁ, ESTE NO ES MENTIROSO

Sincronización de Datos
-----------------------

Por simplcidad, en este apartado, se establece la siguiente terminología:
Cuando se hable de *el cliente* se está refiriendo al proyecto desconectado,
 *el servidor* es el proyecto en línea.

La sincronziación de datos permite que las entidades definidas en el servidor
se repliquen en el cliente y que las creadas y modificadas por el cliente
se transfieran a la aplicación en linea, permitiendo así que se porpaguen
a el resto de los cileintes.

Sin embargo diversas situaciones en las cuales se pueden presentar conflictos entre
las versiones de de una misma entidad:

    * Cuando una entidad se modifica tanto en el cliente como en el servidor
    
    * Cuando una entidad se modifica en dos clientes
    
    * Cuando dos o más entidades equivalentes se crean en dos clientes
    
    * Cuando se crea una entidad equivalente en el cliente y en el servidor equivalente
    
    * Cuando se elimina una entidad en el servidor referenciada en el cliente
    
    * Alguna combinación de los casos anteriores
    
La forma en que se resuelven estos conflictos debe ser abordada por el programador
durante el diseño de la aplicación.

Se implementó una mecánica simple y extendible que resuelve casos simples en
``doff.contrib.syncrhonization``.

Para implementar la sincronización se trataron los siguientes items:

    * Integridad de la sincronización (orden de los modelos, transacciones)
    
    * Transporte de datos
    
    * Detección de cambios en instancias en el servidor
    
    * Detección de cambios en el cliente
 



Transporte de Datos
===================

El primer aspecto a considerar es el transporte de datos. Las bases de datos
relacionales utilizan el lenguaje SQL como estándar para la definicón de su
estructura y manipulación de datos. Django provee un ORM que encapsula el
acceso al RDBMS y brinda una capa de abstracción en el lenguaje Python. Doff realiza
lo propio en el lenguaje JavaScript y apoyándose en las extensiones del 
provistas por Protopy. Gracias al trabajo del sitio remoto, mediante
el registro de modelos, se obtiene consistencia entre las definciones de alto
nivel del servidor con las del cliente, por lo cual se optó por realizar el
transporte utilizando los mecanimos de alto nivel disponibles en Django implenetando
el soporte necesario en Doff.

Django provee un módulo llamado ``serializers`` que brinda un conjunto de
serializadores (*marshalling*) de instancias de ``QuerySet``. Un serializador
se encarga de *aplanar* las intancias en texto con algún formato. Los formatos
de salida provistos por Django son: XML, JSON y Python. Cuando un serializador
trabaja sobre un ``QuerySet`` almacena información sobre el modelo para poder
luego recuperar las instancias medinate un des-serializador. L

Se optó por el serializador basado en JSON, debido a que presenta ventajas a la 
hora de depuración aunque teniendo como penalización el tiempo de procesamiento sobre
conjuntos grandes de datos.

Los serializadores son obtenidos a través de un factory de clases con la signatura 
``get_serializer(nombre)``. Para el siguiente modelo:

.. code-block:: python

    
    class Pais(models.Model):
        nombre = models.CharField(max_length = 45)
        simbolo_moneda = models.CharField(max_length = 8, default = '$')
        
        def __unicode__(self):
            return self.nombre
        
        class Meta:
            verbose_name = u"País"
            verbose_name_plural = u"Paises"
        
    class Provincia(models.Model):
        pais = models.ForeignKey(Pais)
        nombre = models.CharField(max_length = 140)
        
        def __unicode__(self):
            return self.nombre

se puede serializar en JSON de la siguiente forma

.. code-block:: python
    :linenos:

    
    from core.models import Provincia # Importanción de modelos
    # Importación del módulo de serialización
    >>> from django.core import serializers
    # Obtención de la calse de serialización en JSON
    >>> SerializadorCls = serializers.get_serializer('json')
    # Creación de una instancia del serializador
    >>> serializador = SerializadorCls()
    
    # Serialización
    >>> plano = serializador.serialize(Provincia.objects.all())
    # Los datos son texto plano
    >>> plano
    
        '[
            {   "pk": 1, 
                "model": "core.provincia", 
                "fields":   {
                    "pais": 1,
                    "nombre": "Buenos Aires"
                }
            }, 
            {
                "pk": 2, 
                "model": "core.provincia",
                "fields": {
                    "pais": 1, 
                    "nombre": "C\\u00f3rdoba"
                }
            }
         ]'
         
    # Para recuperar los datos, se obtiene una función des-serializador
    # que retorna instncias guardables
    
    >>> deserializador_func = serializers.get_desserializer('json')
    
    # Invocación del deserializador sobre el texto serializado
    >>> for obj in deserializador_func(plano):
    ...     # Guardado de la isntancia
    ...     obj.save() 
    

Como se mencionó anteriormente, los modelos expuestos al cliente se encuentran
en registrados en el sitio remoto mediante un proxy. El Manager definido en
este proxy es el que se utilizará a la hora de serializar los datos para 
su envío al cliente. Por defecto, si no se define un Manager, se utiliza
``_default_manager`` que es un alias de ``objects``.

Se implementó sobre Doff el modulo de serialización para poder recuperar 
los datos y generar las instancias correspondientes en el cliente.

Si bien con la utilización de los serializadores brinda un mecanismo extensible
y simple de transporte de datos, se deben tener en cuenta que en el caso
de contar con relaciones en los modelos, los datos serializados deben ser
enviados en orden para no violar la integridad diferencial, provocando
una falla en el método ``save()`` en la deserialización. Desde el 
punto de las relaciones, los modelos conforman una gerarquía de árbol con
múltiples raices. Gracias a la metainformación que brindan las definciones
de alto nivel, el orden de presedencia fue calculado de manera sencilla.


Versionado de Modelos
=====================

Mediante los serializadores y se puede realizar una transferencia de datos
entre el cliente y el servidor, pero no se ha expuesto aún un mecanismo para
controlar los cambios realizados sobre las instancias tanto en el proyecto
en línea como en el proyecto basado en Doff.

Para realizar el análisis de la información necesaria sobre los cambios de
las instancias se planteó un escenario hipotético que se describe a continuación:

    Existe un proyecto en linea, que cuneta con un sitio remoto publicado. Existe
    uno o más instancias del proyecto creado a partir del sitio remoto. Los clientes
    poseen conexión ocacional, durante la cual realizan la tarea de sincronización
    en la cual envían y reciben los cambios del sitio remoto.
    Ante un conflicto de datos insalvable de manera automática se debera adoptar
    una política: adecuación por el usuario, prevalecen datos del servidor, 
    prevalecen datos del cliente, el criterio de permanencia está dado por el la
    antiguedad o privilegios del usuario.

Los camibos en las instancias ocurren ante los eventos de creación, modificación
y eliminación. Sin embargo, esto eventos se producen tanto en la aplicación del
cliente como en la aplicación en línea, por lo que se realiza un anális por 
separado de cada una de estas situaciones:

 * Creación de una entidad
 
    Ocurre cuando se genera una instancia de alguna entidad del ORM y se 
    invoca el método ``save()``
 
    * En el servidor
    
        El cliente debe copiar la nueva intancia en la próxima sincronización.
    
    * En el cliente
    
        La entidad no existe en el serivor, por lo que se debe crear una 
        clave transitoria en el cliente. Durante la sincronización la entidad
        será creada en el proyecto en línea, devolviendo al cliente el identificador
        del servidor.
 
 * Modificación de una entidad
    
    Ocurre cuando se recupera una instancia mediante un Manager y se modifican
    sus valores, llamando posteriormente al método ``save()``.
 
    * En el servidor
        
        Se debe crear un registro de que la entidad ha sido modificada.
    
    * En el cliente
        
        Si la entidad se creó en el cliente, no ocurre nada, la entidad
        sigue siendo nueva para el servidor. En cambio si la entidad fue
        sincronizada con el servidor se debe crear un registro de que la 
        entidad ha sido modificada.
        
 
 * Eliminación de una entidad
    
    Ocurre cuando se invoca ``delete()`` sobre una entidad recuperada mediante
    un Manager, o cuando se invoda directamente sobre el Manager.
    
    Debido a que las entidades pueden tener relaciones, es necesario establecer
    una política. En Doff por defecto se adoptó que las entidades referenciadas 
    están en estado de baja lógica hasta que se invoca una función de purgado.
    
    * En el servidor
        
        Puede que el cliente tenga entidades que referencien a la instancia
        eliminada por lo tanto se debe usar una baja lógica. Eventualmente
        cuando el programador considere adecuado se realiza la baja física 
        mediante la llamada a una función de purgado.
        
    
    * En el cliente
        
        La eliminación en un cliente debe provocar una baja lógica en el servidor.
        
Del breve análisis expusto se deduce que se debe almacenar información extra
referente al estado de una instancia. 
        
Junction [JunctionDocsSync09]_ es un framework de desarrollo de aplicaciones web
que abordó el problema de sincronización agregando una serie de campos en las
entidades::

    - id          integer primary key autoincrement
    - created_at  datetime
    - updated_at  datetime
    - active      integer
    - version     integer
    - id_start    integer
    - id_start_db varchar(40)
    - synced_at   datetime
    
En el caso de Junction, la información de versionado se almacena tanto en el
servidor como en el cliente. Aplicar este enfoque sobre un proyecto existente de
Django no es factible debido a que involucra modificar todas los modelos pre-existentes.

Se optó por el agregado de información de manera asimétrica: En el cliente las
entidades se crean con campos extras, mientras que en el servidor se utilizan
relaciones genéricas.

Información de Sincronización en el Cliente
*******************************************

La información sobre sicronización en el cliente se basó en parte en los campos
que propone Junction, agregándoselos a cada entidad, pero se modeló la
 sincronización como entidad por separado.

Se creo la aplicación genérica ``doff.contrib.offline`` y donde se definió ``SyncLog``.
Cada vez que el cliente realiza una sincronización con el servidor, se 
almacena la fecha sobre una instancia de esta entidad,
de manera que durante la sincronización siguiente, 
solo se trabaje con los modelos afectados en el intervalo de tiempo transcurrido.

Los datos que se agregaron a cada modelo del cliente fueron:

    * ``server_pk``
    
        Es la calve de la entidad en el servidor. El campo ``pk`` se refiere
        al identificador de la entidad en el cliente. Si la entidad se creo en
        el cliente, este campo es ``NULL``
        
    * ``active``
        
        Indica la baja lógica en el servidor. Por defecto toma el valor ``false``.
        
    * ``sync_log``
        
        Referencia la entidad de ``SyncLog`` en el cual fue sincronizado.
        
    * ``status``
        
        Este campo se creó con el objeto de indicar el estado de una entidad
        con respecto a su contraparte en el servidor, sus valores posibles son los siguientes:
            
            * ``"C"`` (created)
            
                La entidad se creó en el cliente mediante el método ``save()``.
                El atributo ``sync_log`` es ``NULL``.
            
            * ``"S"`` (synched)
                
                Indica que la entidad se encuentra sincronizada con el servidor.
                En esta caso, el atributo ``sync_log`` no es ``NULL`` 
                
            * ``"M"`` (modified)
            
                La entidad sincronizada ha sido modificada en el cliente.
                Ante una sincronización se acutaliza la referencia de ``sync_log``
                y se vuelve al estado de sincronizado (``"S"``).
                
            
            * ``"D"`` (deleted)
                
                Indica que la entidad fue borrada en cliente. Ante una sincronización el
                servidor pasa a estado ``"S"`` y el atributo ``active`` pasa 
                a ``false``.
        
    

.. [JunctionDocsSync09] Steve Yen,  
    *TrimPath Junction Syncrhonization*,
    http://trimpath.googlecode.com/svn/trunk/junction_docs/files/junction_doc_sync-txt.html

Se agregó en el cliente la lógica para la manipulación de los campos ``active``
y ``status``, dejando el trabajo de manipulación de los campos ``server_pk`` y
la relación a ``sync_log`` para el proceso de sincronización.

Metainformación de Sincronización en el Servidor
************************************************

Se mencionó en el capítulo en el cual se introdujo Django que el ORM de este framework
brinda lo que se conoce como el framework de ``ContentType`` (no confundir
con la cabecera HTTP), que consiste en una serie de ``Fields`` del ORM que 
permiten crear relaciones genéricas. Además se mencionó que el framework posee
un sistema de señales que permiten el conexionado de eventos del ORM a funciones.

Con el objeto de registrar los cambios sobre entidades en el servidor, se 
decidió crear una entidad denominada ``SyncData``. Una instancia de esta entidad
se crea antes los eventos de guardado (modificación) y eliminación de las entidades
registradas en el sitio remoto mediante el método ``register(model, proxy = None)``.

De esta manera solo las entidades que forman parte del proyecto desoncetado
son "vigiladas" por cambios, registrandose ante estos la fecha.
Cada vez que se registra un modelo a un sitio remoto internamente también
se registran manejadores de eventos ante las señales de guardado, ``post_save`` 
y eliminación, ``post_delete``.



Protocolo de Sincronización
===========================

En Doff se plantearon dos tipos de sincronización: la *sincronización inicial*, que
ocurre cuando un cliente instala el proyecto desconectado a partir del sitio
remoto y la *sincronización normal* que sucede cada vez que el cliente desea
enviar sus cambios y obtener las novedades sobre las instancias
del modelo del proyecto. La sincronización es explícita para el cliente, 
debdio a que en ocaciones donde se requiera asistencia del usuario para dirmir 
los conflictos esto no ocurra de manera sorpresiva.

Se eligió JSON-RPC como mecanismo de invocación de código remoto, debdido a que
fue el mecanismo elegido en la implentación de Protopy.

La aplicación genérica ``doff.contrib.offline`` y en especial su módulo ``syncrhonization`` son
los encargados del manejo de sincronización. Esta aplicación se instala por defecto (durante la ejecución
del comando ``start_remotesite``).

El sitio remoto publica por cada proxy (modelo registrado) el manager defindo
(``objects`` por defecto) mediante JSONRPC en la URL ``/rpc``. 
Cuando se requiere un ``QuerySet`` de algún Manager expuesto, éste se serailzia 
utilizando el mecanismo de serializers de Django.

Se definieron dos métodos:

    * ``push()``
    
        Esta operación envía los cambios del cliente al servidor.
        
        #. Busca en el cliente la última sincronización (última instancia de ``SyncLog``)
           si existe (en el caso de tratarse de la sincronización inicial se envía ``null``).
           
        #. Crea la instancia de instancia de ``SyncLog`` actual.
           
        #. Reliza una llamada a ``begin_syncrhonization()`` con la instancia de ``SyncLog``
           recuperada en **1** como parámetro.
           
        #. El servidor responde con los modelos afectados, el orden y la fecha
           del servidor.
        
        #. Por cada modelo afectado se recuperan las instancias mediante 
           la invocación de métodos del ``RemoteManager`` (los serializadores
           realizan el *marshlling* de los ``QuerySets``).
           El ``RemoteManager`` se encarga de filtrar los modelos modificados
           a partir de la fecha del último ``SyncLog`` y agregar los nuevos.
           Cada modelo es deserializado y guardado en la base de datos del cliente
           creando la referencia al ``SyncLog`` actual y estableciendo el campo
           ``status`` en ``"S"``.
           
        #. Se almacena en el ``SyncLog`` actual la fecha del servidor.
        
    * ``pull()``
    
        #. El clinete envía 
    
        Esta operación trae los cambios del servidor al cliente.
        
En el siguiente diagrama se muestran las entidades que tienen entran en juego
en la sincronización.


.. figure:: ../_svg/esquema_sync_simple.png
    
    Esquema de sincronización en el que inteviene el módulo ``synchronization``
    y el sitio remoto publicando los ``RemoteManager`` mediante JSONRPC.

Durante la sincronización ocurren cambios sobre el atributo ``status`` de las 
instancias del cliente.

.. figure:: ../_svg/esquema_sync_client.png

    Estados de sincronización de los modelos en el cliente

Considreaciones sobre Sincronización
===================================

Doff provee un mecanismo básico de sincronziación adecuado para peuqueñas aplicaciones
que permite al programador contar con las herramientas para transporte, comunicación RPC
y control de cambios. Debido a que no existe una política universal aplicable a
todas las aplicaciones, y debido a que Doff se trata de un framework extendible, 
se pueden implmentar mecanismos más sofisticados en base a las herramientas expuestas.

 