****************
La aplicación
****************

Una vez lograda la implementación de Django en el clinete sobre el framework
de aplicaciones Doff, se comenzó a trabajar en la integración con los proyectos
en línea.


Doff fue desarrollado con el objetivo de realizar la menor cantidad de 
reescritura posible de las aplicaciones Django al momento de ser ejecutadas de manera
desconectada. Si bien fue intecinalmente omitido en el capítulo sobre el
framework desconectado, el hecho de contar con la misma API de ORM posibilita la generación de 
modelos del cliente de manera autónoma a partir del análisis
de las definciones de los modelos de la aplicación en linea.

De la misma manera, las plantillas del proyecto conectado, no requieren
adaptaciones (en el caso de que utilicen JavaScrpipt, deben adecuarlo
a las normativas de Doff y las etiquetas de templates no estándares
deben ser reescritas en Doff).

Las vistas y las URLs deben ser reescritas, ya que por
no contarse con el mismo soporte para expresiones regulares, y debido
a que las vistas en Django son funciones escritas en Python, estas 
no pueden ser traducidas a JavaScript sin la intervensión del programador.

En el capítulo sobre Doff se introdujo vagamente una aplicación Django llamada
``offline`` que tenía como objetivo servir estáticamente al cliente con
el código de Doff y Protopy. En el presente capítulo se centra sobre la 
utilidad de dicha aplicación.

Se introduce la entidad ``RemoteSite`` que tiene como objetivo ser el punto
vínculo con la aplicación desconectada y brindar mecanismos para seguridad
y sincronización de datos. Esta entidad se encuentra implementada en el 
la aplicación ``offline``.

Como se introdujo en el capítulo teórico sobre las tecnologías del servidor,
el mecanismo de comunicación con Django es la lína de comandos (CLI) y
brinda una API para la generación de comandos presonalizados que se aprovechó
para automatizar varios pasos de la migración de un proyecto.

RemoteSite
----------

La calse ``RemoteSite`` define un proyecto desconectado. Tiene varias 
responsabilidades, entre ellas, servir el código del framework Doff,
el del proyecto, administrar la forma en que el cliente accede a los
datos y permitir la sincornización. Esta clase se impleentó en 
``offline.sites.RemoteSite``.

Su interfase está basada en buena medida en la que presenta la adminstración
que provee Django (``django.contrib.admin``), donde un 
sitio de administración se encarga de las operaciones de CRUD sobre 
los modelos que le son registrados. Pueden existir múltiples sitios de
administración en un proyecto. Cada sitio se publica en una 
URLs dentro del proyecto [DjangoNewFormsAdminBranch09]_.

.. [DjangoNewFormsAdminBranch09] Brian Rosner, Django Trac,
   *The newforms-admin branch*,
   último acceso Octubre 2009,
   http://code.djangoproject.com/wiki/NewformsAdminBranch,
   http://code.djangoproject.com/changeset/7967

Un ``RemoteSite`` representa *una* migración del proyecto. Es decir,
para un mismo proyecto en línea, pueden existir una o más migraciones.
Cada sitio remoto se encuentra publicado en alguna URL en el proyecto.
Cada sitio remoto posee una serie de modelos registrados, sobre los cuales
se puede definir cuales son de solo lectura y cuales de lectura-escritura
(en la sincronización).
Mediante el mecanismo de autenticación y autorización de Django 
(``django.contrib.auth``) se puede restringir que usuario o rol
accede a cada sitio remoto. 

Existe una directorio (que también es un módulo Python) donde se almacenan
los módulos que definen los sitios remotos. Cada sitio remoto posee un 
nombre único. El nombre de este directorio se define en el módulo ``settings.py``
del proyecto como ``OFFLINE_BASE``.

Por cada sitio remoto existe un subdirectorio donde se almacena el código
JavaScript del proyecto y sus aplicaciones: ``OFFLINE_BASE/<nombre_sitio_remoto>``. 

En su nivel base se cuenta con los módulos ``settings.js``, ``urls.js``.
Cada aplicación es un subdirectorio y cuenta con módulos ``views.js``, 
``mixins.js``, ``tests.js`` y ``urls.js``.

Existe una estrecha interacción entre Doff y los sitios remotos:
El sitio remoto publica una serie de URLs de donde Doff descarga los modulos y
recursos que componen a la aplicación, para almacenarlos localmente y poder
ejecutar el proyecto cuando el cliente se encuentre sin conexión. Esta tarea
se realiza mediante un manifesto publicado en la URL ``manifest.json``.

El componente ``ManagedLocalStore`` de Gears se encarga de persistir en el
cliente todas las URLs que publique el manifesto.


A continuación se realiza una descripción del método de migración de proyectos.

Migración de una Proyecto
-------------------------

La migración de un proyecto a través de los sitios remotos consiste
de los siguientes pasos:
 
    #. Instalación de la aplicación de soporte (``offline``), este paso es necesario
       solo una vez.
     
    #. Creación de un sitio remoto

    #. Migración de una aplicación
    
    #. Registro de modelos en el RemoteSite
    
    #. Publicación del sitio remoto
    


El primer paso para la migración consiste en la instalación de la
aplicación de soporte ``offline`` al proyecto. Para esto
se la descarga y añade al ``PYTHONPATH``. Posteriormente se debe agregar a
``INSTALLED_APPS`` del proyecto en linea. 

Una vez realizado este paso se habilitan varios comandos para la administración 
de proyectos desconectados al 
módulo ``manage.py``. Estos comandos permiten realizar varios de los pasos
antes mencionados. Los comandos implementados son los siguientes:

 * ``start_remotesite``
	
    Este comando recibe como argumento el nombre de sitio remoto que se desea
    crear. Si no exite el directorio ``OFFLINE_BASE`` en el proyecto en
    línea lo crea y dentro de el añade el módulo ``remote_<nombre-site>.py``
    en el cual define la instancia de ``RemoteSite`` con el nombre dado. Utiliza
    también el nombre para crear un subdirectorio en el ``OFFLINE_BASE`` donde
    crea el esqueleto del proyecto desconetado (``settings.js`` y ``urls.js`` 
    que son rellenados con la configuración disponible de la aplicación en linea).
    
    Por ejemplo:
    
    .. code-block:: bash
    
        $ manage.py start_remotesite vendedor_viajante
        
    Esto crea en el directorio de la aplicación la siguiente estuctura (suponiendo
    que ``OFFLINE_BASE`` sea la cadena ``soporte_offline``)::
        
        soporte_offline/
            remote_vendedor_viajante.py
            vendedor_viajante/
                settings.js
                urls.js
                logging.js
    
    
 
 * ``list_remotesites``
    
    Este comando lista los ``RemoteSites`` de un proyecto en línea. Verifica
    además si estos se encuentran publicados. No recibe argumentos.
   
 
 * ``migrate_app``
 
    Migra una aplicación conectada a un ``RemoteSite``. Recibe como argumentos
    el nombre del sitio remoto y el nombre de la aplicación. Dentro
    de ``OFFLINE_BASE/<nombre-site>/<nombre-app>`` crea la estructura de la 
    aplicación (módulos ``views.js`` y ``models.js``).
    
    Por ejemplo:
    
    .. code-block:: bash
    
        $ manage.py migrate_app vendedor_viajante catalogo
        
    El ejemplo anterior, basados en lo definido en el comando de más arriba, 
    produciría la siguiente salida::
    
        soporte_offline/
            remote_vendedor_viajante.py
            vendedor_viajante/
                settings.js
                urls.js
                logging.js
                catalogo/
                    views.js
                    mixins.js
                    tests.js
                    urls.js
    
    
 * ``manifest_update``
 
    Acutaliza los recursos que componen al proyecto desconectado: vistas,
    templates, modelos y recursos estáticos. 
    
Una vez creado un sitio remoto, sus recuros estáticos que lo componen
se ubican en ``OFFLINE_BASE/<nombre-site>/``. 

La definción de un remotesite dentro de ``OFFLINE_BASE/remote_<nombre-site>.py``,
resultado del comando ``manage.py create_remotesite <nombre-site>`` tiene 
la siguiente estructura:

.. code-block:: python

    from offline.sites import RemoteSite 

    site = LibrarianRemoteSite('librarian')     

Publicación de Modelos
----------------------

Como se mencionó en el capítulo introductorio, es deseable contar con 
un mecanismo de separación de los datos a los cuales accede al cliente
por seguridad y eficiencia.

Para tal fin se creó la clase ``RemoteModelProxy`` o proxy de modelos que 
envuelve a los modelos de las aplicaciones.
Por defecto ningún modelo es visible para el cliente. Se deben publicar
explicitamente mediante un método llamado ``register(model, proxy = None)`` [*]_.

.. [*] Esta idea también fue tomada de la aplicación genérica ``django.contrib.admin`` antes mencionada. 

El método ``register`` debe ser llamado sobre la instancia del remote site (definida en el módulo 
``OFFLINE_BASE.remote_<nombre-modulo>`` - en el sistema de archivos 
OFFLINE_BASE.remote_<nombre-modulo>.py). Este método recibe una instancia 
opcional de ``RemoteModelProxy`` que en el caso de no ser provista se genera 
internamente.

Por ejemplo, la definción del sitio remoto quedaría como sigue para el ejemplo
anterior:

.. code-block:: python
    
    from offline.sites import RemoteSite
    from offline.sites import RemoteModelProxy
    from bookstore.core.models import Book, Author  

    site = LibrarianRemoteSite('librarian')
    site.register(Book)
    site.register(Author)
    
De esta manera las vistas del sitio remoto tendrán disponible los 
modelos ``Book`` y ``Author``. 

Para personalizar la definición y acceso a datos de un modelo, se debe 
crear una subclase de ``RemoteModelProxy``. Dentro de esta subclase se
pueden definir los campos a publicar mediante (``fields``, ``include``,
``exclude``) y el ``Manager`` del modelo a utilizar. Por ejemplo:

.. code-block:: python

    class TagRemote(RemoteModelProxy):
        class Meta:
            model = Tag # Este campo es opcional
            exclude = ('title', )
            manager = Tag.objects
    
    site.register(Tag, TagRemote) # Registro

El manager permite filtrar las entidades que son accedidas por el cliente.
Si el cliente es un usuario autenticado en el proyecto, mediante la implementación de un
``Manager`` que discrimine usuarios autenticados [*]_, se puede limitar la visión
de las instancias de un modelo (o filas sobre la base de datos).

.. [*] El usuario se ha autenticado en la aplicación en línea contra las entidades
       de ``django.contrib.auth.models.User``.



.. figure:: ../_svg/esquema_offline_simple.png
	
	Análisis inicial de elementos a transferir para lograr una versión offline de un proyecto


Bootstrap
---------

Transferencia de los modelos
----------------------------


Debido a que la API de base de datos posee diferencias mínimas,
la transferencia de la definición de los modelos al cliente se ideó de tal forma
que sea posible mediante introspección. 

Para que el clinete conozca la definción de un modelo, realiza una 


Ciclo de Trabajo
----------------

.. figure:: ../_svg/esquema_utilizacion_offline.png

	Esquema de trabajo con la aplicación offline
	
Comunicación Entre el RemoteSite y el Proyecto del Cliente
----------------------------------------------------------


^$')                                    
^network_check/?$')
^rpc/?$')
^rpc/data/(?P<app_label>\w+)/(?P<model_name>\w+)/$')
manifest.json$')
^templates/(.*)$')
^template_list/$')
system/(.*)$')
project/(.*)$')
^network_check/?$')
^jsonrpc/?$')
^manifests/system.json$')
^manifests/project.json$')
^export/(?P<app_name>.*)/models.js$')
^export_/(?P<app_name>.*)/models.js$')