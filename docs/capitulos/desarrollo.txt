##########
Desarrollo 
##########

El desarrollo consistió en el siguiente diagrama:

.. image:: ../_svg/esquema_general.png

.. _capitulos-protopy:

*************
La biblioteca
*************

La idea de diseñar y desarrollar un framework en que funcione en el hambiente
de un navegador web, como es Firefox, deja entrever muchos aspectos que no
resultan para nada triviales al momento de codificar.

* Se requieren varias lineas de codigo para implementar un framework.
* Como llega el codigo al navegador y se inicia su ejecucion.
* La cara visible o vista debe ser fasilmente manipulable por la aplicacion de
usuario.
* Como los datos generados en el cliente son informados al servidor.
* El framework debe brindar soporte a la aplicacion de usuario de una forma
natural y transparente.
* Se debe promover al reuso y la extension de funcionalidad del framework.
* Como se ponen en marcha los mecanimos o acciones que la aplicacion de usuario
define.

En este capitulo se introducen las ideas principales que motivaron la
creacion de una biblioteca en JavaScript, que brinde el soporte necesario al
framework y a buena parte de los items expuestos.

Si bien el desarrollo de la biblioteca se mantuvo en paralelo a la del
framework, existen aspectos basicos a los que esta brinda soporte y permiten
presentarla en un apartado separado como "Una Biblioteca en JavaScript", esta
constituye la base para posteriores construcciones y auna herramientas que
simplifican el desarrollo client-side.

    | **proto** type + **py** thon = **protopy**

"La creación nace del caos", la libreria "Protopy" no escapa a esta
afirmacion e inicialmente nace de la integracion de Prototype con
las primeras funciones para lograr la modularizacion; con el correr de las
lineas de codigo [*]_ el desarrollo del framework torna el enfoque inicial poco
sustentable, requiriendo este de funciones más Python-compatibles se desecha la
libreria base y se continua con un enfoque "pythonico", persiguiendo de esta
forma acercar la semántica de JavaScript 1.7 a la del lenguaje de programacion
Python.

.. [*] Forma en que los informaticos miden el paso del tiempo.

No es arbitrario que el navegador sobre el cual corre Protopy sea Firefox y
mas particularmente sobre la version 1.7 de JavaScript. El proyecto mozilla
esta hacercando, con cada nueva versiones del lenguaje, la semantica de
JavaScript a la de Python, incluyendo en esta version generadores e iteradores
los cuales son muy bien explotados por Protopy y el framework.

Protopy
=======
Protopy es una biblioteca JavaScript para el desarrollo de aplicaciones
web dinamicas. Aporta un enfoque modular para la inclusión de código,
orientación a objetos, manejo de AJAX, DOM y eventos.

Para una referencia completa de la API de Protopy remitase al apandice
:ref:`Protopy <apendices-doff-dbapi>`

.. _protopy-modulos:

Organizando el codigo
=====================

Como ya se vio en la sección dedicada a :ref:`JavaScript <cliente-javascript>`,
una de las formas tradicionales y recomendada de incluir funcionalidad en un
documento HTML es mediante el tag `script`, haciendo una referencia en el
atributo `src` a la url del archivo que contiene el codigo; en una instancia 
posterior, cuando el cliente accede al recurso, carga el archivo con las
sentencias JavaScript y las interpreta en el contexto del documento.

El enfoque tradicional resulta sustentable para pequeños proyectos, donde el
lenguaje brinda mayormente soporte a la interacción con el usuario (validacion,
accesibilidad, etc) y los fragmentos de código que se pasan al cliente son
bien conocidos por el desarrollador, pero en proyectos que implican mayor cantidad
de funcionalidad JavaScript, con grandes cantidades de código, este enfoque
resulta complejo de mantener y evolucionar en el tiempo. Es por esto que para
Protopy se busco como primera medida una forma de organizar y obtener el código
del servidor que resulte sustentable y escalable.

Similar al concepto de :ref:`modulos en Python <servidor-lenguajes-python>`, el
desarrollo de Protopy se oriento en pequeñas unidades funcionales llamadas
**modulos**.

Además de la sanidad mental que implica organizar el código en distintos
archivos, los módulos representan un cambio muy importante en la obtención de
funcionalidad; ya no es el documento HTML el que dice al cliente que archivo
cargar del servidor, sino que el mismo código interpretado va obteniendo la
funcionalidad a medida que la requiere.

El enfoque modular no es nuevo en programación y basicamente, la implementación
de Protopy, implica llevar el concepto de "divide y vencerás" ó "análisis
descendente (Top-Down)" al hambito de JavaScript.

Un módulo resuelve un problema especifico y define una interfaz de comunicación
para accesar y utilizar la funcionalidad que contiene. Por más simple que
resulte de leer, esto implica que existe una manera de **obtener** un modulo y
una manera de **publicar** la funcionalidad de un modulo, logrando de esta forma
que interactuen entre ellos.

En su forma mas pedestre un módulo es un archivo que contiene definiciones y
sentencias de JavaScript. El nombre del archivo es el nombre del módulo con el
sufijo .js pegado y dentro de un módulo, el nombre del módulo está disponible
como el valor de la variable `__name__`.

Obtener un módulo
-----------------

La función `require` es la encargada de obtener un módulo del servidor e
incorporarlo al :ref:`espacio de nombres <servidor-lenguajes-python>` del
llamador. Por ejemplo, cuando un módulo llamado spam es requerido, Protopy busca un archivo
llamado spam.js en la url base [*]_, de no encontrar el archivo el error
``LoadError`` es lanzado a la función que requirio el módulo.

.. [*] Ruta base desde la cual la biblioteca Protopy carga los módulos, por
    defecto esta es la url base del archivo protopy.js más el sufijo `packages`.

Otra forma de obtener módulos es usando nombres de **paquetes**. A diferencia de
Python un paquete no incluye funcionalidad en si mismo y su funcionalidad
principal es la de establecer las bases en la cual buscar modulos.
De forma similar a la anterior cuando un módulo llamado foo.spam es importado,
Protopy busca en el objeto sys.paths si existe una url asociada al paquete foo,
de encontrar la url base para foo el archivo spam.js es buscado en esa
ubicación, por otra parte si sys.paths no contiene una url asociada a foo el
archivo foo/spam.js es buscado en la url base. 

El uso del objeto sys.paths permite a los modulos de JavaScript que saben lo
que están haciendo modificar o reemplazar el camino de búsqueda para los módulos.
Nótese que es importante que el script no tenga el mismo nombre que un
:ref:`módulo estandar <apendices-protopy-modulos>`.

Las formas en que el modulo obtenido es presentado al llamador difiere en
funcion de los parametros pasados a `require`. Estas formas son:

    * Un modulo puede ser obtenido como un objeto,

    * Se puede obtener solo determinada funcion de un modulo,

    * O se pueden importar todas las definiciones del módulo en el espacio de
    nombres del llamador.

Para ver más :ref:`Apendice Protopy <apendices-protopy>`.

Publicar un módulo
------------------

La acción de publicar un modulo implica exponer la funcionalidad que este define.
En Python no es necesario explicitar que funcionalidad del módulo se expone a
los llamadores, ya que todo lo definido en él es público; pero los módulos en
Protopy se evaluan dentro de una clausura y los llamadores no podran acceder
a sus funciones si no son publicadas. 

La funcion `publish` es la encargada de relizar la tarea de publicar el
contenido del modulo en Protopy.

Un modulo puede contener sentencias ejecutables y definición de funciones,
generalmente las sentencias son para inicializar el módulo ya que estas se
evaluan solo la primera vez que el módulo es requerido a alguna parte y las
definiciones son las que efectivamente seran publicadas como funcionalidad.

A continuación se presenta un fragmento de código que ejemplifica el uso de las 
dos funciones presentadas.

.. code-block:: javascript Figura algo
    :linenos:

     /* Obtengo la funcion copy y deepcopy del modulo copy
        estas funciones son para copia de objetos
        superficiales y en profundidad respectivamente. */
    require('copy', 'copy', 'deepcopy');

    /* Representa la cantidad maxima de caches */
    var MAX = 1000;

    /* Objeto para guardar las cache */
    var cache = {};

    ...

    /* Estructura de datos que representa a una cache */
    var Cache = type('Cache', [ Dict ], {
        ...
    });

    /* Funcion que retorna una cache */
    function get_cache(name) {
        if (len(cache) > 1000)
            throw new Exception('%s caches creadas'.subs(MAX));
        var c = cache[name];
        if (!isundefined(c)) {
            c = new Cache();
            cache[name] = c;
        }
        return d;
    }

    /* Publico la cantidad maxima de caches
       la funcion para obtener caches. */
    publish({
        MAX: MAX,
        get_cache: get_cache
    });

Asumiendo que el código presentado está en un archivo llamado `caches.js` en
la url base, éste representa un módulo en sí mismo y el acceso se obtiene
mediante la invocación de 'require('caches')'.

.. note:: describir de forma rápida los módulos principales

.. _protopy-tipos:

Creando tipos de objeto
=======================

.. note:: Hacer la referencia al codigo anterior

En el apartado teórico se toco el tema de construcción de objetos en base a
"clases" y de la emulacion de herencia en JavaScript. Aunque muchos autores
cuestionan estas practicas alegando, con justa razon, que no tiene sentido
emular un paradigma dentro de otro; en la practica tener una implementación de
objetos tipados mediante clases en JavaScript ayuda a los programadores a
acercarse a este lenguaje y al reuso de código.

La función contrcuctora de tipos en la biblioteca surgue como herramienta para
proveer al framework de mecanismos de extensión.

.. code-block:: javascript Figura algo
    :linenos:

    var Dict = type('Dict', object, {
        ...
    });

    var SortedDict = type('SortedDict', [ Dict ], {
        __init__: function(object) {
            this.keyOrder = (object && isinstance(object, SortedDict))? copy(object.keyOrder) : [];
            super(Dict, this).__init__(object);
        },
        __iter__: function() {
            for each (var key in this.keyOrder) {
                var value = this.get(key);
                var pair = [key, value];
                pair.key = key;
                pair.value = value;
                yield pair;
            }
        },
        __deepcopy__: function() {
            var obj = new SortedDict();
            for (var hash in this._key) {
                obj._key[hash] = deepcopy(this._key[hash]);
                obj._value[hash] = deepcopy(this._value[hash]);
            }
            obj.keyOrder = deepcopy(this.keyOrder); 
            return obj;
        },
        __str__: function() {
            var n = len(this.keyOrder);
            return "%s".times(n, ', ').subs(this.keyOrder);
        },
        set: function(key, value) {
            this.keyOrder.push(key);
            return super(Dict, this).set(key, value);
        },
        unset: function(key) {
            without(this.keyOrder, key);
            return super(Dict, this).unset(key);
        }
    });

Protopy define un constructor de "tipos de objetos" llamado `type`. Notese que
aquí nos referimos a tipos y no a clases.

Al igual que muchas partes de Protopy `type` cambio a lo largo del desarrollo,
sumando soporte para herencia multiple, metodos magicos e incluso "metatipos".

En el ejemplo presentado se utiliza la funcion type para definir el tipo
SortedDict, el cual es una especializacion del tipo base Dict. En la definicion
se detalla bastante bien el comprotambiento de esta type; como primer argumento
recibe el nombre para el nuevo tipo, seguidamente un arreglo con los tipo base y
para terminar un objeto con los atributos y metodos.

Metodo importentes:

    * __init__

        Este es el metodo que se invoca inmediatamente después de contruir un
        nuevo objeto de este tipo. Sería tentador decir que es el “constructor”
        de la clase. Si bien se parece un constructor de Java, actúa como si lo
        fuese ya que el objeto ya esta instanciado cuando se llama a esta
        función.

    * __str__

        Este metodo se llama cuando es necesario proveer de una reprecentacion
        en texto del objeto, JavaScript provee para este objetivo el metodo
        toString, pero por cuestiones de nombres se prefirio usar este metodo en
        su lugar y hacer internamente una relacion entre las funciones.

    * __iter__

        Protopy se vale de versiones modernas de JavaScript y brinda soporte a
        iteradores, este es el método que el desarrollador debe definir si
        quiere objetos iterable, la funcion debe retornar un objeto que
        implemente el metodo next (un iterador o un generado), los bucles
        for hacen esto automáticamente, pero también se puede hacer manualmente.

Otros metodos:

    * __deepcopy__
    * __copy__
    * __json__
    * __html__

Para instanciar un nuevo tipo se utiliza el operador new de JavaScript, este
operador crea el nuevo objeto e invoca a la funcion __init__.

Los primeros tipos que surgen para la organizacion de datos dentro de la
librerias con los "Sets" y los "Diccionarios", hambos aproximan su
estructura a las estructuras homonimas en python, brindando una funcionalidad
similar. Si bien la estructura "hasheable" nativa a JavaScript en un objeto,
los diccionarios de Protopy permiten el uso de objetos como claves en lugar de
solo cadenas.

Extendiendo DOM y JavaScript
============================

Si bien el :term:`DOM` ofrece ya una :term:`API` muy completa para acceder,
añadir y cambiar dinámicamente el contenido del documento HTML, existen
funciones muy utiles y comunes en los desarrollos que los programadores
incorporan al HTML y se intentaron englobar y mantener dentro del nucleo de
Protopy. Funciones para modificar e incorporar elementos al documento son muy
comunes y estan disponibles en Protopy, en conjunto con otras para el manejo de
formularios, como serializacion, obtencion de valores, etc.

Otra extension interesante de mencionar es la de los tipos de datos en
JavaScript, en manejo de cadenas incorpora nuevas funciones que simplifican
tareas comunes, los numeros y fechas tambien tiene su aporte.

Los eventos estan uniforamdos bajo un modulo de manejo de eventos, que permite
conectar eventos del :term:DOM con funciones en JavaScript, así tambien como
funciones entre si.

.. note:: Poner los nombres de las funciones para destacar el laburo

Envolviendo a gears
===================

La biblioteca puede funcionar independiente de la instalación de Google Gears,
debido a que su principal funcionalidad como ya se menciono es la de extención de
JavaScript y posterior soporte al framework, pese a esto Protopy provee
mecanismos para uniformar el acceso y extender los objetos de Gears cuando éste
se encuentra instalado en el navegador.

El acceso al `Factory` de Gears esta centralizado y controlado en el objeto
`gears` dentro del modulo `sys`, mediante este objeto es posible conocer el
estado de Gears y sus permisos. El objeto informa al desarrollador si Gears esta
instalado, la versión, si los permisos son corrector e incluso simplifica
el proceso de instalación de la extensión de no estar presente en el navegador
entre otras cosas.

El metodo `create` del objeto `sys.gears` es el encargado de crear y retornar
los objetos Gears. Esta función se ayuda de módulos presentes en el paquete
`gears` para asistir la creación de los objetos. El objeto que se retorne
dependera de la precencia del módulo con el mismo nombre en dicho paquete; de no
encontrar un modulo que asista la cración de un objeto Gears el objeto en sus
estado "puro" es retornado al llamador.

Si bien no es necesario que los módulos obtengan el acceso a Gears a traves de
Protopy, es recomendable que asi se haga; ya que la biblioteca provee los
mecanimos de extención para los objetos en `create`. Esto no fue así desde el
comienzo de del desarrollo y fue una idea que se maduro luego de observar que
resultaba complejo y costoso requerir los módulos que involucraban a Gears
desde distintos lugares.

El desarrollo del framework implico extender algunos objetos Gears, concretamente
al paquete `gears` se incorporaron los siguientes módulos:

    * desktop

        El objeto `desktop` de Gears permite interactuar con el escritorio del cliente. 
        Aquí se extendio la creacción de accesos directos para simplificar la generación
        de los mismos y agregar la posibilidad de manejar `Icon` y algunos `IconTheme`.

    * database

        Sobre el objeto `database` se agrego funcionalidad uniformar el acceso a la base
        de datos por los módulos de Protopy y encapsular los `ResulSet` en cursores a
        los que se incorporo iteradores, registro de funciones para tipos de datos, etc.

Auditando el codigo
===================

Una queja recurrente de los desarrolladores que trabajan con JavaScript es lo
complejo que resulta el lenguaje para depurar errores. Encontrar errores en
el código resulta molesto y mas todavía si la salida de los mismos no esta en un
formato adecuado y encausada en un lugar especifico.

Tradicionalmente lo que se hace para detectar errores es valerse de funciones
`alert` diseminadas por el código con textos del estilo "Paso por aquí", pero
luego de cerrar unas diez o quince ventanas de este estilo, generalmente se
pierde referencia de donde esta ocurriendo el error y se cae en la tentación de
comenzar a comentar alerts a mansalva esperando dar con el indicado. Este es un
claro ejemplo de que tanto la salida como el sistema de detección de errores es
molesto e infructifero.

Una clara ventaja sobre el sistema tradicional y poderosa herramienta de
desarrollo es el plug-in Firebug, que integra entre otras cosas una consola
JavaScript y un debuger al ambinete del navegador, permitiendo a los
desarrolladores depurar el código mediante puntos de corte, inspección de
variables, etc. En firebug la consola pasa a ser por defecto la principal salida
de errores, gracias a la funcion `console.log` los desarrolladores pueden
redirigir todos los "Paso por aquí" a una salida uniforme e incluso inspeccionar
el valor de las variables.

Protopy lleva la depuración y auditoria del código un paso más lejos, integrando
un sistema de logging propio altamente configurable y con posibilidades de
escribir en diferentes salidas y con diferentes formatos.

Similar a log4j el logger de Protopy trabaja con niveles de prioridad para los
mensajes, distintos manejadores o `Handlers` y salidas en varios formatos. Todo
esto configurable por el desarrollador.

Una vez configurado el sistema de logging, los módulos que requieran auditar el
codigo solo deben requerir un logger en su sespacio de nombre e invocar a sus
funciones.

.. code-block:: javascript

    var logging = require('logging.base');
    var logger = logging.get_logger(__name__);

    ...

    logger.debug('La query: %s\n Los parametros: %s', query, params, {});

En este ejemplo se requiere el módulo `logging` y posteriormente un logger para
el módulo con el nombre __name__, de no encontrar configuración para este módulo
se adopta la configuracion del modulo inmediato superior y asi consecutivamente
hasta tomar la configuración del root logger.

Suponiendo que el módulo del ejemplo se llama doff.db.models.sql el siguiente
archivo de configuracion perapraria este logger en modo DEBUG para auditar el
código en la consola de firebug y en una url con distintos formatos.

.. code-block:: javascript

    {
        'loggers': {
            'root': {
                'level': 'DEBUG',
                'handlers': 'firebug'
            },
            'doff.db.models.sql': {
                'level': 'DEBUG',
                'handlers': [ 'firebug', 'remote'],
                'propagate': true
            },
        },
        'handlers': {
            'firebug': {
                'class': 'FirebugHandler',
                'level': 'DEBUG',
                'formatter': '%(time)s %(name)s(%(levelname)s):\n%(message)s',
                'args': []
            },
            'remote': {
                'class': 'RemoteHandler',
                'level': 'DEBUG',
                'formatter': '%(levelname)s:\n%(message)s',
                'args': ['/loggers/audit']
            },
            'alert': {
                'class': 'AlertHandler',
                'level': 'DEBUG',
                'formatter': '%(levelname)s:\n%(message)s',
                'args': []
            }
        }
    }

.. note:: Poner referencia a firebug

Interactuando con el servidor
=============================
.. HttpRequest


Soporte para json
=================

La idea detras del soporte para JSON en Protopy es la transimisión de datos
generados offline por el cliente, en el momento de recuperar la conexion con el
servidor el cliente debe serializar los datos y enviarlos al servidor; otro uso
para es el intercambio de mensajes de control.

La transferencia de datos involucra varios temas, uno de ellos y que compete
a este apartado, es el formato de los datos que se deben pasar por
la conexcion; este formato debe ser "comprendido" tanto por el cliente como
por el servidor. Desde un primer momento se penso en JSON como el formato
de datos a utilizar, es por esto que Protopy incluye un modulo para trabajar
con el mismo.

El soporte para JSON se encuentra en el modulo "json" entre los módulos
estandar de Protopy. Este brinda soporte al pasaje de estructuras de datos
JavaScript a JSON y viceversa.

Los tipos base del lenguje JavaScript estan soportados y tienen su
reprecentacion correspondiente, object, array, number, string, etc. pero este
modulo interpreta ademas de una forma particular a aquellos objetos que
implementen el metodo __json__, dejando de este modo en manos del
desarrollador la reprecentacion en JSON de determinado objetos.

Con el soporte de datos ya establecidos en la libreria, el framework solo
debe limitarse a hacer uso de él y asegurar la correcta sincronizacion de datos
entre el cliente y el servidor web, este tema se retomara en el capitulo de
sincronizacion.

XML
---

No existe una razon concreta por la cual se deja de lado el soporte en Protopy
para XML como formato de datos; aunque se puede mencionar la simplicidad de
implementacion de un parser JSON contra la implementacion de uno en XML.
Para el leector interesado agregar el sporte para XML en Protopy consta de
escribir un modulo que realize esa tarea y agregarlo al paquete base.

Ejecutando codigo remoto
========================
.. JSON-RPC http://json-rpc.org/ 
.. XML-RPC http://www.xmlrpc.com/
El RPC (del inglés Remote Procedure Call, Llamada a Procedimiento Remoto) es un
protocolo que permite a un programa de ordenador ejecutar código en otra máquina
remota sin tener que preocuparse por las comunicaciones entre ambos. El protocolo
es un gran avance sobre los sockets usados hasta el momento. De esta manera el
programador no tenía que estar pendiente de las comunicaciones, estando éstas
encapsuladas dentro de las RPC.

Las RPC son muy utilizadas dentro del paradigma cliente-servidor. Siendo el
cliente el que inicia el proceso solicitando al servidor que ejecute cierto
procedimiento o función y enviando éste de vuelta el resultado de dicha operación
al cliente.

Hay distintos tipos de RPC, muchos de ellos estandarizados como pueden ser el RPC
de Sun denominado ONC RPC (RFC 1057), el RPC de OSF denominado DCE/RPC y el
Modelo de Objetos de Componentes Distribuidos de Microsoft DCOM, aunque ninguno
de estos es compatible entre sí. La mayoría de ellos utilizan un lenguaje de
descripción de interfaz (IDL) que define los métodos exportados por el servidor.

Hoy en día se está utilizando el XML como lenguaje para definir el IDL y el HTTP
como protocolo de red, dando lugar a lo que se conoce como servicios web.
Ejemplos de éstos pueden ser SOAP o XML-RPC. XML-RPC es un protocolo de llamada a
procedimiento remoto que usa XML para codificar los datos y HTTP como protocolo
de transmisión de mensajes.[1]

Es un protocolo muy simple ya que sólo define unos cuantos tipos de datos y
comandos útiles, además de una descripción completa de corta extensión. La
simplicidad del XML-RPC está en contraste con la mayoría de protocolos RPC que
tiene una documentación extensa y requiere considerable soporte de software para
su uso.

Fue creado por Dave Winer de la empresa UserLand Software en asociación con
Microsoft en el año 1998. Al considerar Microsoft que era muy simple decidió
añadirle funcionalidades, tras las cuales, después de varias etapas de
desarrollo, el estándar dejó de ser sencillo y se convirtió en lo que es
actualmente conocido como SOAP. Una diferencia fundamental es que en los
procedimientos en SOAP los parámetros tienen nombre y no interesan su orden, no
siendo así en XML-RPC.[2

************
El framework
************

    | **d** jango + **off** line = **doff**

Mientras que un cliente se encuentre sin conexion con el servidor web, es capaz
de generar y almacenar datos usando su base de datos local. Al reestablecer
la conexion con el servidor web, estos datos deben ser transimitos a la base de
datos central para su actulizacion y posterior sincronizacion del resto de los
clinetes.

Modelos
=======

Plantillas
==========

Formularios
===========

*************
La aplicación
*************

Un proyecto django consta de un conjunto de aplicaciones. Podemos hacer una distinción
entre los tipos de aplicaciones en función de su objetivo:

 * Las aplicaciones de usuario
 	Son aquellas aplicaciones que resuelven un problema específico. Suelen estar 
	dispuestas en un subdirectorio del proyecto.
 	
 * Las aplicaciones de soporte
 	Las aplicaciones de soporte son las aplicaciones que resuelven un problema general,
 	como autenticación, envío de correo, interacción con servicos provistos por sitios
 	de terceros (Google Maps, Google Charts, AdSense, Yahoo Maps, Yahoo Pipes, Feedburner, etc.),
 	etc. Django provee varias aplicaciones que están disponibles por defecto ante la 
 	creación de un proyecto con el comando *create-app*.
 	
 * Aplicaciones template
 	Esta caracterización se puede aplicar tanto a proyectos como a aplicaciones y consite
 	en una aplicación distribuida como plantilla para lograr una aplicación de usuario, pero
 	que tiene varios factores engorrosos resueltos. Podemos citar en este caso, a el proyecto
 	*Pinax* [*]_ que provee un conjunto de aplicaciones de soporte y aplicaciones de template.
 	
 .. [*] *Pinax Project* http://pinaxproject.com/
 
El enfoque inicial fue realizar un "espejo" de la aplicación que se ejecuta en el servidor 
sobre el cliente. Django está escrito en Python y si bien la ejecución de Python es posible
en un browser, la solución es engorrosa y no es cross-browser. En la plataforma Mozilla, la
integración se puede realizar mediante PyXPCOM [*]_ , PyShell[*]_ y también existe una 
extensión para XUL [*]_

.. [*] *PyXPCOM*, conexión del modelo de objetos multiplataforma de Mozilla con Python, https://developer.mozilla.org/en/PyXPCOM 
.. [*] *PyShell*, consola interactiva 
.. [*] *Luxor, Python for XUL* http://mail.python.org/pipermail/python-announce-list/2003-March/002084.html

Sobre la plataforma Windows, existen dos formas de ejecutar Python en el navegador, 
la primera consiste en la ejecución 
de un control ActiveX sobre el browser que cuente con el intérprete
de Python embebdio. Un control ActiveX es un componente ejecutable empotrable, 
que puede ser dibujado en una página web. 
Los controles ActiveX son peligrosos en el ámbito de la web debido 
a que fueron ideados para ser utilizados como elemento incrustable entre aplicaciones 
o para el uso en entornos confiables. Un control ActiveX cuenta 
con privilegios similares a los de una aplicacion tradicional sobre el equipo del clinete. 
La mayoría de los antivirus y herramientas
de seguridad los eliminan o hacen responsable de la seguridad al usuario a partir de 
la ejecución del ActiveX.
Si bien esta técncia se presenta atractiva gracias a que Python es un lenguaje que ha sido
diseñado para ser embebdio, los controles ActiveX no cumplen con las garantías de seguridad
necesarias para el desarrollo de aplicaciones para la web. 
Es posible considerar esta solución "cross-browser" gracias a proyectos como
un *host para ActiveX sobre la plataforma mozilla* [*]_ pero no es multiplatafoma. 

.. [*] *ActiveX para Mozilla* http://www.iol.ie/~locka/mozilla/plugin.htm

La segunda alternativa es utilizar el framework Silverlight de Microsoft, que 
permite generar aplicaciones para browsers badasdos en la plataforma :term:`.Net`.
Silverlight es un runtime similar al popular Adobe Flash Player, pero las 
aplicaciones pueden ser creadas en cualquier lenguaje de la plataforma .Net, 
incluyendo Python y Ruby [*]_ [*]_ a partir de la versión 4, auque en sus versiones
para .Net.

.. note:: 
	Preguntar en el IRC de *pyar* desde cuando tiene la API standard IronPython
	si no volar el párrafo
	
Esta tecnología exige que el navegador cuente con un plugin para la plataforma, siendo
el más completo el desarrollado por Microsoft, propulsor de la plataforma .Net.
IronPython es una implementación de Python sobre .Net que no cuenta con la API standard [*]_
de la versión CPython, por lo que no se puede ejecutar django de manera nativa. 
  

.. [*] *SilverLight, a new way for Python?* http://mail.python.org/pipermail/python-list/2007-May/610021.html
.. [*] *Sitio de Michael Frood, donde explica como ejecutar IronPython sobre .Net* http://www.voidspace.org.uk/ironpython/silverlight/index.shtml#id2
.. [*] *Listado de Módulos de la API standard* http://docs.python.org/modindex.html 

Aunque en un principio no era posible ejecutar Django sobre la IronPython, gracias
a la popularidad del framework, con la version 2.0 se superó esta dificultad [*]_.


.. [*] *Django On IronPython* http://www.infoq.com/news/2008/03/django-and-ironpython 

Generar este espejo conlleva poseer un equivalente al framework Django que 
pueda ser ejecutado en un browser, brindando los componentes básicos de Django:

 * Mapeador Objeto Relacional
 * Renderización de templates
 * Asociación de expresiones regulares a funciones.
 
Esta idea surge en parte gracias al proyecto "Gars On Rails" [*]_ , un equivalente al objetivo del proyecto
sobre el framework Rails. 

.. [*] *Gears On Rails* 

  	