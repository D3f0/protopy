##########
Desarrollo 
##########

El desarrollo consistió en el siguiente diagrama:

.. image:: ../_svg/esquema_general.png

.. _capitulos-protopy:

****************************
Una biblioteca en JavaScript
****************************

La idea de diseñar y desarrollar un framework en que funcione en el hambiente
de un navegador web, como es Firefox, deja entrever muchos aspectos que no
resultan para nada triviales al momento de codificar.

* Se requieren varias lineas de codigo para implementar un framework.
* Como llega el codigo al navegador y se inicia su ejecucion.
* La cara visible o vista debe ser fasilmente manipulable por la aplicacion de usuario.
* Como los datos generados en el cliente son informados al servidor.
* El framework debe brindar soporte a la aplicacion de usuario de una forma natural y transparente.
* Se debe promover al reuso y la extension de funcionalidad del framework.
* Como se ponen en marcha los mecanimos o acciones que la aplicacion de usuario define.

En este capitulo se introducen las ideas principales que motivaron la
creacion de una libreria en JavaScript, que brinde el soporte necesario al
framework y a buena parte de los items expuestos.

Si bien el desarrollo de la libreria se mantuvo en paralelo a la del
framework, existen aspectos basicos a los que esta brinda soporte y permiten
presentarla en un apartado separado como "Una Biblioteca en JavaScript", esta
constituye la base para posteriores construcciones y auna herramientas que
simplifican el desarrollo client-side.

*proto* type + *py* thon = **protopy**

"La creación nace del caos", la libreria "Protopy" no escapa a esta
afirmacion e inicialmente nace de la integracion de Prototype con
las primeras funciones para lograr la modularizacion; con el correr de las
lineas de codigo [*]_ el desarrollo del framework torna el enfoque inicial poco sustentable,
requiriendo este de funciones mas Python-compatibles se desecha la libreria
base y se continua con un enfoque más "pythonico", persiguiendo de esta forma
acercar la semántica de JavaScript 1.7 a la del lenguaje de programacion Python.

.. [*] Forma en que los informaticos miden el paso del tiempo.

No es arbitrario que el navegador sobre el cual corre Protopy sea Firefox y
mas particularmente sobre la version 1.7 de JavaScript. El proyecto mozilla
esta hacercando, con cada nueva versiones del lenguaje, la semantica de JavaScript a
la de Python, incluyendo en esta version generadores e iteradores los cuales
son muy bien explotados por Protopy y el framework.

Protopy
=======
Protopy es una libreria JavaScript para el desarrollo de aplicaciones
web dinamicas. Aporta un enfoque modular para la inclusión de código,
orientación a objetos, manejo de AJAX, DOM y eventos.

Para una referencia completa de la API de Protopy remitase al apandice
:ref:`Protopy <apendices-doff-dbapi>`

.. _protopy-modulos:

Organizando el codigo
=====================

Como ya se vio en la sección dedicada a :ref:`JavaScript <cliente-javascript>`,
una de las formas tradicionales y recomendada de incluir funcionalidad en un
documento HTML es mediante el tag `script`, haciendo una referencia en el
atributo `src` a la url del archivo que contiene el codigo; en una instancia 
posterior, cuando el cliente accede al recurso, carga el archivo con las
sentencias JavaScript y las interpreta en el contexto del documento.

El enfoque tradicional resulta sustentable para pequeños proyectos, donde el
lenguaje brinda mayormente soporte a la interacción con el usuario (validacion,
accesibilidad, etc) y los fragmentos de código que se pasan al cliente son
bien conocidos por el desarrollador, pero en proyectos que implican mayor cantidad
de funcionalidad JavaScript, con grandes cantidades de código, este enfoque
resulta complejo de mantener y evolucionar en el tiempo. Es por esto que para
Protopy se busco como primera medida una forma de organizar y obtener el código
del servidor que resulte sustentable y escalable.

Similar al concepto de :ref:`modulos en Python <servidor-lenguajes-python>`, el
desarrollo de Protopy se oriento en pequeñas unidades funcionales llamadas
**modulos**.

Además de la sanidad mental que implica organizar el código en distintos
archivos, los módulos representan un cambio muy importante en la obtención de
funcionalidad; ya no es el documento HTML el que dice al cliente que archivo
cargar del servidor, sino que el mismo código interpretado va obteniendo la
funcionalidad a medida que la requiere.

El enfoque modular no es nuevo en programación y basicamente, la implementación
de Protopy, implica llevar el concepto de "divide y vencerás" ó "análisis
descendente (Top-Down)" al hambito de JavaScript.

Un módulo resuelve un problema especifico y define una interfaz de comunicación
para accesar y utilizar la funcionalidad que contiene. Por más simple que
resulte de leer, esto implica que existe una manera de **obtener** un modulo y
una manera de **publicar** la funcionalidad de un modulo, logrando de esta forma
que interactuen entre ellos.

En su forma mas pedestre un módulo es un archivo que contiene definiciones y
sentencias de JavaScript. El nombre del archivo es el nombre del módulo con el
sufijo .js pegado y dentro de un módulo, el nombre del módulo está disponible
como el valor de la variable `__name__`.

Obtener un módulo
-----------------

La función `require` es la encargada de obtener un módulo del servidor e
incorporarlo al :ref:`espacio de nombres <servidor-lenguajes-python>` del
llamador, cuando un módulo llamado spam es requerido, Protopy busca un archivo
llamado spam.js en la url base [*]_, de no encontrar el archivo el error
``LoadError`` es lanzado a la función que requirio el módulo.

.. [*] Ruta base desde la cual la biblioteca Protopy carga los módulos, por
    defecto esta es la url base del archivo protopy.js más el sufijo `packages`.

Otra forma de obtener módulos es usando nombres de **paquetes**. A diferencia de
Python un paquete no incluye funcionalidad en si mismo y su funcionalidad
principal es la de establecer las bases en la cual buscar modulos.
De forma similar a la anterior cuando un módulo llamado foo.spam es importado,
Protopy busca en el objeto sys.paths si existe una url asociada al paquete foo,
de encontrar la url base para foo el archivo spam.js es buscado en esa
ubicación, por otra parte si sys.paths no contiene una url asociada a foo el
archivo foo/spam.js es buscado en la url base. 

El uso del objeto sys.paths permite a los modulos de JavaScript que saben lo
que están haciendo modificar o reemplazar el camino de búsqueda para los módulos.
Nótese que es importante que el script no tenga el mismo nombre que un
:ref:`módulo estandar <apendices-protopy-modulos>`.

Las formas en que el modulo obtenido es presentado al llamador difiere en
funcion de los parametros pasados a `require`:

    * Un modulo puede ser obtenido como un objeto

    * Se puede obtener solo determinada funcion de un modulo.

    * O se pueden importar todas las definiciones del módulo en el espacio de nombres del
    llamador

Para ver más :ref:`Apendice Protopy <apendices-protopy>`.

Publicar un módulo
------------------

La acción de publicar un modulo implica exponer la funcionalidad que este define.
En Python no es necesario explicitar que funcionalidad del módulo se expone a
los llamadores, ya que todo lo definido en él es público; pero los módulos en
Protopy se evaluan dentro de una clausura y los llamadores no podran acceder
a sus funciones si no son publicadas. 

La funcion `publish` es la encargada de relizar la tarea de publicar el
contenido del modulo en Protopy.

Un modulo puede contener sentencias ejecutables y definición de funciones,
generalmente las sentencias son para inicializar el módulo ya que estas se
evaluan solo la primera vez que el módulo es requerido a alguna parte y las
definiciones son las que efectivamente seran publicadas como funcionalidad.

A continuación se presenta un fragmento de código que ejemplifica el uso de las 
dos funciones presentadas.

.. code-block:: javascript

     //Obtengo la funcion copy y deepcopy del modulo copy
    require('copy', 'copy', 'deepcopy');

    var SortedDict = type('SortedDict', [ Dict ], {
        __init__: function(object) {
            this.keyOrder = (object && isinstance(object, SortedDict))? copy(object.keyOrder) : [];
            super(Dict, this).__init__(object);
        },
        __iter__: function() {
            for each (var key in this.keyOrder) {
                var value = this.get(key);
                var pair = [key, value];
                pair.key = key;
                pair.value = value;
                yield pair;
            }
        },
        __deepcopy__: function() {
            var obj = new SortedDict();
            for (var hash in this._key) {
                obj._key[hash] = deepcopy(this._key[hash]);
                obj._value[hash] = deepcopy(this._value[hash]);
            }
            obj.keyOrder = deepcopy(this.keyOrder); 
            return obj;
        },
        __str__: function() {
            var n = len(this.keyOrder);
            return "%s".times(n, ', ').subs(this.keyOrder);
        },
        set: function(key, value) {
            this.keyOrder.push(key);
            return super(Dict, this).set(key, value);
        },
        unset: function(key) {
            without(this.keyOrder, key);
            return super(Dict, this).unset(key);
        }
    });
    
    //Publico el tipo de objeto SortedDict
    publish({ 
        SortedDict: SortedDict 
    });

Asumiendo que el código presentado esta en un archivo llamado `sortedict.js` en
la url base, esté representa un módulo en si mismo y el acceso se obtiene
mediante la invocación de 'require('sortedict')'. El ejemplo presenta muchas
cosas nuevas, que seran abordadas a lo largo de este apartado, por ahora solo
interesa la parte que corresponde al requerimiento de `copy` y la
publicación de `SortedDict`.

La primera lineas del ejemplo incian requirendo la funcion copy y deepcopy del
módulo `copy`, ambas funciones se utilizan para realizar copias de objetos,
superficial y en profundidad respectivamente. El ejemplo continua con una
definición de un nuevo tipo de objeto llamado `SortedDict` que posteriormente
publica en la ultima linea de código.

.. note:: queda mas o menos claro?

.. _protopy-tipos:

Creando tipos de objeto
=======================

En el apartado teórico se menciono ya que en JavaScript todo es un objeto y que
estos se crean y modifican dinamicamente en tiempo de ejecución.

Sin embargo, la creacion de objetos en Javascript carece de "clases" o si se
quiere "tipos de objeto" y para crear dos o mas objetos de un mismo tipo se
deben volver a declarar todos los miembros del objeto.

La forma en que los lenguajes orientados a objetos comúnmente resuelven el
problema anterior es mediante el uso de Clases, en JavaScript no es posible
declarar Clases, pero si es posible instanciar objetos a partir de un
constructor.

El objeto Function es utilizado como objeto instanciable en JavaScript, y el
cuerpo de la función es el constructor del nuestros objetos. Una vez que tenemos
un constructor, podemos llamarlo con el operador new.

En la programación basada en prototipos las "clases" no están presentes, y la
re-utilización de procesos se obtiene a través de la clonación de objetos ya
existentes y la extención de funcionalidad.

Protopy agrega el concepto de clases al desarrollo, mediante un contructor de
"tipos de objeto". De esta forma los objetos pueden ser de dos tipos, las
clases y las instancias. Las clases definen la disposición y la funcionalidad
básicas de los objetos, y las instancias son objetos "utilizables" basados en
los patrones de una clase particular.

.. note:: hablar de las implementaciones de herencia y como es la nuestra

Creando ‘Clases’ en JavaScript

La forma en que los lenguajes orientados a objetos comúnmente resuelven el
problema anterior es mediante el uso de Clases, en JavaScript no es posible
declarar Clases, pero si es posible instanciar objetos a partir de un
constructor.

El objeto Function es utilizado como objeto instanciable en JavaScript, y el
cuerpo de la función es el constructor del nuestros objetos. Una vez que tenemos
un constructor, podemos llamarlo con el operador new.


/*clase de ejemplo*/

miClase = new Function();

nuevoObjeto = new miClase(); // instanciamos ‘miClase’

El método mas difundido para emular las clases en JavaScript es aprovechar el
funcionamiento de la palabra clave this dentro de los constructores. Cuándo una
función es llamada con el operador new, this hace referencia al objeto que será
retornado. Veamos como funciona.

/*clase de ejemplo*/

miClase = function(){

/*

agregamos miembros dinamicamente

al objeto que será retornado

*/

this.propiedad = “hola!”;

this.metodo = function(){

/* aqui ‘this’ hace referencia al objeto al que pertenece el metodo */

alert(this.propiedad);

}

}

nuevoObjeto = new miClase(); // instanciamos ‘miClase’

Ahora, ‘nuevoObjeto’ va a referenciar al objeto que se retornó cuando se llamó a
‘miClase’ usando el operador new, por lo tanto, va a tener todas las propiedades
y metodos que se crearon dentro del constructor.

El problema de esta forma de crear clases es que cada vez que la función
‘miClase’ es llamada, se crea una nueva función llamada ‘metodo’, de modo que
cada objeto tiene su propia versión de ‘metodo’ cuando, en realidad, todos los
objetos deberían compartir la misma función.

La propiedad ‘Prototype’

Todas las funciones tienen una propiedad llamada prototype, esta propiedad es un
objeto que será utilizado como ‘modelo’ inicial de todos los objetos que sean
creados con esta función cuando sea utilizada como constructor.

Inicialmente esta propiedad es un objeto vacío, pero debemos modificarla para
aprovechar esta característica del lenguaje. Reescribiendo el ejemplo anterior
el código quedaría así:

/* creamos un constructor limpio */

miClase = new Function();

miClase.prototype.propiedad = “hola!”;

miClase.prototype.metodo = function(){

/* aqui ‘this’ hace referencia al objeto al que pertenece el metodo */

alert(this.propiedad);

}

nuevoObjeto = new miClase(); // instanciamos ‘miClase’

Ahora todos los objetos creados a partir de ‘miClase’ compartirán inicialmente
las mismas referencias en todas sus propiedades, esto significa que, todos los
objetos van a compartir la misma versión de ‘metodo’.

Adicionalmente, al utilizar la propiedad prototype, obtenemos otra ventaja,
podemos usar la palabra reservada instanceof. Vemos como se usa si
escribimos:alert(nuevoObjeto instanceof miClase) // muestra ‘true’

El problema del uso de prototype, es que todas las propiedades hacen referencia
a las mismas del prototipo, por lo que si modificamos estos objetos se van a
modificar también en todos los objetos creados con esta clase. En siguiente
ejemplo cambiamos nuestra propiedad a un array para poder modificarla sin
cambiar nuestra referencia, de modo que podamos ver lo que explico con un
ejemplo:

/* creamos un constructor limpio */

miClase = new Function();

miClase.prototype.propiedad = new Array(“hola”,“hello”);

miClase.prototype.metodo = function(){

/* aqui ‘this’ hace referencia al objeto al que pertenece el metodo */

alert(this.propiedad);

}

nuevoObjeto = new miClase(); // instanciamos ‘miClase’

otroObjeto = new miClase(); // instanciamos ‘miClase’

nuevoObjeto.propiedad.push(“olá”);

otroObjeto.metodo(); // muestra “hola”,”hello”,”olá”

Como pueden ver en el ejemplo anterior, ‘nuevoObjeto’ y ‘otroObjeto’ hacen
referencia al mismo array, para solucionar este problema solo debemos asignar
un objeto diferente a cada propiedad de nuestros objetos. El constructor es un
buen lugar para realizar esta tarea:

miClase = function(){

this.propiedad = new Array(“hola”,“hello”); // reemplazamos el valor de nuestra propiedad con un nuevo objeto

};

miClase.prototype.propiedad = new Array(“hola”,“hello”);

miClase.prototype.metodo = function(){

/* aqui ‘this’ hace referencia al objeto al que pertenece el metodo */

alert(this.propiedad);

}

nuevoObjeto = new miClase(); // instanciamos ‘miClase’

otroObjeto = new miClase(); // instanciamos ‘miClase’

nuevoObjeto.propiedad.push(“olá”);

otroObjeto.metodo(); // muestra “hola”,”hello” :)

Listo, tenemos clase y tenemos objetos que funcionan bien. Espero que les haya
resultado claro, en el próximo post voy a explicar el mecanismo de la herencia
en JavaScript (si!!, se puede!!). Hasta entonces.

Descargar archivo de ejemplo

Y ya para finalizar este tema en el que se trata el lenguaje JS a modo de
introducción hablaremos de la herencia entre clases. En relación a este aspecto
he de decir que tras buscar por internet la posibilidad de Herencia, me he
encontrado con algunos ejemplos que principalmente no funcionan, como es el caso
del ejemplo de herencias que nos muestra "Douglas Crockford".

En este caso y tras probar las posibilidades de herencia me di cuenta de que o
no sabia exactamente como funcionaba o es que realmente no se soporta este tipo
de herencia, yo he llegado a la conclusión de que no lo soporta.

Posteriormente vi que la librería prototype ha desarrollado un metodo por el
cual se pueden realizar herencias entre clases. Pero aún así seguí buscando la
forma de tener una metodología propia para poder implementar las herencias en
nuestro propia librería de JS. Y así llegué a un post en el que se trataba el
tema en cuestión y en el cuál "Harry Fuecks" nos ha abierto la puerta a dotar a
nuestrar propias librerías de herencia entre clases. ¿Y como es esto?, pues es
tan sencillo como crearnos un objeto que lo que haga sea recorrer cada par
"nombre:variable" del objeto que pasamos como original y asignárselo a nuevos
pares "nombre:variable" del objeto al que deseamos copiar la herencia.

Bueno por si no me he explicado bien vamos a ver unos ejemplos para así ver su
funcionamiento.

...

Como ya se menciono anteriormente Protopy explota las novedades de JavaScript
1.7, para los iteradores el constructor de tipos prevee el metodo
__iter__ con la finalidad de que los objetos generados en base al tipo
sean iterables.

Los primeros tipos que surgen para la organizacion de datos dentro de la
librerias con los "Sets" y los "Diccionarios", hambos aproximan su
estructura a las estructuras homonimas en python, brindando una funcionalidad
similar. Si bien la estructura "hasheable" nativa a JavaScript en un objeto,
los diccionarios de Protopy permiten el uso de objetos como claves en lugar de
solo cadenas.

Extendiendo JavaScript
======================
Si bien el :term:`DOM` ofrece ya una :term:`API` muy completa para acceder,
añadir y cambiar dinámicamente el contenido del documento HTML, existen
funciones muy utiles y comunes en los desarrollos que los programadores
incorporan al HTML y se intentaron englobar y mantener dentro del nucleo de
Protopy, 


Extendiendo DOM
===============
Si bien el :term:`DOM` ofrece ya una :term:`API` muy completa para acceder,
añadir y cambiar dinámicamente el contenido del documento HTML, existen
funciones muy utiles y comunes para la manipulación del DOM, que los
programadores incorporan al proyecto en forma de bibliotecas propias o de
terceros, este tipo de funciones se integraron al nucleo de Protopy con el
objetivo de fasilitar el desarrollo.

Funciones para modificar e incorporar elementos al documento son muy comunes y
estan disponibles en Protopy, en conjunto con otras para el manejo de
formularios, como serializacion, obtencion de valores.

En cuanto a los eventos 


Envolviendo a gears
===================

La biblioteca puede funcionar independiente de la instalación de Google Gears,
debido a que su principal funcionalidad como ya se menciono es la de extención de
JavaScript y posterior soporte al framework, pese a esto Protopy provee
mecanismos para uniformar el acceso y extender los objetos de Gears cuando este
se encuentra instalado en el navegador.

Si bien no es necesario que los módulos obtengan el acceso a Gears a traves de
Protopy, es recomendable que asi se haga; ya que la biblioteca provee los
mecanimos de extención para los objetos Gears al momento de solicitarlos. Esto
no fue asi desde el comienzo de del desarrollo y fue una idea que se maduro
luego de observar que resultava complejo y costoso requerir los modulos que
involucraban a Gears desde distintos lugares.

El acceso al `Factory` de Gears esta centralizado y controlado en el objeto
`gears` dentro del modulo `sys`, mediante este objeto es posible conocer el
estado de Gears y sus permisos. El objeto informa al desarrollador si Gears esta
instalado y en que version, si los permisos estan correctos e incluso simplifica
el proceso de instalación de la extención de no estar presente en el navegador.

La función `create` del objeto `sys.gears` es la encargada de crear y retornar
los objetos Gears, la creación de estos objetos puede ser directemente
dependiente del objeto `Factory` original de Gears o estar asistida y extendida
por un modulo de Protopy que se encuentre en el paquete gears en la url base.

Se busco extender algunos objetos Gears para el desarrollo del framework con la
finalidad de interaccionar el backend de base datos con el acceso a la base
propieamente dicho. 

Auditando el codigo
===================
.. Logger


Interactuando con el servidor
=============================
.. HttpRequest


Soporte para json
=================
.. JSON REF http://www.json.org/
.. Esto es algo sobre json, quiza no valla aca
JSON brinda un buen soporte al intercambio de datos, resultando de fásil
lectura/escritura para las personas y de un rapido interpretacion/generacion
para las maquinas. Se basa en un subconjunto del lenguaje de programación
JavaScript, estándar ECMA-262 3ª Edición - Diciembre de 1999. Este formato de
texto es completamente independiente del lenguaje de programacion, pero utiliza
convenciones que son familiares para los programadores de lenguajes de la
familia ``C'', incluyendo C, C + +, C#, Java, JavaScript, Perl, Python y muchos otros.

JSON se basa en dos estructuras:
* Una colección de pares nombre / valor. En varios lenguajes esto se
  representa mediante un objeto, registro, estructura, diccionario, tabla hash,
  introducido lista o matriz asociativa.
* Una lista ordenada de valores. En la mayoría de los lenguajes esto se
  representa como un arreglo, matriz, vector, lista, o secuencia.

Estas son estructuras de datos universales. Prácticamente todos los lenguajes
de programación modernos las soportan de una forma u otra. Tiene sentido que un
formato de datos que es intercambiable con los lenguajes de programación
también se basan en estas estructuras.

Para mas informacion sobre JSON http://www.json.org/

.. Ahora vemos que hace protopy, la necesidad
Mientras que un cliente se encuentre sin conexion con el servidor web, es capaz
de generar y almacenar datos usando su base de datos local. Al reestablecer
la conexion con el servidor web, estos datos deben ser transimitos a la base de
datos central para su actulizacion y posterior sincronizacion del resto de los
clinetes.
La transferencia de datos involucra varios temas, uno de ellos y que compete
a este apartado, es el formato de los datos que se deben pasar por
la conexcion; este formato debe ser ``comprendido'' tanto por el cliente como
por el servidor. Desde un primer momento se penso en JSON como el formato
de datos a utilizar, es por esto que Protopy incluye un modulo para trabajar con el mismo.

.. Porque no xml?
No existe una razon concreta por la cual se deja de lado el soporte en Protopy
para XML como formato de datos; aunque se puede mencionar la simplicidad de
implementacion de un parser JSON contra la implementacion de uno en XML.
Para el leector interesado agregar el sporte para XML en Protopy consta de
escribir un modulo que realize esa tarea y agregarlo al paquete base.

.. El como
El soporte para JSON se encuentra en el modulo ``json" entre los modulos
estandar de Protopy. Este brinda soporte al pasaje de estructuras de datos
JavaScript a JSON y viceversa.
Los tipos base del lenguje JavaScript estan soportados y tienen su
reprecentacion correspondiente, object, array, number, string, etc. pero este
modulo interpreta ademas de una forma particular a aquellos objetos que
implementen el metodo __json__, dejando de este modo en manos del
desarrollador la reprecentacion en JSON de determinado objetos.
La inclusion del metodo __json__  resulta de especial impotancia a la
hora de pasar a JSON los objetos creados en base a tipos definidos por el
desarrollador mediante el contructor ``type''.

Con el soporte de datos ya establecidos en la libreria, el framework solo
debe limitarce a hacer uso de él y asegurar la correcta sincronizacion de datos
entre el cliente y el servidor web, este tema se retomara en el capitulo de
sincronizacion.
.. TODO: retomar este tema para no ser un mentiroso :)


Ejecutando codigo remoto
========================
.. JSON-RPC http://json-rpc.org/ 
.. XML-RPC http://www.xmlrpc.com/
El RPC (del inglés Remote Procedure Call, Llamada a Procedimiento Remoto) es un
protocolo que permite a un programa de ordenador ejecutar código en otra máquina
remota sin tener que preocuparse por las comunicaciones entre ambos. El protocolo
es un gran avance sobre los sockets usados hasta el momento. De esta manera el
programador no tenía que estar pendiente de las comunicaciones, estando éstas
encapsuladas dentro de las RPC.

Las RPC son muy utilizadas dentro del paradigma cliente-servidor. Siendo el
cliente el que inicia el proceso solicitando al servidor que ejecute cierto
procedimiento o función y enviando éste de vuelta el resultado de dicha operación
al cliente.

Hay distintos tipos de RPC, muchos de ellos estandarizados como pueden ser el RPC
de Sun denominado ONC RPC (RFC 1057), el RPC de OSF denominado DCE/RPC y el
Modelo de Objetos de Componentes Distribuidos de Microsoft DCOM, aunque ninguno
de estos es compatible entre sí. La mayoría de ellos utilizan un lenguaje de
descripción de interfaz (IDL) que define los métodos exportados por el servidor.

Hoy en día se está utilizando el XML como lenguaje para definir el IDL y el HTTP
como protocolo de red, dando lugar a lo que se conoce como servicios web.
Ejemplos de éstos pueden ser SOAP o XML-RPC. XML-RPC es un protocolo de llamada a
procedimiento remoto que usa XML para codificar los datos y HTTP como protocolo
de transmisión de mensajes.[1]

Es un protocolo muy simple ya que sólo define unos cuantos tipos de datos y
comandos útiles, además de una descripción completa de corta extensión. La
simplicidad del XML-RPC está en contraste con la mayoría de protocolos RPC que
tiene una documentación extensa y requiere considerable soporte de software para
su uso.

Fue creado por Dave Winer de la empresa UserLand Software en asociación con
Microsoft en el año 1998. Al considerar Microsoft que era muy simple decidió
añadirle funcionalidades, tras las cuales, después de varias etapas de
desarrollo, el estándar dejó de ser sencillo y se convirtió en lo que es
actualmente conocido como SOAP. Una diferencia fundamental es que en los
procedimientos en SOAP los parámetros tienen nombre y no interesan su orden, no
siendo así en XML-RPC.[2
