##########
Desarrollo 
##########

El desarrollo consistió en el siguiente diagrama:

.. image:: ../_svg/esquema_general.png

.. _capitulos-protopy:

****************************
Una biblioteca en JavaScript
****************************

La idea de diseñar y desarrollar un framework en que funcione en el hambiente
de un navegador web, como es Firefox, deja entrever muchos aspectos que no
resultan para nada triviales al momento de codificar.

* Se requieren varias lineas de codigo para implementar un framework.
* Como llega el codigo al navegador y se inicia su ejecucion.
* La cara visible o vista debe ser fasilmente manipulable por la aplicacion de usuario.
* Como los datos generados en el cliente son informados al servidor.
* El framework debe brindar soporte a la aplicacion de usuario de una forma natural y transparente.
* Se debe promover al reuso y la extension de funcionalidad del framework.
* Como se ponen en marcha los mecanimos o acciones que la aplicacion de usuario define.

En este capitulo se introducen las ideas principales que motivaron la
creacion de una libreria en JavaScript, que brinde el soporte necesario al
framework y a buena parte de los items expuestos.

Si bien el desarrollo de la libreria se mantuvo en paralelo a la del
framework, existen aspectos basicos a los que esta brinda soporte y permiten
presentarla en un apartado separado como una ''Libreria JavaScript'', esta
constituye la base para posteriores construcciones y auna herramientas que
simplifican el desarrollo client-side.

*proto* type + *py* thon = **protopy**

"La creación nace del caos", la libreria "Protopy" no escapa a esta
afirmacion e inicialmente nace de la integracion de Prototype con
las primeras funciones para lograr la modularizacion; con el correr de las
lineas de codigo [*]_ el desarrollo del framework torna el enfoque inicial poco sustentable,
requiriendo este de funciones mas Python-compatibles se desecha la libreria
base y se continua con un enfoque más "pythonico", persiguiendo de esta forma
acercar la semántica de JavaScript 1.7 a la del lenguaje de programacion Python.

.. [*] Forma en que los informaticos miden el paso del tiempo.

No es arbitrario que el navegador sobre el cual corre Protopy sea Firefox y
mas particularmente sobre la version 1.7 de JavaScript. El proyecto mozilla
esta hacercando, con cada nueva versiones del lenguaje, la semantica de JavaScript a
la de Python, incluyendo en esta version generadores e iteradores los cuales
son muy bien explotados por Protopy y el framework.

Protopy
=======
Protopy es una libreria JavaScript para el desarrollo de aplicaciones
web dinamicas. Aporta un enfoque modular para la inclusión de código,
orientación a objetos, manejo de AJAX, DOM y eventos.

Para una referencia completa de la API de Protopy remitase al apandice
:ref:`Protopy <apendices-doff-dbapi>`

Organizando el codigo
=====================

Como ya se vio en la sección dedicada a :ref:`JavaScript <cliente-javascript>`,
una de las formas tradicionales y recomendada de incluir funcionalidad en un
documento HTML es mediante el tag ``script``, haciendo una referencia en el
atributo ``src`` a la url del archivo que contiene el codigo; en una instancia 
posterior, cuando el cliente accede al recurso, carga el archivo con las
sentencias JavaScript y las interpreta en el contexto del documento.

El enfoque tradicional resulta sustentable para pequeños proyectos donde el lenguaje
brinda mayormente soporte a la interacción con el usuario (validacion,
accesibilidad, etc) y los fragmentos de código que se pasan al cliente son
bien conocidos por el desarrollador; en proyectos que implican mayor cantidad
de funcionalidad JavaScript, con grandes cantidades de código, este enfoque
resulta complejo de mantener y evolucionar en el tiempo. Es por esto que para
Protopy se busco como primera medida una forma de organizar y obtener el codigo
del servidor que resulte sustentable y escalable.

Similar al concepto de :ref:`modulos en Python <servidor-lenguajes-python>`, el
desarrollo de Protopy se oriento en pequeñas unidades funcionales llamadas
**modulos**. A demas de la sanidad mental que implica organizar el código en
distintos archivos, los módulos representan un cambio muy importante en la obtención
de funcionalidad, donde ya no es el documento HTML el que dice al cliente que
archivo cargar del servidor, sino que el mismo codigo interpretado va obteniendo
la funcionalidad a medida que la requiere.

El enfoque modular no es nuevo en programación y basicamente, la implementación
de Protopy, implica llevar el concepto de "divide y vencerás" ó "análisis
descendente (Top-Down)" al hambito de JavaScript.

Un módulo resuelve un problema especifico y define una interfaz de comunicación
para accesar y utilizar la funcionalidad que contiene. Por más simple que
resulte de leer, esto implica que existe una manera de **obtener** un modulo y
una manera de **publicar** la funcionalidad de un modulo, logrando de esta forma
que interactuen entre ellos para resolver una determinada tarea.

En su forma mas pedestre un módulo es un archivo que contiene definiciones y
sentencias de JavaScript. El nombre del archivo es el nombre del módulo con el
sufijo .js pegado y dentro de un módulo, el nombre del módulo está disponible
como el valor de la variable `__name__`.

Obtener un módulo
-----------------

La función `require` es la encargada de obtener un módulo del servidor e
incorporarlo al :ref:`espacio de nombres <servidor-lenguajes-python>` del
llamador, cuando un módulo llamado spam es requerido, Protopy busca un archivo
llamado spam.js en la url base [*]_, de no encontrar el archivo el error
``LoadError`` es lanzado a la funcion que requirio el modulo.

.. [*] Ruta base desde la cual la biblioteca Protopy fue obtenida del servidor.

Otra forma de obtener modulos es usando nombres de **paquetes**. A diferencia de
Python un paquete no incluye funcionalidad en si mismo y su funcionalidad
principal es la de establecer las bases en la cual buscar modulos.
De forma similar a la anterior cuando un módulo llamado foo.spam es importado,
Protopy busca en el objeto sys.paths si existe una url asociada al paquete foo,
de encontrar la url base para foo el archivo spam.js es buscado en esa
ubicación, por otra parte si sys.paths no contiene una url asociada a foo el
archivo foo/spam.js es buscado en la url base. 

El uso del objeto sys.paths permite a los modulos de JavaScript que saben lo
que están haciendo al modificar o reemplazar el camino de búsqueda de módulos.
Nótese que es importante que el script no tenga el mismo nombre que un
:ref:`módulo estandar <apendices-protopy-modulos>`.

Las formas en que el modulo obtenido es presentado al llamador difiere en
funcion de los parametros pasados a `require`, por ahora solo alcanza con mencionar que
un modulo puede ser obtenido en su totalidad, se puede obtener solo determinada
funcion de un modulo o tambien cargar todas las definiciones del modulo en el
espacio de nombres del llamador, para ver más :ref:`Apendice Protopy <apendices-protopy>`.

Publicar un módulo
------------------

La acción de publicar un modulo implica exponer la funcionalidad que este define.
En Python no es necesario explicitar que funcionalidad del módulo se expone a
los llamadores, ya que todo lo definido en él es público; pero los modulos en
Protopy se evaluan dentro de una clausura y los llamadores no podran acceder
a las definiciones dentro de ellas si no son publicadas. Para publicar las
sentencias ejecutables y definición de funciones Protopy provee la función
`publish`. La intención de las sentencias es inicializar el módulo y son
ejecutadas sólo la primera vez que el módulo es requerido a alguna parte.

Creando tipos de objeto
=======================

.. Semántica de objetos, dentro de la cual se hace una adaptación de
En la programación basada en prototipos las ``clases'' no están presentes, y la
re-utilización de procesos se obtiene a través de la clonación de objetos ya
existentes.
Protopy agrega el concepto de clases al desarrollo, mediante un contructor de
``tipos de objeto''. De esta forma los objetos pueden ser de dos tipos, las
clases y las instancias. Las clases definen la disposición y la funcionalidad
básicas de los objetos, y las instancias son objetos ``utilizables'' basados en
los patrones de una clase particular.
...

Como ya se menciono anteriormente Protopy explota las novedades de JavaScript
1.7, para los iteradores el constructor de tipos prevee el metodo
__iter__ con la finalidad de que los objetos generados en base al tipo
sean iterables.

Los primeros tipos que surgen para la organizacion de datos dentro de la
librerias con los ``Sets'' y los ``Diccionarios'', hambos aproximan su
estructura a las estructuras homonimas en python, brindando una funcionalidad
similar. Si bien la estructura ``hasheable'' nativa a JavaScript en un objeto,
los diccionarios de Protopy permiten el uso de objetos como claves en lugar de
solo cadenas.


Extendiendo el DOM
==================
Si bien el :term:`DOM` ofrece ya una :term:`API` muy completa para acceder,
añadir y cambiar dinámicamente el contenido estructurado en el documento HTML.


Manejando los eventos
=====================
.. event.connect
.. event.


Envolviendo a gears
===================
.. Almacenamiento en la base de datos local
.. LocalServer para guradar codigo


Auditando el codigo
===================
.. Logger


Interactuando con el servidor
=============================
.. HttpRequest


Soporte para json
=================
.. JSON REF http://www.json.org/
.. Esto es algo sobre json, quiza no valla aca
JSON brinda un buen soporte al intercambio de datos, resultando de fásil
lectura/escritura para las personas y de un rapido interpretacion/generacion
para las maquinas. Se basa en un subconjunto del lenguaje de programación
JavaScript, estándar ECMA-262 3ª Edición - Diciembre de 1999. Este formato de
texto es completamente independiente del lenguaje de programacion, pero utiliza
convenciones que son familiares para los programadores de lenguajes de la
familia ``C'', incluyendo C, C + +, C#, Java, JavaScript, Perl, Python y muchos otros.

JSON se basa en dos estructuras:
* Una colección de pares nombre / valor. En varios lenguajes esto se
  representa mediante un objeto, registro, estructura, diccionario, tabla hash,
  introducido lista o matriz asociativa.
* Una lista ordenada de valores. En la mayoría de los lenguajes esto se
  representa como un arreglo, matriz, vector, lista, o secuencia.

Estas son estructuras de datos universales. Prácticamente todos los lenguajes
de programación modernos las soportan de una forma u otra. Tiene sentido que un
formato de datos que es intercambiable con los lenguajes de programación
también se basan en estas estructuras.

Para mas informacion sobre JSON http://www.json.org/

.. Ahora vemos que hace protopy, la necesidad
Mientras que un cliente se encuentre sin conexion con el servidor web, es capaz
de generar y almacenar datos usando su base de datos local. Al reestablecer
la conexion con el servidor web, estos datos deben ser transimitos a la base de
datos central para su actulizacion y posterior sincronizacion del resto de los
clinetes.
La transferencia de datos involucra varios temas, uno de ellos y que compete
a este apartado, es el formato de los datos que se deben pasar por
la conexcion; este formato debe ser ``comprendido'' tanto por el cliente como
por el servidor. Desde un primer momento se penso en JSON como el formato
de datos a utilizar, es por esto que Protopy incluye un modulo para trabajar con el mismo.

.. Porque no xml?
No existe una razon concreta por la cual se deja de lado el soporte en Protopy
para XML como formato de datos; aunque se puede mencionar la simplicidad de
implementacion de un parser JSON contra la implementacion de uno en XML.
Para el leector interesado agregar el sporte para XML en Protopy consta de
escribir un modulo que realize esa tarea y agregarlo al paquete base.

.. El como
El soporte para JSON se encuentra en el modulo ``json" entre los modulos
estandar de Protopy. Este brinda soporte al pasaje de estructuras de datos
JavaScript a JSON y viceversa.
Los tipos base del lenguje JavaScript estan soportados y tienen su
reprecentacion correspondiente, object, array, number, string, etc. pero este
modulo interpreta ademas de una forma particular a aquellos objetos que
implementen el metodo __json__, dejando de este modo en manos del
desarrollador la reprecentacion en JSON de determinado objetos.
La inclusion del metodo __json__  resulta de especial impotancia a la
hora de pasar a JSON los objetos creados en base a tipos definidos por el
desarrollador mediante el contructor ``type''.

Con el soporte de datos ya establecidos en la libreria, el framework solo
debe limitarce a hacer uso de él y asegurar la correcta sincronizacion de datos
entre el cliente y el servidor web, este tema se retomara en el capitulo de
sincronizacion.
.. TODO: retomar este tema para no ser un mentiroso :)


Ejecutando codigo remoto
========================
.. JSON-RPC http://json-rpc.org/ 
.. XML-RPC http://www.xmlrpc.com/
El RPC (del inglés Remote Procedure Call, Llamada a Procedimiento Remoto) es un
protocolo que permite a un programa de ordenador ejecutar código en otra máquina
remota sin tener que preocuparse por las comunicaciones entre ambos. El protocolo
es un gran avance sobre los sockets usados hasta el momento. De esta manera el
programador no tenía que estar pendiente de las comunicaciones, estando éstas
encapsuladas dentro de las RPC.

Las RPC son muy utilizadas dentro del paradigma cliente-servidor. Siendo el
cliente el que inicia el proceso solicitando al servidor que ejecute cierto
procedimiento o función y enviando éste de vuelta el resultado de dicha operación
al cliente.

Hay distintos tipos de RPC, muchos de ellos estandarizados como pueden ser el RPC
de Sun denominado ONC RPC (RFC 1057), el RPC de OSF denominado DCE/RPC y el
Modelo de Objetos de Componentes Distribuidos de Microsoft DCOM, aunque ninguno
de estos es compatible entre sí. La mayoría de ellos utilizan un lenguaje de
descripción de interfaz (IDL) que define los métodos exportados por el servidor.

Hoy en día se está utilizando el XML como lenguaje para definir el IDL y el HTTP
como protocolo de red, dando lugar a lo que se conoce como servicios web.
Ejemplos de éstos pueden ser SOAP o XML-RPC. XML-RPC es un protocolo de llamada a
procedimiento remoto que usa XML para codificar los datos y HTTP como protocolo
de transmisión de mensajes.[1]

Es un protocolo muy simple ya que sólo define unos cuantos tipos de datos y
comandos útiles, además de una descripción completa de corta extensión. La
simplicidad del XML-RPC está en contraste con la mayoría de protocolos RPC que
tiene una documentación extensa y requiere considerable soporte de software para
su uso.

Fue creado por Dave Winer de la empresa UserLand Software en asociación con
Microsoft en el año 1998. Al considerar Microsoft que era muy simple decidió
añadirle funcionalidades, tras las cuales, después de varias etapas de
desarrollo, el estándar dejó de ser sencillo y se convirtió en lo que es
actualmente conocido como SOAP. Una diferencia fundamental es que en los
procedimientos en SOAP los parámetros tienen nombre y no interesan su orden, no
siendo así en XML-RPC.[2
