##########
Desarrollo 
##########

El desarrollo consistió en el siguiente diagrama:

.. image:: ../_svg/esquema_general.png

.. _capitulos-protopy:

*************
La biblioteca
*************

La idea de diseñar y desarrollar un framework en que funcione en el hambiente
de un navegador web, como es Firefox, deja entrever muchos aspectos que no
resultan para nada triviales al momento de codificar.

* Se requieren varias lineas de codigo para implementar un framework.
* Como llega el codigo al navegador y se inicia su ejecucion.
* La cara visible o vista debe ser fasilmente manipulable por la aplicacion de
usuario.
* Como los datos generados en el cliente son informados al servidor.
* El framework debe brindar soporte a la aplicacion de usuario de una forma
natural y transparente.
* Se debe promover al reuso y la extension de funcionalidad del framework.
* Como se ponen en marcha los mecanimos o acciones que la aplicacion de usuario
define.

En este capitulo se introducen las ideas principales que motivaron la
creacion de una biblioteca en JavaScript, que brinde el soporte necesario al
framework y a buena parte de los items expuestos.

Si bien el desarrollo de la biblioteca se mantuvo en paralelo a la del
framework, existen aspectos basicos a los que esta brinda soporte y permiten
presentarla en un apartado separado como "Una Biblioteca en JavaScript", esta
constituye la base para posteriores construcciones y auna herramientas que
simplifican el desarrollo client-side.

    | **proto** type + **py** thon = **protopy**

"La creación nace del caos", la libreria "Protopy" no escapa a esta
afirmacion e inicialmente nace de la integracion de Prototype con
las primeras funciones para lograr la modularizacion; con el correr de las
lineas de codigo [*]_ el desarrollo del framework torna el enfoque inicial poco
sustentable, requiriendo este de funciones más Python-compatibles se desecha la
libreria base y se continua con un enfoque "pythonico", persiguiendo de esta
forma acercar la semántica de JavaScript 1.7 a la del lenguaje de programacion
Python.

.. [*] Forma en que los informaticos miden el paso del tiempo.

No es arbitrario que el navegador sobre el cual corre Protopy sea Firefox y
mas particularmente sobre la version 1.7 de JavaScript. El proyecto mozilla
esta hacercando, con cada nueva versiones del lenguaje, la semantica de
JavaScript a la de Python, incluyendo en esta version generadores e iteradores
los cuales son muy bien explotados por Protopy y el framework.

Protopy
=======
Protopy es una biblioteca JavaScript para el desarrollo de aplicaciones
web dinamicas. Aporta un enfoque modular para la inclusión de código,
orientación a objetos, manejo de AJAX, DOM y eventos.

Para una referencia completa de la API de Protopy remitase al apandice
:ref:`Protopy <apendices-doff-dbapi>`

.. _protopy-modulos:

Organizando el codigo
=====================

Como ya se vio en la sección dedicada a :ref:`JavaScript <cliente-javascript>`,
una de las formas tradicionales y recomendada de incluir funcionalidad en un
documento HTML es mediante el tag `script`, haciendo una referencia en el
atributo `src` a la url del archivo que contiene el codigo; en una instancia 
posterior, cuando el cliente accede al recurso, carga el archivo con las
sentencias JavaScript y las interpreta en el contexto del documento.

El enfoque tradicional resulta sustentable para pequeños proyectos, donde el
lenguaje brinda mayormente soporte a la interacción con el usuario (validacion,
accesibilidad, etc) y los fragmentos de código que se pasan al cliente son
bien conocidos por el desarrollador, pero en proyectos que implican mayor
cantidad
de funcionalidad JavaScript, con grandes cantidades de código, este enfoque
resulta complejo de mantener y evolucionar en el tiempo. Es por esto que para
Protopy se busco como primera medida una forma de organizar y obtener el código
del servidor que resulte sustentable y escalable.

Similar al concepto de :ref:`modulos en Python <servidor-lenguajes-python>`, el
desarrollo de Protopy se oriento en pequeñas unidades funcionales llamadas
**modulos**.

Además de la sanidad mental que implica organizar el código en distintos
archivos, los módulos representan un cambio muy importante en la obtención de
funcionalidad; ya no es el documento HTML el que dice al cliente que archivo
cargar del servidor, sino que el mismo código interpretado va obteniendo la
funcionalidad a medida que la requiere.

El enfoque modular no es nuevo en programación y basicamente, la implementación
de Protopy, implica llevar el concepto de "divide y vencerás" ó "análisis
descendente (Top-Down)" al hambito de JavaScript.

Un módulo resuelve un problema especifico y define una interfaz de comunicación
para accesar y utilizar la funcionalidad que contiene. Por más simple que
resulte de leer, esto implica que existe una manera de **obtener** un modulo y
una manera de **publicar** la funcionalidad de un modulo, logrando de esta forma
que interactuen entre ellos.

En su forma mas pedestre un módulo es un archivo que contiene definiciones y
sentencias de JavaScript. El nombre del archivo es el nombre del módulo con el
sufijo .js pegado y dentro de un módulo, el nombre del módulo está disponible
como el valor de la variable `__name__`.

Obtener un módulo
-----------------

La función `require` es la encargada de obtener un módulo del servidor e
incorporarlo al :ref:`espacio de nombres <servidor-lenguajes-python>` del
llamador. Por ejemplo, cuando un módulo llamado spam es requerido, Protopy busca
un archivo
llamado spam.js en la url base [*]_, de no encontrar el archivo el error
``LoadError`` es lanzado a la función que requirio el módulo.

.. [*] Ruta base desde la cual la biblioteca Protopy carga los módulos, por
    defecto esta es la url base del archivo protopy.js más el sufijo `packages`.

Otra forma de obtener módulos es usando nombres de **paquetes**. A diferencia de
Python un paquete no incluye funcionalidad en si mismo y su funcionalidad
principal es la de establecer las bases en la cual buscar modulos.
De forma similar a la anterior cuando un módulo llamado foo.spam es importado,
Protopy busca en el objeto sys.paths si existe una url asociada al paquete foo,
de encontrar la url base para foo el archivo spam.js es buscado en esa
ubicación, por otra parte si sys.paths no contiene una url asociada a foo el
archivo foo/spam.js es buscado en la url base. 

El uso del objeto sys.paths permite a los modulos de JavaScript que saben lo
que están haciendo modificar o reemplazar el camino de búsqueda para los
módulos.
Nótese que es importante que el script no tenga el mismo nombre que un
:ref:`módulo estandar <apendices-protopy-modulos>`.

Las formas en que el modulo obtenido es presentado al llamador difiere en
funcion de los parametros pasados a `require`. Estas formas son:

    * Un modulo puede ser obtenido como un objeto,

    * Se puede obtener solo determinada funcion de un modulo,

    * O se pueden importar todas las definiciones del módulo en el espacio de
    nombres del llamador.

Para ver más :ref:`Apendice Protopy <apendices-protopy>`.

Publicar un módulo
------------------

La acción de publicar un modulo implica exponer la funcionalidad que este
define.
En Python no es necesario explicitar que funcionalidad del módulo se expone a
los llamadores, ya que todo lo definido en él es público; pero los módulos en
Protopy se evaluan dentro de una clausura y los llamadores no podran acceder
a sus funciones si no son publicadas. 

La funcion `publish` es la encargada de relizar la tarea de publicar el
contenido del modulo en Protopy.

Un modulo puede contener sentencias ejecutables y definición de funciones,
generalmente las sentencias son para inicializar el módulo ya que estas se
evaluan solo la primera vez que el módulo es requerido a alguna parte y las
definiciones son las que efectivamente seran publicadas como funcionalidad.

A continuación se presenta un fragmento de código que ejemplifica el uso de las 
dos funciones presentadas.

.. code-block:: javascript Figura algo
    :linenos:

     /* Obtengo la funcion copy y deepcopy del modulo copy
        estas funciones son para copia de objetos
        superficiales y en profundidad respectivamente. */
    require('copy', 'copy', 'deepcopy');

    /* Representa la cantidad maxima de caches */
    var MAX = 1000;

    /* Objeto para guardar las cache */
    var cache = {};

    ...

    /* Estructura de datos que representa a una cache */
    var Cache = type('Cache', [ Dict ], {
        ...
    });

    /* Funcion que retorna una cache */
    function get_cache(name) {
        if (len(cache) > 1000)
            throw new Exception('%s caches creadas'.subs(MAX));
        var c = cache[name];
        if (!isundefined(c)) {
            c = new Cache();
            cache[name] = c;
        }
        return d;
    }

    /* Publico la cantidad maxima de caches
       la funcion para obtener caches. */
    publish({
        MAX: MAX,
        get_cache: get_cache
    });

Asumiendo que el código presentado está en un archivo llamado `caches.js` en
la url base, éste representa un módulo en sí mismo y el acceso se obtiene
mediante la invocación de 'require('caches')'.

.. note:: describir de forma rápida los módulos principales

.. _protopy-tipos:

Creando tipos de objeto
=======================

.. note:: Hacer la referencia al codigo anterior

En el apartado teórico se toco el tema de construcción de objetos en base a
"clases" y de la emulacion de herencia en JavaScript. Aunque muchos autores
cuestionan estas practicas alegando, con justa razon, que no tiene sentido
emular un paradigma dentro de otro; en la practica tener una implementación de
objetos tipados mediante clases en JavaScript ayuda a los programadores a
acercarse a este lenguaje y al reuso de código.

La función contrcuctora de tipos en la biblioteca surgue como herramienta para
proveer al framework de mecanismos de extensión.

.. code-block:: javascript Figura algo
    :linenos:

    var Dict = type('Dict', object, {
        ...
    });

    var SortedDict = type('SortedDict', [ Dict ], {
        __init__: function(object) {
            this.keyOrder = (object && isinstance(object, SortedDict))?
copy(object.keyOrder) : [];
            super(Dict, this).__init__(object);
        },
        __iter__: function() {
            for each (var key in this.keyOrder) {
                var value = this.get(key);
                var pair = [key, value];
                pair.key = key;
                pair.value = value;
                yield pair;
            }
        },
        __deepcopy__: function() {
            var obj = new SortedDict();
            for (var hash in this._key) {
                obj._key[hash] = deepcopy(this._key[hash]);
                obj._value[hash] = deepcopy(this._value[hash]);
            }
            obj.keyOrder = deepcopy(this.keyOrder); 
            return obj;
        },
        __str__: function() {
            var n = len(this.keyOrder);
            return "%s".times(n, ', ').subs(this.keyOrder);
        },
        set: function(key, value) {
            this.keyOrder.push(key);
            return super(Dict, this).set(key, value);
        },
        unset: function(key) {
            without(this.keyOrder, key);
            return super(Dict, this).unset(key);
        }
    });

Protopy define un constructor de "tipos de objetos" llamado `type`. Notese que
aquí nos referimos a tipos y no a clases.

Al igual que muchas partes de Protopy `type` cambio a lo largo del desarrollo,
sumando soporte para herencia multiple, metodos magicos e incluso "metatipos".

En el ejemplo presentado se utiliza la funcion type para definir el tipo
SortedDict, el cual es una especializacion del tipo base Dict. En la definicion
se detalla bastante bien el comprotambiento de esta type; como primer argumento
recibe el nombre para el nuevo tipo, seguidamente un arreglo con los tipo base y
para terminar un objeto con los atributos y metodos.

Metodo importentes:

    * __init__

        Este es el metodo que se invoca inmediatamente después de contruir un
        nuevo objeto de este tipo. Sería tentador decir que es el “constructor”
        de la clase. Si bien se parece un constructor de Java, actúa como si lo
        fuese ya que el objeto ya esta instanciado cuando se llama a esta
        función.

    * __str__

        Este metodo se llama cuando es necesario proveer de una reprecentacion
        en texto del objeto, JavaScript provee para este objetivo el metodo
        toString, pero por cuestiones de nombres se prefirio usar este metodo en
        su lugar y hacer internamente una relacion entre las funciones.

    * __iter__

        Protopy se vale de versiones modernas de JavaScript y brinda soporte a
        iteradores, este es el método que el desarrollador debe definir si
        quiere objetos iterable, la funcion debe retornar un objeto que
        implemente el metodo next (un iterador o un generado), los bucles
        for hacen esto automáticamente, pero también se puede hacer manualmente.

Otros metodos:

    * __deepcopy__
    * __copy__
    * __json__
    * __html__

Para instanciar un nuevo tipo se utiliza el operador new de JavaScript, este
operador crea el nuevo objeto e invoca a la funcion __init__.

Los primeros tipos que surgen para la organizacion de datos dentro de la
librerias con los "Sets" y los "Diccionarios", hambos aproximan su
estructura a las estructuras homonimas en python, brindando una funcionalidad
similar. Si bien la estructura "hasheable" nativa a JavaScript en un objeto,
los diccionarios de Protopy permiten el uso de objetos como claves en lugar de
solo cadenas.

Extendiendo DOM y JavaScript
============================

Si bien el :term:`DOM` ofrece ya una :term:`API` muy completa para acceder,
añadir y cambiar dinámicamente el contenido del documento HTML, existen
funciones muy utiles y comunes en los desarrollos que los programadores
incorporan al HTML y se intentaron englobar y mantener dentro del nucleo de
Protopy. Funciones para modificar e incorporar elementos al documento son muy
comunes y estan disponibles en Protopy, en conjunto con otras para el manejo de
formularios, como serializacion, obtencion de valores, etc.

Otra extension interesante de mencionar es la de los tipos de datos en
JavaScript, en manejo de cadenas incorpora nuevas funciones que simplifican
tareas comunes, los numeros y fechas tambien tiene su aporte.

Los eventos estan uniforamdos bajo un modulo de manejo de eventos, que permite
conectar eventos del :term:DOM con funciones en JavaScript, así tambien como
funciones entre si.

.. note:: Poner los nombres de las funciones para destacar el laburo

Envolviendo a gears
===================

La biblioteca puede funcionar independiente de la instalación de Google Gears,
debido a que su principal funcionalidad como ya se menciono es la de extención
de
JavaScript y posterior soporte al framework, pese a esto Protopy provee
mecanismos para uniformar el acceso y extender los objetos de Gears cuando éste
se encuentra instalado en el navegador.

El acceso al `Factory` de Gears esta centralizado y controlado en el objeto
`gears` dentro del modulo `sys`, mediante este objeto es posible conocer el
estado de Gears y sus permisos. El objeto informa al desarrollador si Gears esta
instalado, la versión, si los permisos son corrector e incluso simplifica
el proceso de instalación de la extensión de no estar presente en el navegador
entre otras cosas.

El metodo `create` del objeto `sys.gears` es el encargado de crear y retornar
los objetos Gears. Esta función se ayuda de módulos presentes en el paquete
`gears` para asistir la creación de los objetos. El objeto que se retorne
dependera de la precencia del módulo con el mismo nombre en dicho paquete; de no
encontrar un modulo que asista la cración de un objeto Gears el objeto en sus
estado "puro" es retornado al llamador.

Si bien no es necesario que los módulos obtengan el acceso a Gears a traves de
Protopy, es recomendable que asi se haga; ya que la biblioteca provee los
mecanimos de extención para los objetos en `create`. Esto no fue así desde el
comienzo de del desarrollo y fue una idea que se maduro luego de observar que
resultaba complejo y costoso requerir los módulos que involucraban a Gears
desde distintos lugares.

El desarrollo del framework implico extender algunos objetos Gears,
concretamente
al paquete `gears` se incorporaron los siguientes módulos:

    * desktop

        El objeto `desktop` de Gears permite interactuar con el escritorio del
cliente. 
        Aquí se extendio la creacción de accesos directos para simplificar la
generación
        de los mismos y agregar la posibilidad de manejar `Icon` y algunos
`IconTheme`.

    * database

        Sobre el objeto `database` se agrego funcionalidad uniformar el acceso a
la base
        de datos por los módulos de Protopy y encapsular los `ResulSet` en
cursores a
        los que se incorporo iteradores, registro de funciones para tipos de
datos, etc.

Auditando el codigo
===================

Una queja recurrente de los desarrolladores que trabajan con JavaScript es lo
complejo que resulta el lenguaje para depurar errores. Encontrar errores en
el código resulta molesto y mas todavía si la salida de los mismos no esta en un
formato adecuado y encausada en un lugar especifico.

Tradicionalmente lo que se hace para detectar errores es valerse de funciones
`alert` diseminadas por el código con textos del estilo "Paso por aquí", pero
luego de cerrar unas diez o quince ventanas de este estilo, generalmente se
pierde referencia de donde esta ocurriendo el error y se cae en la tentación de
comenzar a comentar alerts a mansalva esperando dar con el indicado. Este es un
claro ejemplo de que tanto la salida como el sistema de detección de errores es
molesto e infructifero.

Una clara ventaja sobre el sistema tradicional y poderosa herramienta de
desarrollo es el plug-in Firebug, que integra entre otras cosas una consola
JavaScript y un debuger al ambinete del navegador, permitiendo a los
desarrolladores depurar el código mediante puntos de corte, inspección de
variables, etc. En firebug la consola pasa a ser por defecto la principal salida
de errores, gracias a la funcion `console.log` los desarrolladores pueden
redirigir todos los "Paso por aquí" a una salida uniforme e incluso inspeccionar
el valor de las variables.

Protopy lleva la depuración y auditoria del código un paso más lejos, integrando
un sistema de logging propio altamente configurable y con posibilidades de
escribir en diferentes salidas y con diferentes formatos.

Similar a log4j el logger de Protopy trabaja con niveles de prioridad para los
mensajes, distintos manejadores o `Handlers` y salidas en varios formatos. Todo
esto configurable por el desarrollador.

Una vez configurado el sistema de logging, los módulos que requieran auditar el
codigo solo deben requerir un logger en su sespacio de nombre e invocar a sus
funciones.

.. code-block:: javascript

    var logging = require('logging.base');
    var logger = logging.get_logger(__name__);

    ...

    logger.debug('La query: %s\n Los parametros: %s', query, params, {});

En este ejemplo se requiere el módulo `logging` y posteriormente un logger para
el módulo con el nombre __name__, de no encontrar configuración para este módulo
se adopta la configuracion del modulo inmediato superior y asi consecutivamente
hasta tomar la configuración del root logger.

Suponiendo que el módulo del ejemplo se llama doff.db.models.sql el siguiente
archivo de configuracion perapraria este logger en modo DEBUG para auditar el
código en la consola de firebug y en una url con distintos formatos.

.. code-block:: javascript

    {
        'loggers': {
            'root': {
                'level': 'DEBUG',
                'handlers': 'firebug'
            },
            'doff.db.models.sql': {
                'level': 'DEBUG',
                'handlers': [ 'firebug', 'remote'],
                'propagate': true
            },
        },
        'handlers': {
            'firebug': {
                'class': 'FirebugHandler',
                'level': 'DEBUG',
                'formatter': '%(time)s %(name)s(%(levelname)s):\n%(message)s',
                'args': []
            },
            'remote': {
                'class': 'RemoteHandler',
                'level': 'DEBUG',
                'formatter': '%(levelname)s:\n%(message)s',
                'args': ['/loggers/audit']
            },
            'alert': {
                'class': 'AlertHandler',
                'level': 'DEBUG',
                'formatter': '%(levelname)s:\n%(message)s',
                'args': []
            }
        }
    }

.. note:: Poner referencia a firebug

Interactuando con el servidor
=============================

Protopy permite al desarrollador trabajar con AJAX de forma simple y segura,
encapuslando en objetos la lógica de petición y los valores de retorno del
servidor.

Todo lo relacionado con AJAX se encuentra en el modulo `ajax`. El objeto de
transporte para ajax es `XMLHttpRequest` e internamente se salvan las
diferencias que existen entre los distintos navegadores. La forma de realizar
una peticion es creando una instancia del objeto ajax.Request.

.. code-block:: javascript

    new ajax.Request('una/url', {method: 'get'});

La primera opcion es la url de la solicitud, y el segundo parametro es el hash
de opciones, en este caso el metodo a utilizar es GET, si no se especifica, el
metodo por defecto es POST.

Por defecto la respuesta del servidor es asincrona, para este caso se debe
explicitar en el hash de opciones las funciones que manejaran los eventos
disparados.   

.. code-block:: javascript

    new ajax.Request('una/url', { 
        method:'get',
        onSuccess: function(transport){ 
            var response = transport.responseText || "sin texto";
            alert("Success! \n\n" + response); }, 
        onFailure: function(){ 
            alert('Algo esta mal...'); } 
    }); 

En el ejemplo se presentan dos funciones, onSuccess y onFailure, para manejar
los eventos correspondientes. A cada manejador se le pasa un objeto que
representa la respuesta obtenida y que esta en relación con el evento
capturando.

Otros manejadores que se pueden definir son:
    
    * onUninitialized
    * onLoading
    * onLoaded
    * onInteractive
    * onComplete
    * onException 

Todos estos dependen de un estado del objeto `XMLHttpRequest`.

De igual manera que el resto de las opciones es posible agregar parametros a la
peticion, estos pueden ser pasados como un objeto "hasheable" o como una cadena
clave-valor.

Soporte para json
=================

La idea detras del soporte para JSON en Protopy es la transimisión de datos
generados offline por el cliente, en el momento de recuperar la conexion con el
servidor el cliente debe serializar los datos y enviarlos al servidor; otro uso
para es el intercambio de mensajes de control.

La transferencia de datos involucra varios temas, uno de ellos y que compete
a este apartado, es el formato de los datos que se deben pasar por
la conexcion; este formato debe ser "comprendido" tanto por el cliente como
por el servidor. Desde un primer momento se penso en JSON como el formato
de datos a utilizar, es por esto que Protopy incluye un modulo para trabajar
con el mismo.

El soporte para JSON se encuentra en el modulo "json" entre los módulos
estandar de Protopy. Este brinda soporte al pasaje de estructuras de datos
JavaScript a JSON y viceversa.

Los tipos base del lenguje JavaScript estan soportados y tienen su
reprecentacion correspondiente, object, array, number, string, etc. pero este
modulo interpreta ademas de una forma particular a aquellos objetos que
implementen el metodo __json__, dejando de este modo en manos del
desarrollador la reprecentacion en JSON de determinado objetos.

Con el soporte de datos ya establecidos en la libreria, el framework solo
debe limitarse a hacer uso de él y asegurar la correcta sincronizacion de datos
entre el cliente y el servidor web, este tema se retomara en el capitulo de
sincronizacion.

XML
---

No existe una razon concreta por la cual se deja de lado el soporte en Protopy
para XML como formato de datos; aunque se puede mencionar la simplicidad de
implementacion de un parser JSON contra la implementacion de uno en XML.
Para el leector interesado agregar el sporte para XML en Protopy consta de
escribir un modulo que realize esa tarea y agregarlo al paquete base.

Ejecutando codigo remoto
========================
.. JSON-RPC http://json-rpc.org/ 
.. XML-RPC http://www.xmlrpc.com/
El RPC (del inglés Remote Procedure Call, Llamada a Procedimiento Remoto) es un
protocolo que permite a un programa de ordenador ejecutar código en otra máquina
remota sin tener que preocuparse por las comunicaciones entre ambos. El
protocolo
es un gran avance sobre los sockets usados hasta el momento. De esta manera el
programador no tenía que estar pendiente de las comunicaciones, estando éstas
encapsuladas dentro de las RPC.

Las RPC son muy utilizadas dentro del paradigma cliente-servidor. Siendo el
cliente el que inicia el proceso solicitando al servidor que ejecute cierto
procedimiento o función y enviando éste de vuelta el resultado de dicha
operación
al cliente.

Hay distintos tipos de RPC, muchos de ellos estandarizados como pueden ser el
RPC
de Sun denominado ONC RPC (RFC 1057), el RPC de OSF denominado DCE/RPC y el
Modelo de Objetos de Componentes Distribuidos de Microsoft DCOM, aunque ninguno
de estos es compatible entre sí. La mayoría de ellos utilizan un lenguaje de
descripción de interfaz (IDL) que define los métodos exportados por el servidor.

Hoy en día se está utilizando el XML como lenguaje para definir el IDL y el HTTP
como protocolo de red, dando lugar a lo que se conoce como servicios web.
Ejemplos de éstos pueden ser SOAP o XML-RPC. XML-RPC es un protocolo de llamada
a
procedimiento remoto que usa XML para codificar los datos y HTTP como protocolo
de transmisión de mensajes.[1]

Es un protocolo muy simple ya que sólo define unos cuantos tipos de datos y
comandos útiles, además de una descripción completa de corta extensión. La
simplicidad del XML-RPC está en contraste con la mayoría de protocolos RPC que
tiene una documentación extensa y requiere considerable soporte de software para
su uso.

Fue creado por Dave Winer de la empresa UserLand Software en asociación con
Microsoft en el año 1998. Al considerar Microsoft que era muy simple decidió
añadirle funcionalidades, tras las cuales, después de varias etapas de
desarrollo, el estándar dejó de ser sencillo y se convirtió en lo que es
actualmente conocido como SOAP. Una diferencia fundamental es que en los
procedimientos en SOAP los parámetros tienen nombre y no interesan su orden, no
siendo así en XML-RPC.[2

************
El framework
************

    | **d** jango + **off** line = **doff**

Mientras que un cliente se encuentre sin conexion con el servidor web, es capaz
de generar y almacenar datos usando su base de datos local. Al reestablecer
la conexion con el servidor web, estos datos deben ser transimitos a la base de
datos central para su actulizacion y posterior sincronizacion del resto de los
clinetes.

El framework fue construido con el objeto de ser compatible con los modelos y
las plantillas de django, intentando acercar así al desarrollador que tenga
experiencia en este framework.

Modelos
=======

La forma de interactuar con la base de datos es a traves de los modelos, siendo 
consistente con Django, Doff abstrae la logica de negocios dentro de los modelos.

Continuando con la linea de ejemplos se presenta a continuación una
configuración de datos básica sobre libro/autor/editor, esta estructura debe
estar contenida en un archivo models.js dentro de una aplicacion:

    var models = require('doff.db.models.base');

    var Publisher = type('Publisher', [ models.Model ], {
        name: new models.CharField({ maxlength: 30 }),
        address: new models.CharField({ maxlength: 50 }),
        city: new models.CharField({ maxlength: 60 }),
        state_province: new models.CharField({ maxlength: 30 }),
        country: new models.CharField({ maxlength: 50 }),
        website: new models.URLField()
    });

    var Author = type('Author', [ models.Model ], {
        salutation: new models.CharField({ maxlength: 10 }),
        first_name: new models.CharField({ maxlength: 30 }),
        last_name: new models.CharField({ maxlength: 40 }),
        email: new models.EmailField(),
        headshot: new models.ImageField({ upload_to: '/tmp' })
    });

    var Book = type('Book', [ models.Model ], {
        title: new models.CharField({ maxlength: 100 }),
        authors: new models.ManyToManyField(Author),
        publisher: new models.ForeignKey(Publisher),
        publication_date: new models.DateField()
    });

Cada modelo es representado por un tipo de Protopy que es un subtipo de
``doff.db.models.model.Model``. El tipo ``Model`` contiene toda la maquinaria
necesaria para hacer que los nuevos tipos sean capaces de interactuar con la
base de datos.

Cada modelo se corresponde con una tabla única de la base de datos, y cada
atributo de un modelo con una columna en esa tabla. El nombre de atributo
corresponde al nombre de columna, y el tipo de campo corresponde al tipo de
columna de la base de datos. Por ejemplo, el modelo ``Publisher`` es equivalente
a la siguiente tabla:

    CREATE TABLE "books_publisher" (
        "id" serial NOT NULL PRIMARY KEY,
        "name" varchar(30) NOT NULL,
        "address" varchar(50) NOT NULL,
        "city" varchar(60) NOT NULL,
        "state_province" varchar(30) NOT NULL,
        "country" varchar(50) NOT NULL,
        "website" varchar(200) NOT NULL
    );

La excepción a la regla una-clase-por-tabla es el caso de las relaciones
muchos-a-muchos. En el ejemplo, ``Book`` tiene un ``ManyToManyField`` llamado
``authors``. Esto significa que un libro tiene uno o más autores, pero la tabla
de la base de datos ``Book``  no tiene una columna ``authors``. En su lugar, se
crea una tabla adicional que maneja la correlación entre libros y autores.

Para una lista completa de tipos de campo y opciones de sintaxis de modelos,
ver el Apéndice B.

Finalmente, no se define explícitamente una clave primaria en ninguno de estos
modelos. A no ser que se le indique lo contrario, Doff dará automáticamente a
cada modelo un campo de clave primaria entera llamado ``id``.

Para activar los modelos en el proyecto, la aplicación que los contine debe
estar incluida en la lista de aplicaciones instaladas de Doff. Esto es, edita
el archivo ``settings.js``, y examina la variable de configuración ``INSTALLED_APPS``

Posteriormente, cuando el usuario instala la aplicación en su navegador, el
sistema recorre las aplicaciones en ``INSTALLED_APPS`` y genera el SQL para
cada modelo, creando las tablas en la base de datos. 

Doff provee entre las herramientas del desarrollador, un interprete de SQL sobre
la base de datos del cliente para conslutas.

Acceso básico a datos
---------------------

Una vez que se creo el modelo, Doff provee automáticamente una API JavaScript
de alto nivel para trabajar con estos modelos:

    >>> require('books.models', 'Publisher');
    >>> p1 = new Publisher({ name: 'Addison-Wesley', address: '75 Arlington Street',
    ...     city: 'Boston', state_province: 'MA', country: 'U.S.A.',
    ...     website: 'http://www.apress.com/'});
    >>> p1.save();
    >>> publisher_list = Publisher.objects.all();
    >>> print(array(publisher_list));
    [<Publisher: Publisher object>]

Se puede hacer mucho con la API de base de datos de Doff y para mejorar la
interactividad se recomienda implementar __str__ de Protopy. Con este
método los objetos tendran su representación en "string", es imporante que eso
sea así ya que el framework utiliza esta representacion en muchos lugares, como
templates y salidas por consola.

Insertando y actualizando datos
-------------------------------

En el ejemplo presentado anteriormente se ve cómo se hace para insertar una fila
en la base de datos, primero se crea una instancia del modelo pasando argumentos
nombrados y luego se llama al método ``save()`` del objeto:

En el caso de ``Publisher`` se usa una clave primaria autoincremental ``id``,
por lo tanto la llamada inicial a ``save()`` hace una cosa más: calcula el valor
de la clave primaria para el registro y lo establece como el valor del atributo
``id``  de la instancia.

Las subsecuentes llamadas a ``save()`` guardarán el registro en su lugar, sin
crear un nuevo registro (es decir, ejecutarán una sentencia SQL ``UPDATE`` en
lugar de un ``INSERT``).

Seleccionar objetos
-------------------

La forma de seleccionar y tamizar los datos se consige a traves de los
administradores de consultas, en el ejmplo la linea ``Publisher.objects.all()``
pide al administrador objects de Publisher que obtenga todos los registros,
internamente esto genera una consulta SQL::

    SELECT
        id, name, address, city, state_province, country, website
    FROM book_publisher;

Todos los modelos automáticamente obtienen un administrador ``objects`` que debe
ser usado cada vez que se quiera consultar sobre una instancia del modelo. El
metodo ``all()`` es un método del administrador ``objects`` que retorna todas
las filas de la base de datos. Aunque este objeto se *parece* a una lista, es
actualmente un *QuerySet* -- un objeto que representa algún conjunto de filas de
la base de datos. El Apéndice C describe QuerySets en detalle.

Cualquier búsqueda en base de datos va a seguir esta pauta general.

Filtrar datos
-------------

Aunque obtener todos los objetos es algo que ciertamente tiene su utilidad, la
mayoría de las veces lo que vamos a necesitar es manejarnos sólo con un
subconjunto de los datos. Para ello usaremos el método ``filter()``::

    >>> Publisher.objects.filter(name="Apress Publishing")
    [<Publisher: Apress Publishing>]

``filter()`` toma argumentos de palabra clave que son traducidos en las
cláusulas SQL ``WHERE`` apropiadas. El ejemplo anterior sería traducido en algo
como::

    SELECT
        id, name, address, city, state_province, country, website
    FROM book_publisher
    WHERE name = 'Apress Publishing';

Puedes pasarle a ``filter()`` múltiples argumentos para reducir las cosas aún
más::

    >>> Publisher.objects.filter(country="U.S.A.", state_province="CA")
    [<Publisher: Apress Publishing>]

Esos múltiples argumentos son traducidos a cláusulas SQL ``AND``. Por lo tanto
el ejemplo en el fragmento de código se traduce a lo siguiente::

    SELECT
        id, name, address, city, state_province, country, website
    FROM book_publisher
    WHERE country = 'U.S.A.' AND state_province = 'CA';

Notar que por omisión la búsqueda usa el operador SQL ``=`` para realizar
búsquedas exactas. Existen también otros tipos de búsquedas::

    >>> Publisher.objects.filter(name__contains="press")
    [<Publisher: Apress Publishing>]

Notar el doble guión bajo entre ``name`` y ``contains``. Del mismo modo que
Python, Django usa el doble guión bajo para indicar que algo "mágico" está
sucediendo -- aquí la parte ``__contains`` es traducida por Django en una
sentencia SQL ``LIKE``::

    SELECT
        id, name, address, city, state_province, country, website
    FROM book_publisher
    WHERE name LIKE '%press%';

Hay disponibles varios otos tipos de búsqueda, incluyendo ``icontains`` (``LIKE`` no
sensible a diferencias de mayúsculas/minúsculas), ``startswith`` y ``endswith``,
y ``range`` (consultas SQL ``BETWEEN``). El Apéndice C describe en detalle todos
esos tipos de búsqueda.

Obteniendo objetos individuales
-------------------------------

En ocasiones desearás obtener un único objeto. Para esto existe el método
``get()``::

    >>> Publisher.objects.get(name="Apress Publishing")
    <Publisher: Apress Publishing>

En lugar de una lista (o más bien, un QuerySet), este método retorna un objeto
individual. Debido a eso, una consulta cuyo resultado sean múltiples objetos
causará una excepción::

    >>> Publisher.objects.get(country="U.S.A.")
    Traceback (most recent call last):
        ...
    AssertionError: get() returned more than one Publisher -- it returned 2!

Una consulta que no retorne objeto alguno también causará una excepción::

    >>> Publisher.objects.get(name="Penguin")
    Traceback (most recent call last):
        ...
    DoesNotExist: Publisher matching query does not exist.

Ordenando datos
---------------

A medida que juegas con los ejemplos anteriores, podrías descubrir que los
objetos so devueltos en lo que parece ser un orden aleatorio. No estás
imaginándote cosas, hasta ahora no le hemos indicado a la base de datos cómo
ordenar sus resultados, de manera que simplemente estamos recibiendo datos con
algún orden arbitrario seleccionado por la base de datos.

Eso es, obviamente, un poco ***silly*** (tonto), no querríamos que una página Web que
muestra una lista de editores estuviera ordenada aleatoriamente. Así que, en la
práctica, probablemente querremos usar ``order_by()`` para reordenar nuestros
datos en listas más útiles::

    >>> Publisher.objects.order_by("name")
    [<Publisher: Apress Publishing>, <Publisher: Addison-Wesley>, <Publisher: O'Reilly>]

Esto no se ve muy diferente del ejemplo de ``all()`` anterior, pero el SQL
incluye ahora un ordenamiento específico::

    SELECT
        id, name, address, city, state_province, country, website
    FROM book_publisher
    ORDER BY name;

Podemos ordenar por cualquier campo que deseemos::

    >>> Publisher.objects.order_by("address")
    [<Publisher: O'Reilly>, <Publisher: Apress Publishing>, <Publisher: Addison-Wesley>]

    >>> Publisher.objects.order_by("state_province")
    [<Publisher: Apress Publishing>, <Publisher: Addison-Wesley>, <Publisher: O'Reilly>]

y por múltiples campos::

    >>> Publisher.objects.order_by("state_provice", "address")
     [<Publisher: Apress Publishing>, <Publisher: O'Reilly>, <Publisher: Addison-Wesley>]

También podemos especificar un ordenamiento inverso antecediendo al nombre del
campo un prefijo ``-`` (el símbolo menos)::

    >>> Publisher.objects.order_by("-name")
    [<Publisher: O'Reilly>, <Publisher: Apress Publishing>, <Publisher: Addison-Wesley>]

Aunque esta flexibilidad es útil, usar ``order_by()`` todo el tiempo puede ser
demasiado repetitivo. La mayor parte del tiempo tendrás un campo particular por
el que usualmente desearás ordenar. Es esos casos Django te permite anexar al
modelo un ordenamiento por omisión para el mismo:

.. literal-evaluado::

    class Publisher(models.Model):
        name = models.CharField(maxlength=30)
        address = models.CharField(maxlength=50)
        city = models.CharField(maxlength=60)
        state_province = models.CharField(maxlength=30)
        country = models.CharField(maxlength=50)
        website = models.URLField()

        def __str__(self):
            return self.name

        **class Meta:**
            **ordering = ["name"]**

Este fragmento ``ordering = ["name"]`` le indica a Django que a menos que se
proporcione un ordenamiento mediante ``order_by()``, todos los editores deberán
ser ordenados por su nombre.

.. exhortacion:: ¿Qué es este asunto de Meta?

    Django usa esta ``class Meta`` interna como un lugar en el cual se pueden
    especificar metadatos  adicionales acerca de un modelo. Es completamente
    opcional, pero puede realizar algunas cosas muy útiles. Examina el Apéndice
    B para conocer las opciones que puede poner bajo ``Meta``.

Encadenando búsquedas
---------------------

Has visto cómo puedes filtrar datos y has visto cómo ordenarlos. En ocasiones,
por supuesto, vas a desear realizar ambas cosas. En esos casos simplemente
"encadenas" las búsquedas entre sí::

    >>> Publisher.objects.filter(country="U.S.A.").order_by("-name")
    [<Publisher: O'Reilly>, <Publisher: Apress Publishing>, <Publisher: Addison-Wesley>]

Como podrías esperar, esto se traduce a una consulta SQL conteniendo tanto un
``WHERE`` como un ``ORDER BY``::

    SELECT
        id, name, address, city, state_province, country, website
    FROM book_publisher
    WHERE country = 'U.S.A'
    ORDER BY name DESC;

Puedes encadenar consultas en forma consecutiva tantas veces como desees. No
existe un límite para esto.

Rebanando datos
---------------

Otra necesidad común es buscar sólo un número fijo de filas. Imagina que tienes
miles de editores en tu base de datos, pero quieres mostrar sólo el primero.
Puedes hacer eso usando la sintaxis estándar de Python para el rebanado de
listas::

    >>> Publisher.objects.all()[0]
    <Publisher: Addison-Wesley>

Esto se traduce, someramente, a::

    SELECT
        id, name, address, city, state_province, country, website
    FROM book_publisher
    ORDER BY name
    LIMIT 1;

.. exhortacion::  Y más...

    Hemos sólo arañado la superficie del manejo de modelos, pero deberías ya
    conocer lo suficiente para entender todos los ejemplos del resto del libro.
    Cuando estés listo para aprender los detalles completos detrás de las
    búsquedas de objetos, échale una mirada al Apéndice C.

Eliminando objetos
------------------

Para eliminar objetos, simplemente se debe llamar al método ``delete()`` del objeto:

    >>> p = Publisher.objects.get({ name: "Addison-Wesley" });
    >>> p.delete();
    >>> array(Publisher.objects.all());
    []

Se pueden borrar objetos al por mayor llamando a ``delete()`` en el resultado de
una búsqueda::

    >>> publishers = Publisher.objects.all();
    >>> publishers.delete();
    >>> array(Publisher.objects.all());
    []

.. note:: 

    Mixin en RemoteSite, los modelos se registran en RemoteSite o se pueden hacer a mano.
    Hacer la referencia correspondiente al anexo de modelos

Plantillas
==========

Doff brinda soporte al sistema de plantillas de Django. La idea detras de esto
es que las plantillas creadas para una apilcacion on-line en Django pueda ser
utilizada en la aplicación off-line de una forma simple y mantenible.

Retomando el ejemplo presentado en la seccion de plantillas en Django,
continuamos desde aquí describiendo como es el trabajo con esta plantilla en
Doff.

Rapidamente, la forma de obtener un producto de la plantilla es:

    # Crea un objeto ``Template`` brindando el código crudo de la plantilla
       como una cadena.

    # Llama al método ``render()`` del objeto ``Template`` con un conjunto de
       variables (o sea, el contexto). Este retorna una plantilla totalmente
       renderizada como una cadena de caracteres, con todas las variables y
       etiquetas de bloques evaluadas de acuerdo al contexto.

Creación de objetos Template
----------------------------

Doff provee su versión del objeto ``Template`` para crear plantillas, y esté
puede ser importado del módulo ``doff.template.base``, el argumento para la
construccion del objeto es el texto en crudo de la plantilla. 

    >>> require('doff.template.base', 'Template');
    >>> t = new Template("Mi nombre es {{ name }}.");
    >>> print(t);

En este ejemplo `t` es un objeto template listo para ser renderizado. Si se
obtubo el objeto es porque la plantilla esta correctamente analizada y no se
econtraron errores en la misma, algunos errores por los que puede fallar la
construccion son:

    * Bloques de etiquetas inválidos
    * Argumentos inválidos de una etiqueta válida
    * Filtros inválidos
    * Argumentos inválidos para filtros válidos
    * Sintaxis de plantilla inválida
    * Etiquetas de bloque sin cerrar (para etiquetas de bloque que requieran la
      etiqueta de cierre)

En todos los casos el sistema lanza una excepción ``TemplateSyntaxError``.

Renderizar una plantilla
------------------------

Una vez que se tiene el objeto ``Template``, se esta en condiciones de obtener
una salida procesada en un determinado *contexto*. Un contexto es simplemente un
conjunto de variables y sus valores asociados. Una plantilla usa las variables
para poblar la plantilla evaluando las etiquetas de bloque.

El contexto esta representado en el tipo ``Context``, el cual se encuentra en el
módulo ``doff.template.base``. La construccion del objeto toma un argumento
opcional: un hash mapeando nombres de variables con valores. La llamada al
método ``render()`` del objeto ``Template`` con el contexto "rellena" la
plantilla::

    >>> requiere('doff.template.base', 'Context', 'Template');
    >>> t = new Template("Mi nombre es {{ name }}.")
    >>> c = new Context({"name": "Pedro"})
    >>> t.render(c)
    'My name is Pedro.'

El objeto ``Template`` puede ser renderizado con múltiples contextos, obteniendo
así salidas diferentes para la misma plantilla. Por cuestiones de eficiencia es
conveniente crear un objeto ``Template`` y luego llamar a ``render()``
sobre este muchas veces::

    # Mal chico
    for each (var name in ['John', 'Julie', 'Pat']) {
        var t = new Template('Hello, {{ name }}');
        print(t.render(new Context({'name': name})));
    }

    # Buen chico
    t = new Template('Hello, {{ name }}');
    for each (var name in ['John', 'Julie', 'Pat'])
        print(t.render(new Context({'name': name})));

Al igual que en Django el objeto contexto puede contener variables mas complejas
y la forma de inspeccionar dentro de estas es con el operador `.`. Usando el
punto se puede acceder a objetos, atributos, índices, o métodos de un objeto.

Cuando un sistema de plantillas encuentra un punto en una variable el orden de
busqueda es el siguiente:

    * Diccionario (por ej. ``foo["bar"]``)
    * Atributo (por ej. ``foo.bar``)
    * Llamada de método (por ej. ``foo.bar()``)
    * Índice de lista (por ej. ``foo[bar]``)

El sistema utiliza el primer tipo de búsqueda que funcione. Es la lógica de
cortocircuito.

Para terminar con este objeto, si una variable no existe en el contexto, el
sistema de plantillas renderiza este como un string vacío, fallando
silenciosamente. Es posible cambiar este comportamiento modificando el valor de
la variable de configuración `TEMPLATE_STRING_IF_INVALID` en el módulo
`settings`.

Cargador de plantillas
----------------------

Se ve a continuación un ejemplo de una vista que retorna HTML generado por una
plantilla::

    require('doff.template.base', 'Template', 'Context');
    require('doff.utils.http', 'HttpResponse');
    require('doff.template.loader', 'get_template');

    function current_datetime(request) {
        var t = get_template('mytemplate.html');
        html = t.render(new Context({'current_date': new Date()}))
        return new HttpResponse(html);
    }

En esta vista se utiliza la API para cargar plantillas, a la cual se accede 
mediante la funcion `get_template`, antes de poder utilizar esta funcion es
necesario indicarle al framework donde están las plantillas. El lugar para hacer
esto es en el *archivo de configuración*.

Existen varios cargadores de plantillas que se pueden habilitar en el archivo de 
configuración, este se vera en profundidad en el Apéndice E, por ahora se vera
el cargador realacionado con la variable de configuración ``TEMPLATE_URL``. Esta
variable le indica al mecanismo de carga de plantillas dónde buscar las
plantillas. Por omisión, ésta es una cadena vacia. El valor para esta varible es
la url del servidor en donde se sirven los templates que se renderizan
localmente, por defecto si no se especifica la variable los archivos se buscan
en la base del soporte off-line /templates/.

.. note:: 

    Terminar esto. con el tema de la base del soporte off-line
    Introducir el concepto al inicio de doff
    Hacer la referencia correspondiente al anexo de plantillas

Formularios
===========

*************
La aplicación
*************

.. note::
	Esto tendría que ir en el apartado de Django

entre los tipos de aplicaciones en función de su objetivo:

 * Las aplicaciones de usuario
 	Son aquellas aplicaciones que resuelven un problema específico. Suelen
estar 
	dispuestas en un subdirectorio del proyecto.
 	
 * Las aplicaciones de soporte
 	Las aplicaciones de soporte son las aplicaciones que resuelven un problema
general,
 	como autenticación, envío de correo, interacción con servicos provistos por
sitios
 	de terceros (Google Maps, Google Charts, AdSense, Yahoo Maps, Yahoo Pipes,
Feedburner, etc.),
 	etc. Django provee varias aplicaciones que están disponibles por defecto
ante la 
 	creación de un proyecto con el comando *create-app*.
 	
 * Aplicaciones template
 	Esta caracterización se puede aplicar tanto a proyectos como a aplicaciones
y consite
 	en una aplicación distribuida como plantilla para lograr una aplicación de
usuario, pero
 	que tiene varios factores engorrosos resueltos. Podemos citar en este caso,
a el proyecto
 	*Pinax* [*]_ que provee un conjunto de aplicaciones de soporte y
aplicaciones de template.
 	
 .. [*] *Pinax Project* http://pinaxproject.com/
 
en un browser, la solución es engorrosa y no es cross-browser. En la plataforma
Mozilla, la
integración se puede realizar mediante PyXPCOM [*]_ , PyShell[*]_ y también
existe una 

Python, https://developer.mozilla.org/en/PyXPCOM 
http://mail.python.org/pipermail/python-announce-list/2003-March/002084.html

navegador, 
aplicaciones 
del clinete. 
partir de 
diseñado para ser embebdio, los controles ActiveX no cumplen con las garantías
de seguridad
multiplatafoma. 
:term:`.Net`.
versiones
siendo
standard [*]_
.Net* http://www.voidspace.org.uk/ironpython/silverlight/index.shtml#id2
.. [*] *Listado de Módulos de la API standard*
http://docs.python.org/modindex.html 
a la popularidad del framework, con la version 2.0 se superó esta dificultad
[*]_.
http://www.infoq.com/news/2008/03/django-and-ironpython 
equivalente al objetivo del proyecto

  	