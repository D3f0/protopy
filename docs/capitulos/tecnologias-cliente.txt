.. _cliente:

#######################
Tecnologías del cliente
#######################

**********************************
Generación dinámica de páginas Web
**********************************

Desde la perspectiva de un usuario, la Web consiste en una enorme cantidad de
documentos interconectados a nivel mundial llamados *paginas Web*.
En el clinete las paginas se ven mediante un programa llamado navegadores  

**************************
Estructura de un navegador
**************************

.. _navegador-web:

Navegador Web
=============

.. note::
	Acá abordamos desde la perspectiva del navegador HTTP, HTML y Javascript
	
	
Un navegador web o *web browser*, es un software encargado de representar 
documentos de hípertexto al usuario, siendo los lenguajes de codificación de hipertexto más 
populares HTML y XHTML. Un navegador no solo representa los documentos de hipertexto, sino
que puede representar otros tipos de documentos, como imágenes
(:term:JPEG, :term:GIF, :term:PNG, etc.), 
sonido (:term:WAV, :term:MP3, :term:OGG) y contenido
multimedial como video (:term:MPEG, :term:H264, :term:RM, :term:MOV), 
e interactivos como es el caso de Macromedia Flash, applets Java o controles ActiveX en
la plataforma Windows. Debido a la cantidad de recursos que debe manejar un navegador, 
el servidor web agrega a cada respuesta al cliente una cabecera donde le indica 
el tipo de recurso que está engregado. Esta especificación se realiza con el 
standard :term:MIME.


Un navegador web acepta como entrada del usuario una URL, comunmente conocida como dirección 
de internet. Una vez validada la URL, el navegador web descarga el recurso apuntado por la URL
mediante el protcolo HTTP.

Una URL tiene el siguiente esquema, donde podemos diferenciar varios comopnentes

.. image:: ../_svg/esquema_urls.png

Los componetes de una URL son:

	* esquema
		Especifica el mecanismo de comunicación. Generalmente HTTP y HTTPS en una comunicación
		asegurada mediante TLS [*]_ .
		
	* anfitrión
		Especifica el nombre de dominio del servidor en internet, por ejemplo: *google.com*, 
		*nasa.gov*, *wikipedia.com*, etc.
		Se popularizó la utilización de el subdominio "www" para identificar el aniftrión
		que ejecuta el servidor web, dando lugar a direcciones del tipo *www.google.com*, 
		*www.nasa.gov*, etc.
		
		El *puerto* es un parametro de conexión TCP, y suele ser omitido debido a que 
		el esquema suele determinarlo, sindo 80 para HTTP y 443 para HTTPS. 
		 
	* recurso
		Especifica dentro del servidor, la ruta para acceder al recurso
		
	* query
		El parámetro query tiene sentido cuando el recurso apuntado por la ruta no
		se trata de una página estática y sirve para el pasaje de parámetros.
		El programa que genera el recurso puede recbir como argumentos estos parámetros, 
		por ejemplo, cuando se ingresa la palaba *foo* en el buscador google, la 
		url que provee el resutlado de la búsqueda es la siguiente::
			
			http://www.google.com/search?*q=foo*
		
	
	* enlace
		Dentro de un documento de hipertexto pueden existir destinos de enlaces, 
		o enlaces internos. Gracias a este parámeto se puede enlazar a una 
		sección epecífica de un documento, permitiendo al navegador ubicarse
		visualmente.

.. [*] *Transport Security Layer* es el sucesor de *Secure Socket Layer* (SSL), es un protocolo
criptográfico que provee conexiones seguras a traves de una red, típicamente internet [WikiSSL2009]_ .

.. [WikiSSL2009] *Transport Layer Security*, Wikipedia, 2009, último acceso, Agosto 2009.

Cuando el recurso apuntado se encuentra en internet, el navegador realiza una conexión hacia
el servidor web indicado por el dominio y mediante el prtocolo HTTP le informandole a que
recurso dese acceder.


HTTP
====

Para acceder al recurso *~ndefosse/introducion_lenguaje_python.html* en
el servidor *students.unp.edu.ar*, de la url http://students.unp.edu.ar/~ndefosse/introducion_lenguaje_python.html, el
navegador conforma la siguiente consulta::

	GET /~ndefosse/introduccion-lenguaje-python.html HTTP/1.1
	Host: students.unp.edu.ar
	User-Agent: Mozilla/5.0
	Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
	Accept-Language: es-ar,en-us;q=0.7,en;q=0.3
	Accept-Encoding: gzip,deflate
	Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
	Cookie: user_id=G7NVG5YY51I9DZAIJDEDQIXYQSRF0CTL

.. _http_request:

Esto conforma lo que se conoce como una consulta HTTP o *HTTP Request*. En la primera
linea se conforma de el método HTTP y el nombre del recurso, finalizando con la versión
del prtocolo que soporta el navegador (o cliente)::
	
	GET /~ndefosse/introduccion-lenguaje-python.html HTTP/1.1
	
La sgunda linea es el host al cual se accede. Un mismo servidor web puede estar publicado
en varios dominos, mediante esta linea se puede discriminar desde cual se intenta acceder
al recurso::

	Host: students.unp.edu.ar
	
El siguiente componente del *request* es la linea que identifica al cliente, en este caso
el navegador informa que se trata de Mozila, versión 5::
	User-Agent: Mozilla/5.0


Una vez que el servidor web a localizado y accedido al recurso, precede a enviar la respuesta
	
.. _cliente-html:
HTML
====
HTML es un lenguaje de marcado que teiene como objetivo describir un documento de hipertexto.
Un documento HTML se conforma por una serie de *tags* o etiquetas.

.. image:: ../_svg/etiqueta_html.png

 
Un documento HTML está delimitado por las etiquetas o *tags* html y contiene una cabecera
delimitada por *head* y un cuerpo, delmitado por *body*.

.. code-block:: html
	
	<html>
		<head>
			<title>Mi pagina</title>
		</head>
		<body>
			<h1>Título principal</h1> <!-- comentario -->
			<p>Párrafo</p>
		</body>
	</html>

Un documento HTML contener enlaces a recursos entendibles para el navegador, como los
enlaces a hojas de estilos o código javascript.

La inclusión de una hoja de estilo se realiza mediante el tag *link*, de la siguiente manera:

.. code-block:: html

	<link type="text/css" rel="stylesheet" href="hoja_de_estilos.css">

Se puede además embeber en la página el estilo, de la siguente manera

.. code-block:: html

	<style type="text/css">
	
		BODY {
			font-family: "Verdana";
			font-size: 12pt;
			padding: 2px 2px 3px 2px;
		}
	</style>
	
Al haberse incrustado el estilo en una página en particular, este solo tiene validés
para ese recurso en particular.

Otro tipo de recurso entendible para el navegador constituye la inclusión de código
de ejecución en el clinete, mediante el tag script.

.. code-block:: html

	<script type="text/javscript" src="mi_codigo.js"></script>
	
Además de la inclusión de recursos javascript externos, el código javascript se
puede embeber en el código html de varias maneras [StephenChapmanJS2009]_, entre ellas:

.. code-block:: html

	<script type="text/javascript">
	<!-- // Javascript en un comentario, para pasar validadores XHTML y ocultar de navegadores
		// que no soporten Javascript
		var x = 2;
		var y = 4;
	// -->
	</script> 

.. [StephenChapmanJS2009] *Javascript and XML*, Stephen Chapman, About.com, último acceso Agosto 2009, http://javascript.about.com/library/blxhtml.htm


.. _cliente-css:

CSS
===
Una hoja de estilo en cascada especfica como se va a mostrar un documento en pantalla, como
se va a imprimir o inclusive como se realiza la pronunciación a través de un dispositivo de
lectura [W3cCSS2009]_ .

El objetivo de CSS es separar el contendio de la presentación de un documento HTML o XML. Una
hoja de estilo puede ser enlazada desde varias paginas, permitiendo mantener coherencia y 
consistencia en el estilo. 


.. [W3cCSS2009] *Guia breve de CSS*, W3C, español, último acceso Agosto 2009, http://www.w3c.es/divulgacion/guiasbreves/HojasEstilo

.. _cliente-javascript:

JavaScript
==========

.. Explicar como meter codigo javascript en un doc da sustento a protopy

Javascript es un lenguaje de programación interpretado, de ámbito dinámico y orientado
a objetos mediante protipos.

al archivo que contiene la funcionalidad. Mas tarde cuando el navegador descarga
el documento y comienza su lectura al encontrar esta etiqueta solicita
al servidor el archivo referenciado y lo interpreta, para continuar luego con la
lectura del resto de las etiquetas. 

JavaScript es un lenguaje orientado a objetos, pero no es muy fácil comprenderlo
en este aspecto. A pesar de la sintaxis y el nombre, la forma en que JavaScript
implementa objetos es bastante diferente al que conocemos de C++ o Java, esto
suele llevar a la confusión. Mi intención es describir como es que se trabaja
con OOP en JavaScript intentando no confundir al compararlo con otros lenguajes.

Creación de Objetos
-------------------

No existe en JavaScript nada que no sea un objeto, lo son todos los tipos de
datos e inclusive las funciones, pudiendo contener estos propiedades y métodos.

Para crear un objeto desde cero basta con hacer:

miobjeto = new Object();

Lo que equivale a hacer:

miobjeto = {};

La primera forma de declarar un objeto les puede resultar familiar, la segunda
hace uso de una característica propia del lenguaje para declarar estructuras de
datos. Todos los tipos de datos pueden declararse de las dos maneras, por
ejemplo, una cadena de texto se declara:micadena = new String();

Y de la forma declarativa:micadena = “”;

Un array se declara:miarray = new Array();

Ó también:miarray = [];

Esta forma de declarar objetos es muy útil en algunos casos y es la base del
intercambio de mensajes mediante el estándar JSON.

Agregar miembros

Javascript es un lenguaje dinámico, esto posibilita la modificación de los
objetos en tiempo de ejecución, esto quiere decir que a un objeto, luego de ser
creado, se le pueden agregar o eliminar métodos y propiedades.

Para agregar miembros al objeto creado anteriormente solo basta con declararlo y
asignarle algún valor.

miobjeto.variable = “hola”;

miobjeto.metodo = new Function();

Listo, ya disponemos de un objeto personalizado creado desde cero, de este modo
se pueden agregar mas miembros de cualquier tipo a nuestro objeto. Sin embargo,
crear objetos de esta manera no es muy cómodo, ya que si quisiéramos crear una
copia de este objeto deberíamos declarar nuevamente todos sus miembros, debido a
que este objeto no se puede instanciar.

Creando ‘Clases’ en JavaScript

La forma en que los lenguajes orientados a objetos comúnmente resuelven el
problema anterior es mediante el uso de Clases, en JavaScript no es posible
declarar Clases, pero si es posible instanciar objetos a partir de un
constructor.

El objeto Function es utilizado como objeto instanciable en JavaScript, y el
cuerpo de la función es el constructor del nuestros objetos. Una vez que tenemos
un constructor, podemos llamarlo con el operador new.

/*clase de ejemplo*/

miClase = new Function();

nuevoObjeto = new miClase(); // instanciamos ‘miClase’

El método mas difundido para emular las clases en JavaScript es aprovechar el
funcionamiento de la palabra clave this dentro de los constructores. Cuándo una
función es llamada con el operador new, this hace referencia al objeto que será
retornado. Veamos como funciona.

/*clase de ejemplo*/

miClase = function(){

/*

agregamos miembros dinamicamente

al objeto que será retornado

*/

this.propiedad = “hola!”;

this.metodo = function(){

/* aqui ‘this’ hace referencia al objeto al que pertenece el metodo */

alert(this.propiedad);

}

}

nuevoObjeto = new miClase(); // instanciamos ‘miClase’

Ahora, ‘nuevoObjeto’ va a referenciar al objeto que se retornó cuando se llamó a
‘miClase’ usando el operador new, por lo tanto, va a tener todas las propiedades
y metodos que se crearon dentro del constructor.

El problema de esta forma de crear clases es que cada vez que la función
‘miClase’ es llamada, se crea una nueva función llamada ‘metodo’, de modo que
cada objeto tiene su propia versión de ‘metodo’ cuando, en realidad, todos los
objetos deberían compartir la misma función.

La propiedad ‘Prototype’

Todas las funciones tienen una propiedad llamada prototype, esta propiedad es un
objeto que será utilizado como ‘modelo’ inicial de todos los objetos que sean
creados con esta función cuando sea utilizada como constructor.

Inicialmente esta propiedad es un objeto vacío, pero debemos modificarla para
aprovechar esta característica del lenguaje. Reescribiendo el ejemplo anterior
el código quedaría así:

/* creamos un constructor limpio */

miClase = new Function();

miClase.prototype.propiedad = “hola!”;

miClase.prototype.metodo = function(){

/* aqui ‘this’ hace referencia al objeto al que pertenece el metodo */

alert(this.propiedad);

}

nuevoObjeto = new miClase(); // instanciamos ‘miClase’

Ahora todos los objetos creados a partir de ‘miClase’ compartirán inicialmente
las mismas referencias en todas sus propiedades, esto significa que, todos los
objetos van a compartir la misma versión de ‘metodo’.

Adicionalmente, al utilizar la propiedad prototype, obtenemos otra ventaja,
podemos usar la palabra reservada instanceof. Vemos como se usa si
escribimos:alert(nuevoObjeto instanceof miClase) // muestra ‘true’

El problema del uso de prototype, es que todas las propiedades hacen referencia
a las mismas del prototipo, por lo que si modificamos estos objetos se van a
modificar también en todos los objetos creados con esta clase. En siguiente
ejemplo cambiamos nuestra propiedad a un array para poder modificarla sin
cambiar nuestra referencia, de modo que podamos ver lo que explico con un
ejemplo:

/* creamos un constructor limpio */

miClase = new Function();

miClase.prototype.propiedad = new Array(“hola”,“hello”);

miClase.prototype.metodo = function(){

/* aqui ‘this’ hace referencia al objeto al que pertenece el metodo */

alert(this.propiedad);

}

nuevoObjeto = new miClase(); // instanciamos ‘miClase’

otroObjeto = new miClase(); // instanciamos ‘miClase’

nuevoObjeto.propiedad.push(“olá”);

otroObjeto.metodo(); // muestra “hola”,”hello”,”olá”

Como pueden ver en el ejemplo anterior, ‘nuevoObjeto’ y ‘otroObjeto’ hacen
referencia al mismo array, para solucionar este problema solo debemos asignar
un objeto diferente a cada propiedad de nuestros objetos. El constructor es un
buen lugar para realizar esta tarea:

miClase = function(){

this.propiedad = new Array(“hola”,“hello”); // reemplazamos el valor de nuestra propiedad con un nuevo objeto

};

miClase.prototype.propiedad = new Array(“hola”,“hello”);

miClase.prototype.metodo = function(){

/* aqui ‘this’ hace referencia al objeto al que pertenece el metodo */

alert(this.propiedad);

}

nuevoObjeto = new miClase(); // instanciamos ‘miClase’

otroObjeto = new miClase(); // instanciamos ‘miClase’

nuevoObjeto.propiedad.push(“olá”);

otroObjeto.metodo(); // muestra “hola”,”hello” :)

Listo, tenemos clase y tenemos objetos que funcionan bien. Espero que les haya
resultado claro, en el próximo post voy a explicar el mecanismo de la herencia
en JavaScript (si!!, se puede!!). Hasta entonces.


..
    De Wikipedia, la enciclopedia libre

    Programación basada en prototipos

    Programación basada en prototipos es un estilo de programación orientada a
    objetos en el cual, las "clases" no están presentes, y la re-utilización de
    procesos (conocida como herencia en lenguajes basados en clases) se obtiene
    a través de la clonación de objetos ya existentes, que sirven de prototipos,
    extendiendo sus funcionalidades. Este modelo es conocido como orientado a
    prototipos, o programación basada en instancias.

    El original (y el más canónico) ejemplo de lenguaje prototipado es el
    lenguaje Self, desarrollado por David Ungar y Randall Smith. Sin embargo el 
    paradigma sin clases está comenzando a popularizarse y ya ha sido
    implementado en lenguajes de programación como JavaScript, Cecil,
    NewtonScript, Ío, MOO, REBOL y varios otros.

    En lenguajes basados en clases los objetos pueden ser de dos tipos generales,
    las clases y las instancias. Las clases definen la disposición y la
    funcionalidad básicas de los objetos, y las instancias son objetos "utilizables"
    basados en los patrones de una clase particular. En este modelo, las clases
    actúan como colecciones de comportamiento (métodos) y estructuras que son
    iguales para todas las instancias, mientras que las instancias llevan los datos
    de los objetos. La distinción del papel se basa así sobre todo en una distinción
    entre la estructura y el comportamiento en un lado, y el estado en el otro.

    Los entusiastas de la programación basada en prototipos a menudo argumentan que
    los lenguajes basados en clases animan un modelo del desarrollo que se centra
    primero en la taxonomía y las relaciones entre las clases. En cambio, la
    programación basada en prototipos intenta animar al programador que se centre en
    el comportamiento de un cierto sistema de ejemplos y después de clasificar estos
    objetos en objetos arquetipos que se utilizan más adelante en una manera similar
    a las clases. Como tal, muchos sistemas basados en prototipos animan la
    alteración de prototipos durante tiempo de ejecución, mientras que solamente muy
    pocos sistemas orientados a objeto, basados en clase (como el primer sistema
    orientados al objetos dinámicos, Smalltalk) permiten que las clases sean
    alteradas durante la ejecución de un programa.

    Mientras que basan la amplia mayoría de sistemas basados en prototipos se hacen
    con lenguajes de programación interpretados y de tipos de datos dinámicos, es
    importante precisar que los sistemas de tipos de datos estáticos son
    técnicamente factibles. El lenguaje de programación de Omega que es basado en
    prototipos es un ejemplo de tal sistema, aunque según el Web site de Omega,
    Omega no es exclusivamente de tipos de datos estáticos, pero su "compilador
    puede elegir utilizar el tipo de dato estático donde es posible esto y puede
    mejorar la eficacia del programa.”

.. 
    http://javis.wordpress.com/2006/10/23/javascript-orientado-a-objetos/
    Algo de introduccion a objetos en javascript. sustento de prtopy y el constructor de clases

************************
Evolución del JavaScript
************************


************
Google Gears
************

Introducción
============

Google Gears es un software de código abierto distribuido por Google que añade
una nueva capa de aplicación a los navegadores.

.. http://gears.google.com/ Sitio de google gears

Una vez instaldo como una extensión en el navegador, el producto agrega una API
que permite programar en JavaScript interacciones con los componentes que
contiene.

Los tres componentes principales que incorpora gears son:

    * Local Server
        Permite almacenar localmente datos correspondientes a las páginas webs.
        Tanto HTML, JavaScript e imágenes entre otros, pueden ser almacenados
        localmente por el cliente e interponerse entre el requerimiento del
        navegador al servidor en conslutas posteriores, evitando asi la
        solicitud HTTP y optimizando el tiempo de respuesta de la aplicacion.
        
        Pese a que su funcionamiento es muy similar al de la cache del navegador
        la diferencia fundamental esta en que la actualizacion de los recursos
        que almacena es mantenida y realizada por el desarrollador.
    
    * Database
        Permite almacenar localmente datos que no correspondan a una página web
        pero son parte de la logica de la aplicacion y requieren de un
        almacenamiento presistente.
        
        El motor de base de datos utilizado es SQLite con algunos agregados y
        restricciones para brindar seguridad y formas de busqueda.
 
        Luego de que el usuario de la aplicacion web otroge el permiso explicito
        de creacion de la base, el desarrollador, disponer de un almacenamiento
        del tipo relacional en la máquina huésped. 
    
    * Worker Pool
        De manera similar a los "hilos" del sistema operativo, el manejador de
        hilos permite ejecutar acciones en segundo plano sin bloquear la
        ejecución del hilo principal del navegador.

        Hay que destacar que el manejador no corre en forma paralela a la
        ejecución del navegador, sino que se ejecuta cuando la página web se
        mantiene activa, por lo cual el refresco de página o la salida de la
        misma provoca que este se detenga o no se ejecute directemente.

Basicamente Gears y sus principales componentes estan enfocados en permitir al
programador ejecutar sus aplicaciones cuando el navegador no está conectado
al servidor. El lider del grupo de desarrollo Bret Taylor dijo que buscaba ser
capaz de acceder al Google Reader mientras usaba la conexión de la compañía, la
cual frecuentemente tenia un acceso defectuoso a Internet.

.. http://bret.appspot.com/ Blog de Bret Taylor

Gears esta incluido en el nuevo navegador de Google (Google Chrome) y posee
extensiones para instalarse en Internet Explorer 6.0+, Mozilla Firefox, Safari y
Opera Mini, y funciona en los sistemas operativos Windows 2000, XP y Vista,
Windows Mobile 5 y 6, MacOS y Linux de 32 bits.

Con susecivos lanzamientos el producto sea visto mejorado y favorecido en varios
aspectos a partir de la versión 0.4 del Gears se puede hablar ya de:

    * API para GIS, que permite acceder a la posición geográfica del usuario.

    * El API Blob, que permite gestionar bloques de datos binarios.

    * Accede a archivos en el equipo cliente a través del API de Google Desktop.

    * Permite enviar y recibir Blobs con el API HttpRequest.

    * Localización de los cuadros de diálogo de Gears en varios idiomas.

    * API para canvas, que permite manipular imagenes desde JavaScript.

En todos los casos que se requiera tener instalada una aplicacion soportada por
Gears vale la pena aclarar que el cliente debe haber accedido al menos una vez
al servidor de la aplicacion web y otorgado los permisos de instalacion
correspondiente. 