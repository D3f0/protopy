Programación de sistemas vs aplicaciones
----------------------------------------

Jhon Cownan [Cowan2005]_ además hace una clasificación interesante sobre la utilización de los lenguajes de 
programación, diferenciando la *programación de sistema* de la *programación de aplicaciones* [*]_.

    * *Programación de sistemas*

        En la programación de sistemas, el programador se centra en adaptar un nuevo dominio
        a interfases genéricas preexistentes.

    * *Programación de aplicaciones*

        En la programación de aplicaciones, por el contrario, modela el dominio de la aplicación
        de manera específica como paso inicial (análisis y diseño) y luego de la integración (si existe).

.. [*] Podemos ejemplificar la programación de sistemas con la creación de un shellscript por parte de un administrador de sistemas basados en UNIX,
donde existe un legnguaje de integración, shellscript y las un set de utilidades de sistema con interfase conocida que le brindan funcionalidades como ordenamiento de caddenas, busqueda y reemplazo de patrones, inicio y detencción de procesos, interacción con el SO, etc.

.. [Cowan2005] *RESTful Web Services, An introduction to building Web Services without tears (i.e., without SOAP or WSDL)*, 2005, http://home.ccil.org/~cowan/	restws.pdf


Framework
---------	
	
Un framework Web, es un framework de software que permite implementar
aplicaciones Web, brindando soporte para tareas comunes. Su objetivo es
facilitar el desarrollo de aplicaciones Web.

Para entender mejor esto, se presenta a continuación un ejemplo de aplicación
Web escrita usando CGI; este fragmento de código en Python, muestra los diez
libros más recientemente publicados de una base de datos::

    #!/usr/bin/python

    import MySQLdb

    # Se imprime el Content-Type y una linea en blanco, tal como requiere CGI
    print "Content-Type: text/html"
    print

    # Algo de HTML introductorio que de forma al documento
    print "<html><head><title>Libros</title></head>"
    print "<body>"
    print "<h1>Los ultimos 10 libros</h1>"
    print "<ul>"

    # Contectar con la base de datos y obtener los utlimos libros publicados
    conexion = MySQLdb.connect(user='yo', passwd='dejame_entrar', db='mi_base')
    cursor = conexion.cursor()
    cursor.execute("SELECT nombre FROM libros ORDER BY fecha_pub DESC LIMIT 10")
    
    # Iterar sobre la lista de libros e imprimir HTML con los datos obtenidos
    for fila in cursor.fetchall():
        print "<li>%s</li>" % fila[0]

    # Cerrar el documento HTML
    print "</ul>"
    print "</body></html>"

    # Cerrar la conexion con la base de datos
    conexion.close()

Si bien el código es sencillo de comprender y utilizar, cuando la aplicación
Web comienza a crecer más allá de lo trivial, este enfoque se desmorona y surgen
una serie de problemas:

    * ¿Qué sucede cuando múltiples páginas necesitan conectarse a la base de datos?
      Seguro que ese código de conexión a la base de datos no debería estar duplicado
      en cada uno de los scripts CGI, así que la forma pragmática de hacerlo sería
      refactorizarlo en una función compartida.

    * ¿Debería un desarrollador *realmente* tener que preocuparse por imprimir
      la línea de "Content-Type" y acordarse de cerrar la conexión con la base de datos?
      Este tipo de código repetitivo reduce la productividad del programador e
      introduce la oportunidad para que se cometan errores. Estas tareas de configuración y
      cierre estarían mejor manejadas por una infraestructura común.

    * ¿Qué sucede cuando este código es reutilizado en múltiples entornos,
      cada uno con una base de datos y contraseñas diferentes? En ese punto,
      se vuelve esencial alguna configuración específica del entorno.

    * ¿Qué sucede cuando un diseñador Web que no tiene experiencia programando
      en Python desea rediseñar la página? Lo ideal sería que la lógica de la página
      -- la búsqueda de libros en la base de datos -- esté separada del código HTML
      de la página, de modo que el diseñador pueda hacer modificaciones sin afectar
      la búsqueda.

Precisamente estos son los problemas que un framework Web intenta resolver.
Un framework Web provee una infraestructura de programación para las
aplicaciones, para que el desarrollador se pueda concentrar en escribir código
limpio y de fácil mantenimiento sin tener que reinventar la rueda.


ORM
---

En las aplicaciones modernas, la lógica arbitraria a menudo implica interactuar
con una base de datos. Detrás de escena, un *programa impulsado por una base de
datos* se conecta a un servidor de base de datos, recupera algunos datos de
esta, y los presenta al usuario con un formato agradable para su interpretacion.
Una aplicacion web no escapa a esta aseveración, solo que presenta los datos 
representados en HTML, así mismo un sitio puede proporcionar funcionalidad que
permita a los visitantes del sitio poblar la base de datos por su propia cuenta.

Amazon.com, por ejemplo, es un buen ejemplo de un sitio que maneja una base de
datos. Cada página de un producto es esencialmente una consulta a la base de
datos de productos de Amazon formateada en HTML, y cuando se envian datos al 
servidor, como opiniónes de cliente, estos son insertadados en la base de datos
de opiniones.

La forma simple de interactuar con una base de datos, es mediante el uso de
bibliotecas provistas por los lenguajes para ejecutar consultas SQL y una vez 
obtenidos los datos, procesarlos.

En este ejemplo se usa la biblioteca ``MySQLdb`` para conectar con una base de
datos MySQL, recuperar algunos registros::

    import MySQLdb

    db = MySQLdb.connect(user='me', db='mydb', passwd='secret', host='localhost')
    cursor = db.cursor()
    cursor.execute('SELECT name FROM books ORDER BY name')
    names = [row[0] for row in cursor.fetchall()]
    db.close()

Este enfoque funciona, pero presenta algunos problemas:

    * Los parametros de la conexión a la base de datos estan codificandos 
        *en duro* (*hard-coding*).

    * Se debe escribir una cantidad de código estereotípico: crear una
        conexión, un cursor, ejecutar una sentencia, y cerrar la conexión.

    * Ata a las aplicaciones a MySQL. Si, en el camino, se quiere cambiar MySQL
        por PostgreSQL por ejemplo, se deben alterar todas las lineas que hagan
        falta para la nueva biblioteca o conector, parámetros de conexión, 
        posiblemente reescribir el SQL, etc.

Por otro lado y quiza mas importante a la hora de desarrollar un programador que 
trabajé con programación orientada a objetos y bases de datos relacionales, debe
realizar un cambio de contexto cada vez que requiera interactuar con la base de
datos, escribiendo consultas en SQL y luego lidear con los resultados obtenidos
de las consultas entre los objetos. Este *cambio de contexto* es debido a una
diferencia que existe entre los dos paradigmas involucrados. Mientras que el
modelo relacional trata con relaciones, conjuntos y la logica matemática 
correspondiente, el paradigma orientado a objetos trata con objetos, atributos
y asociaciones de unos con otros. Tan pronto como se quieran persistir los
objetos utilizando una base de datos relacional esta desaveniencia resulta
evidente. 


Herencia
--------


Utiliza prototipos
en vez de clases. Estos se definen con una función [*]_, pero
para que ésta funcione como prototipo, se utiliza la palabra reservada
``new``. En tal caso, dentro del cuerpo de la función, la palabra reservada
``this`` apunta a la instancia que está siendo generada. La función
toma el comportamiento de lo que se conoce en los lenguajes de programación OO
como *constructor*. Por ejemplo:

.. code-block:: javascript

	function prototipo () {
		this.x = 1;
	}
	
	var instancia = new prototipo();

.. note:: Hablar de por que

Otra forma de definir una instancia es a través del tipo de dato llamado ``Object``[*]_, 
también conocido como arreglo asociativo.
Los arreglos asociativos consisten en asocaciones clave-valor y están presentes en varios lenguajes [*]_.

.. En JavaScript, este tipo de dato responde al operador punto ``.`` de la misma manera que al operador de indexación ``[]``
   y a veces es utilizado para definir objetos de una única instancia:

.. code-block:: javascript

	// Las llaves son un alias de "new Object()"
	var mi_instancia = {
		// Definción de un método
		mi_metodo: function () {
			alert(this.atributo);

		},
		// Definición de un atributo
		atributo: 3
	}

	mi_instancia.mi_metodo();
	
	

Tampoco está presente el ocultamiento de información, todos los métodos y atributos
son públicos.

.. [*] En JavaScript una función es una instancia de la clase Function
.. [*] En JavaScript la sintaxis ``{}`` es equivalente a escribir ``new Object()``.
.. [*] ``dict`` en Python, ``HashMap`` en Java, ``Dictinary`` en SmallTalk, ``Hash`` en Ruby.


Un objeto se puede crear de varias maneras:

.. code-block:: javascript

    var uno = new Object();	// Mediante el constructor
    uno['a'] = 3;			// Asignacion equivalente
    uno.b = 4;				// Asignación equivalente
    
    var dos = {};			// Mediante la sintaxis abreviada
    dos['a'] = 3;			// Asignacion equivalente
    dos.b = 4;				// Asignación equivalente

Las caracteristicas dinámicas de lenguaje posibilitan la modificación de los
objetos en tiempo de ejecución, esto quiere decir que a un objeto, luego de ser
creado, se le pueden agregar o eliminar métodos y propiedades:

.. code-block:: javascript

    uno.variable = “hola”;
    dos.metodo = function () { this.c = 3; }

El resultado de la ejecución del código previo son dos objetos, ``uno`` y ``dos``,
personalizados uno con un atributo y otro con un "metodo".
Sin embargo esta forma de definir un objeto sobre la marcha es inadecuada
para la creación instancias, tarea para la cual son más adecuados
los prototipos.

Una vez aclaradas las diferencias entre los prototipos, se utilizará el
término *clase* y *prototipo* de manera indistinta.

En JavaScript se pueden generar funciones anónimas, conocidas en otros lenguajes
como expresiones *lambda*. Utilizando esta característica, se puede lograr
una definción de prototipos más cercana a la sintaxis de otros lenguajes OO.

.. code-block:: javascript

    /*clase de ejemplo*/

    Clase = function() {
        this.propiedad = “hola!”;
        this.metodo = function(){
            alert(this.propiedad);
        }
    }
    objeto = new Clase(); // instanciamos ‘Clase’

Esta primera aproximación posee una importante desventaja: cada
instancia posee una nueva versión de los métodos.

Para lograr una unificación del protipo al cual pertenecen las instancias
todas las funciones tienen una propiedad llamada *prototype*. 
Esta propiedad es un Object que será utilizado como ‘modelo’ inicial de todos los objetos que sean
creados cuando esta función cuando sea utilizada como constructor.

Reescribiendo el ejemplo anterior el código quedaría así:

.. code-block:: javascript

    /* creamos un constructor limpio */

    Clase = new Function();
    Clase.prototype.propiedad = “hola!”;
    Clase.prototype.metodo = function(){
        alert(this.propiedad);
    }
    objeto = new Clase(); // instanciamos ‘miClase’

En este ejemplo, todos los objetos creados a partir de ‘Clase’ comparten las
mismas referencias en todas sus propiedades, esto significa que, todos los
objetos van a compartir la misma versión de cada ‘metodo’.

Adicionalmente, al utilizar la propiedad prototype, se obtiene otra ventaja y es
poder usar la palabra reservada instanceof para determinar si un objeto es
instancia de un constructor:

.. code-block:: javascript
	
	var instancia = new Clase();
	instanceof(instancia, Clase); // -> true


.. http://javis.wordpress.com/2006/10/23/javascript-orientado-a-objetos/

************************
Evolución del JavaScript
************************

A continuación se describen algunas características que se han agregado
a ECMAScript a lo largo de las versiones.

Herencia
========

Javascript posee herencia basada en prototipos, pero existen muchas versiones
de implementarla. Se describen a continuación las técnicas más populares.


Object Masquerading
-------------------

Este método saca provecho del comportamiento de la palabra reservada this
dentro de los constructores.
El funcionamiento es el siguiente: Un constructor asigna propiedades y métodos
a un objeto referenciándolo con la palabra clave *this*. Como un constructor
es una función, esta puede ser invocada desde una "subclase".

Definendo a la clase A como siguie:

.. code-block:: javascript
    
    function ClaseA(nombre){
        this.nombre = nombre;
        this.identificarse = function(){
            alert(this.nombre);
        }
    }

Recordemos que en un constructor, this hace referencia al nuevo objeto que será
retornado. Pero en un método, this hace referencia al objeto desde el cual fue
llamado.

.. code-block:: javascript
     
    function ClaseB(nombre){
        this.superClase = ClaseA;
        this.superClase(nombre);
        delete this.superClase;
    }

En el código anterior, el constructor ‘ClaseA’, es llamado como método del nuevo
objeto que se esta creando en ‘ClaseB’, por lo tanto, todas las propiedades y
métodos que se crean en ClaseA se añaden a las instancias de ClaseB.


*Object Masquerading* permite, por su forma de invocar a los "superconstructores",
implementar herencia múltiple, basta con llamar cuantos constructores sean necesarios.
Al no trabajar con la propiedad *prototype*, *instanceof* no es utilizable y persiste
el problema de las múltiples versiones de los métodos.

Prototype Chaining
------------------

Anteriormente se mostró como definir clases utilizando el objeto prototype.
*Prototype Chaining* se basa en este objeto y es el método recomendado por el
standard ECMA Script.
El atributo *prototype* de el objeto Function es pasado a todas las instancias
cuando la función se invoca como constructor.

La idea trás Prototype Chaining es generar una instancia de la clase base
como instancia inicial del prototipo de la subclase.

Modificando el ejemplo anterior para utilizar Prototype Chaining obtenemos
el siguiente código.

.. code-block:: javascript

    function ClassA() {}
    ClassA.prototype.nombre = “”;
    ClassA.prototype.identificarse = function() {
        alert(this.nombre);
    }
    function ClassB() {}    
    ClassB.prototype = new ClassA();

Este método posee la desventaja que no es posible invocar el constructor
con parámetros, pero habilita la utilización de la función *instanceof*:

.. code-block:: javascript

    var miobjeto = new ClassB();
    alert(miobjeto instanceof ClassB); // true
    alert(miobjeto instanceof ClassA); // true
