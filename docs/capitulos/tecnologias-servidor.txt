.. _servidor:

########################
Tecnologías del servidor
########################

.. _servidor-cgi:

***
CGI
***

CGI, *Common Gateway Interface* [*]_ es un estándar de comunicación entre un servidor web
y una aplicación, que permite que un a través de un navegador, se invoque un programa
en el servidor y se recuperen resultados de éste. 

CGI fue la primera estandarización de un mecanismo para generar contenido dinámico 
en la web.

En el estandar CGI, el servidor web intercambia datos con la aplicación medinate variables
de entorno y los flujos de entrada y salida.

Los parámetros HTTP (como la URL, el método (GET, POST, PUSH, etc.), nombre del servidor
puerto, etc.) e información sobre el servidor son trasferidos a la aplicación CGI como variables de 
entorno.

Si existiese un cuerpo en la petición HTTP, como por ejemplo, el contenido de un formulario, bajo
el método POST, la aplicación CGI accede a esta como entrada estandard.

El resultado de la ejecución de la aplicación CGI se escribe en la salida estándard, anteponiendo
las cabeceras HTTP respuesta, para que el servidor responda al clinete. En los encabezados
de respuesta, el tipo MIME determina como interpreta el clinete la respuesta. Es decir, la 
invocación de un CGI puede devolover diferentes tipos de contenido al clinete (html, imágenes, 
javascript, contenido multimedia, etc.)


Dentor de las varaibles de entorno, la Wikipedia [WikiCGI2009]_ menciona:

    * QUERY_STRING
        Es la cadena de entrada del CGI cuando se utiliza el método GET sustituyendo algunos símbolos especiales por otros. Cada elemento se envía como una pareja Variable=Valor. Si se utiliza el método POST esta variable de entorno está vacía.
    * CONTENT_TYPE
        Tipo MIME de los datos enviados al CGI mediante POST. Con GET está vacía. Un valor típico para esta variable es: Application/X-www-form-urlencoded.
    * CONTENT_LENGTH
        Longitud en bytes de los datos enviados al CGI utilizando el método POST. Con GET está vacía.
    * PATH_INFO
        Información adicional de la ruta (el "path") tal y como llega al servidor en el URL.
    * REQUEST_METHOD
        Nombre del método (GET o POST) utilizado para invocar al CGI.
    * SCRIPT_NAME
        Nombre del CGI invocado.
    * SERVER_PORT
        Puerto por el que el servidor recibe la conexión.
    * SERVER_PROTOCOL
        Nombre y versión del protocolo en uso. (Ej.: HTTP/1.0 o 1.1)

Variables de entorno que se intercambian de servidor a CGI:

    * SERVER_SOFTWARE
        Nombre y versión del software servidor de www.
    * SERVER_NAME
        Nombre del servidor.
    * GATEWAY_INTERFACE
        Nombre y versión de la interfaz de comunicación entre servidor y aplicaciones CGI/1.12

Debido a la popularidad de las aplicaciones CGI, los servidores web incluyen generalmente
un directorio llamado **cgi-bin** donde se albergan estas aplicaciones.

.. note:: Faltan referencias sobre la popularidad de los lenguajes

Históricamente las aplicaciones CGI han sido escritas en lenguajes interpretados, sinedo muy popular Perl y más recientemente el lenguaje PHP.


..  http://www.mi_dominio.com/cgi-bin/mi_programa.cgi?nombre=matias
    
.. Invocará a la aplicación del archivo mi_programa.cgi


.. Poner un gráfico aquí

.. [WikiCGI2009] *Interfaz de entrada común*, Wikipedia, 2009, último acceso Agosto 2009, http://es.wikipedia.org/wiki/Common_Gateway_Interface#Intercambio_de_informaci.C3.B3n:_Variables_de_entorno

.. [*] A veces traducido como pasarela común de acceso.

.. _servidor-lenguajes:

************************
Lenguajes interpreteados
************************

PHP
===

Ruby
====
Python
======

Python es un lengauje interpretado.
.. Escribir sobre el concepto de modulos y algo de programacion modular, ya que da soporte a protopy http://es.wikipedia.org/wiki/Programaci%C3%B3n_modular

.. _servidor-wsgi:

WSGI
----

WSGI o Web Server Gateway Interfase es una especidicación para que un web server y una aplicación
se comuniquen. Es un estándar del lenguaje Python, descrito en el PEP [*]_ 333. Si bien WSGI es
similar en su concepción a CGI, su objetivo es estandarizar la aparición de estructras de software
cada vez más complejas (frameworks :ref:`servidor-frameworks_ <framework>`)

.. [*] PEP *Python Enhancement Proposals* son documentos en los que se proponen mejoras para el lenguaje
Python, son albergados en el sitio oficial http://www.python.org

WSGI propone que una aplicación es una función que recibe 2 argumentos. Como primer argumento, un diccionario con las variables de entorno, al igual que en CGI, y como segundo argumento una función (u :ref:`python_callables_ <objeto llamable>`) al cual se invoca para iniciar la respuesta.

.. image:: ../_svg/esquema_wsgi.png




.. _servidor-frameworks:

**********
Frameworks
**********

.. Usamos la traducción redefinir para override

Según la la wikipedia [WIK001]_ un framework de software es *una abstracción en la cual un código común, que provee una funcionalidad genérica, 
puede ser personalizado por el programador de manera selectiva para brindar una funcionalidad específica*.

.. [WIK001] *Software Framework*, Wikipedia, 2009, http://en.wikipedia.com/software_framework, última visita Agosto de 2009.

Además agrega  que los frameworks son similares a las bibliotecas de software (a veces llamadas librerías) dado que proveen
abstracciones reusables de código a las cuales se accede mediante una API bien definida. Sin embargo, existen
ciertas características que diferencian al framework de una librería o aplicaciones normales de usuario:

    * Inversion de control
        Al contrario que las bibliotecas en las aplicaciones de usuario, en un framework, el flujo de control no es manejado
        por el llamador, sino por el framework. Es decir, cuando se utilizan bibliotecas o programas de usuario como soporte
        para brindar funcionalidad, estas son llamados o invocados en el código de aplicación principal que es definido por el usuario. 
        En un framework, el flujo de control principal está definido por el framework.

    * Comportamiento por defecto definido
        Un framework tiene un comportamiento por defecto definido. En cada componete del framework, existe un comportamineto
        genérico con alguna utilidad, que puede ser redefinido con funcionalidad del usuario.

    * Extensibiliad
        Un framework suele ser extendido por el usuario mediante redefinición o especialización para proveer una funcionalidad específica. 

    * No modificabilidad del código del framework
        En general no se permite la modificación del código del framework. Los programadores pueden extender el framework, pero no modificar
        su código. 

Los diseñadores de frameworks tienen como objetivo facilitar el desarrollo de software, permitiendo
a los programadores enfocarse en cumplimentar los requermientos del análisis y diseño, en vez de 
dedicar tiempo a resolver los detalles comunes de bajo nivel. En general la utilización de un 
framework reduce el tiempo de desarrollo.

Por ejemplo, en un equipo donde se utiliza un framework web para desarrollar un sitio de banca 
electrónica, los desarrolladores pueden enfocarse en la lógica necesaria para realizar las extraciones
de dinero, en vez de la mecánica para preserver el estado entre las peticiones del navegador.

.. Carga != Incertidumbre

Sin embargo, se suele argumentar que los frameworks pueden ser una carga, debido a la complejidad
de sus APIs o la incertidumbre que generar la existencia de varios frameworks para un mismo tipo
de aplicación. A pesar de tener como objetivo estandarizar y reducir el tiempo de desarrollo, el
aprendizaje de un framework suele requerir tiempo extra en el desarrollo, que debe ser 
tenido en cuenta por el quipo de desarrollo.
Trás completar el desarrollo en un framework, el equipo de desarrllo no debe volver a invertir 
tiempo en aprendizaje en sucesivos desarrollos.

.. image:: ../_static/framework_esquema_flujo_control.png
    :width: 719px

Framework Web
=============

.. note::
    
    Ver diferencia entre sitio y aplicación
    
Un framework web, es un framework de software que permite implementar aplicaciones web brindando
soporte para tareas comunes como.

En Wikipeida [WIKI002]_

    * Seguridad
    
    * Mapeo de URLs
    
    * Sistema de plantillas
    
    * Caché
    
    * AJAX
    
    * Configuración mínima y simplificada
    
.. [WIKI002] *Web Framework*, Wikipedia, 2009, http://en.wikipedia.org/wiki/Web_application_framework, última visita Agosto de 2009.

.. _servidor-mvc:

********************
Model View Controler
********************

Antes de profundizar en más código, tomémonos un momento para considerar el
diseño global de una aplicación Web Django impulsada por bases de datos.

Como mencionamos en los capítulos anteriores, Django fue diseñado para promover
el acoplamiento débil y la estricta separación entre las piezas de una
aplicación. Si sigues esta filosofía, es fácil hacer cambios en un lugar
particular de la aplicación sin afectar otras piezas. En las funciones de vista,
por ejemplo, discutimos la importancia de separar la lógica de negocios de la
lógica de presentación usando un sistema de plantillas. Con la capa de la base
de datos, aplicamos esa misma filosofía para el acceso lógico a los datos.

Estas tres piezas juntas -- la lógica de acceso a la base de datos, la lógica
de negocios, y la lógica de presentación -- comprenden un concepto que a veces
es llamado el patrón de arquitectura de software *Modelo-Vista-Controlador* (MVC).
En este patrón, el "Modelo" hace referencia al acceso a la capa de datos, la
"Vista" se refiere a la parte del sistema que selecciona qué mostrar y cómo
mostrarlo, y el "Controlador" implica la parte del sistema que decide qué
vista usar, dependiendo de la entrada del usuario, accediendo al modelo si es
necesario.

.. exhortacion:: ¿Por qué el acrónimo?

    El objetivo de definir en forma explícita patrones como MVC es
    principalmente simplificar la comunicación entre los desarrolladores. En
    lugar de tener que decir a tus compañeros de trabajo, "Vamos a hacer una
    abstracción del acceso a la base de datos, luego vamos a tener una capa que
    se encarga de mostrar los datos, y vamos a poner una capa en el medio para
    que regule esto", puedes sacar provecho de un vocabulario compartido y
    decir, "Vamos a usar un patrón MVC aquí".

Django sigue el patrón MVC tan al pie de la letra que puede ser llamado
un framework MVC. Someramente, la M, V y C se separan en Django de la
siguiente manera:

    * *M*, la porción de acceso a la base de datos, es manejada por la capa de
      la base de datos de Django, la cual describiremos en este capítulo.

    * *V*, la porción que selecciona qué datos mostrar y cómo mostrarlos, es
      manejada por la vista y las plantillas.

    * *C*, la porción que delega a la vista dependiendo de la entrada del
      usuario, es manejada por el framework mismo siguiendo tu URLconf y
      llamando a la función apropiada de Python para la URL obtenida.

Debido a que la "C" es manejada por el mismo framework y la parte más
emocionante se produce en los modelos, las plantillas y las vistas, Django es
conocido como un *Framework MTV*. En el patrón de diseño MTV,

    * *M* significa "Model" (Modelo), la capa de acceso a la base de datos. Esta
      capa contiene toda la información sobre los datos: cómo acceder a estos,
      cómo validarlos, cuál es el comportamiento que tiene, y las relaciones
      entre los datos.

    * *T* significa "Template" (Plantilla), la capa de presentación. Esta capa
      contiene las decisiones relacionadas a la presentación: como algunas cosas
      son mostradas sobre una página web o otro tipo de documento.

    * *V* significa "View" (Vista), la capa de la lógica de negocios. Esta capa
      contiene la lógica que accede al modelo y la delega a la plantilla
      apropiada: puedes pensar en esto como un puente entre el modelos y las
      plantillas.

Si estás familiarizado con otros frameworks de desarrollo web MVC, como Ruby on
Rails, quizás consideres que las vistas de Django pueden ser el "controlador" y
las plantillas de Django pueden ser la "vista". Esto es una confusión
desafortunada a raíz de las diferentes interpretaciones de MVC. En la
interpretación de Django de MVC, la "vista" describe los datos que son
presentados al usuario; no necesariamente el *cómo* se mostrarán, pero si
*cuáles* datos son presentados. En contraste, Ruby on Rails y frameworks
similares sugieren que el trabajo del controlador incluya la decisión de cuales
datos son presentados al usuario, mientras que la vista sea estrictamente el
*cómo* serán presentados y no *cuáles*.

Ninguna de las interpretaciones es más "correcta" que otras. Lo importante es
entender los conceptos subyacentes.


.. _servidor-orm:

**************************
Mapeador Objeto-Relacional
**************************

En las aplicaciones web modernas, la lógica arbitraria a menudo implica
interactuar con una base de datos. Detrás de escena, un *sitio web impulsado por
una base de datos* se conecta a un servidor de base de datos, recupera algunos
datos de esta, y los muestra con un formato agradable en una página web. O,
del mismo modo, el sitio puede proporcionar funcionalidad que permita a los
visitantes del sitio poblar la base de datos por su propia cuenta.

Muchos sitios web más complejos proporcionan alguna combinación de las dos.
Amazon.com, por ejemplo, es un gran ejemplo de un sitio que maneja una base de
datos. Cada página de un producto es esencialmente una consulta a la base de
datos de productos de Amazon formateada en HTML, y cuando envías una opinión
de cliente (*customer review*), esta es insertada en la base de datos de
opiniones.

Así como en el `Capítulo 3`_ detallamos la manera "tonta" de producir una salida
con la vista (codificando *en duro*) el texto directamente dentro de la vista),
hay una manera "tonta" de recuperar datos desde la base de datos en una vista.
Esto es simple: sólo usa una biblioteca de Python existente para ejecutar una
consulta SQL y haz algo con los resultados.

En este ejemplo de vista, usamos la biblioteca ``MySQLdb`` (disponible en
http://www.djangoproject.com/r/python-mysql/)  para conectarnos a una base de
datos de MySQL, recuperar algunos registros, y alimentar con ellos una plantilla
para mostrar una página web::

    from django.shortcuts import render_to_response
    import MySQLdb

    def book_list(request):
        db = MySQLdb.connect(user='me', db='mydb', passwd='secret', host='localhost')
        cursor = db.cursor()
        cursor.execute('SELECT name FROM books ORDER BY name')
        names = [row[0] for row in cursor.fetchall()]
        db.close()
        return render_to_response('book_list.html', {'names': names})

Este enfoque funciona, pero deberían hacerse evidentes inmediatamente algunos
problemas:

    * Estamos codificando *en duro* (*hard-coding*) los parámetros de la
      conexión a la base de datos. Lo ideal sería que esos parámetros se
      guardarsen en la configuración de Django.

    * Tenemos que escribir una cantidad de código estereotípico: crear una
      conexión, un cursor, ejecutar una sentencia, y cerrar la conexión. Lo
      ideal sería que todo lo que tuviéramos que hacer fuera especificar los
      resultados que queremos.

    * Nos ata a MySQL. Si, en el camino, cambiamos de MySQL a PostgreSQL,
      tenemos que usar un adaptador de base de datos diferente (por ej.
      ``psycopg`` en vez de ``MySQLdb``), alterar los parámetros de conexión
      y -- dependiendo de la naturaleza de las sentencia de SQL -- posiblemente
      reescribir el SQL. La idea es que el servidor de base de datos que usemos
      esté abstraído, entonces el pasarnos a otro servidor podría significar
      realizar un cambio en un único lugar.



.. por poner algo, pueden ser otros
Rails

Symfony

.. Django CLI

.. _servidor-django:

******
Django
******

Acá tenemos que justificar por que django

`Django <http://www.djangoproject.com>`_ es un framework web escrito en Python
el cual sigue vagamente el concepto de Modelo Vista Controlador.
Ideado inicialmente como un adminsitrador de contenido para varios sitios de
noticias, los desarrolladores encontraron que su CMS era lo sufcientemente
genérico como para curbir un ámbito más aplio de aplicaciones.

En honor al músico Django Reinhart, fue liberado el código base bajo la licencia 
:term:`BSD` en Julio del 2005 como Django Web Framework. El slogan del framework
fue "Django, Él framework para perfeccionistas con fechas límites" [*]_.

.. [*] Del ingles "The Web framework for perfectionists with deadlines"

En junio del 2008 fue anuncidada la cereación de la Django Software Fundation,
la cual se hace cargo hasta la fecha del desarrollo y mantenimiento.

Los orígenes de Django en la administración de páginas de noticias son evidentes
en su diseño, ya que proporciona una serie de características que facilitan el
desarrollo rápido de páginas orientadas a contenidos. 
Por ejemplo, en lugar de requerir que los desarrolladores escriban controladores 
y vistas para las áreas de administración de la página, Django proporciona una
aplicación incorporada para administrar los contenidos que puede incluirse como
parte de cualquier proyecto; la aplicación administrativa permite la creación,
actualización y eliminación de objetos de contenido, llevando un registro de
todas las acciones realizadas sobre cada uno (sistema de logging o bitácora), y
proporciona una interfaz para administrar los usuarios y los grupos de usuarios
(incluyendo una asignación detallada de permisos).

Con Django también se distribuyen aplicaciones que proporcionan un sistema de 
comentarios, herramientas para sindicar contenido via RSS y/o Atom, "páginas
planas" que permiten gestionar páginas de contenido sin necesidad de escribir
controladores o vistas para esas páginas, y un sistema de redirección de URLs.

Django como framework de desarrollo consiste en un  conjunto de utilidades 
de consola que permiten crear y manipular proyectos y aplicaciones.

Estructuración de un proyecto en Django
=======================================

Durante la instalación del framework en el sistema del desarrollador, se añade
al PATH un comando con el nombre django-admin.py. Mediante este comando se crean
proyectos y se los administra.

Un proyecto se crea mediante la siguiente orden:

.. code-block:: bash
    
    $ django-admin.py startproject mi_proyecto # Crea el proyecto mi_proyecto

**Un proyecto es un paquete Python que contiene 3 módulos**:

    * manage.py
        Interfase de consola para la ejecución de comandos
    * urls.py
        Mapeo de URLs en vistas (funciones)
    * settings.py
        Configuración de la base de datos, directorios de plantillas, etc.
 
En el ejemplo anterior, un listado gerárquico del sistema de archivos 
mostraría la siguiente estructura::

    mi_proyecto/
        __init__.py
        manage.py
        settings.py
        urls.py

El proyecto funciona como un contenedor de aplicaciones que ser rigen bajo
la misma base de datos, los mismos templates, las mismas clases de middleware entre 
otros parámetros.

Analicemos a continuación la función de cada uno de estos 3 módulos.

.. _django-proyecto-settings:

Módulo settings
---------------

Este módulo define la configuración del proyecto, siendo sus atributos
principales la configuración de la base de datos a utilizar, la ruta en la cual
se encuentran los médios estáticos, cuál es el nombre del archivo raíz de urls
(generalmente urls.py).
Otros atributos son las clases middleware, las rutas de los templates, el idioma
para las aplicaciones que soportan :ref:`i18n`, etc.

.. Subir como ventaja
.. Poner algo mas sobre la base de datos

Al ser un módulo del lengauje python, la confguración se puede editar muy facilmente
a diferencia de configuraciones realizadas en XML, además de contar con la ventaja de 
poder configurar en caliente algunos parametros que así lo requieran.

Un parametro fundamental es la lista denominada INSTALLED_APPS que contiene los nombres
de las aplicaciones instaladas en le proyecto.

.. _django-proyecto-manage:

Módulo manage
-------------

Esta es la interfase con el framework. Éste módulo es un script ejecutable, que
recibe como primer argumento un nombre de comando de django.

Los comandos de django pemiten, permiten entre otras cosas:

    * startapp <nombre de aplicación>
        Crear una aplicación

    * runserver
        Correr el proyecto en un servidor de desarrollo.

    * syncdb
        Generar las tablas en la base de datos de las aplicaciones instaladas
        
El resultado de el comando **startapp** en el ejemplo anterior genera el siguiente
resultado::

    mi_proyecto/
        mi_aplicacion/
            __init__.py
            models.py
            views.py
        __init__.py
        manage.py
        settings.py
        urls.py

Módulo urls
-----------

Este nombre de módulo aparece a nivel proyecto, pero también puede aparecer a nivel
aplicación. Su misión es definir las asociaciones entre URLs y vistas, de manera de 
que el framework sepa que vista utilizar en función de la URL que está requiriendo
el clinete.
Las URLs se ecriben mediante expresiones regulares. Se suele aprovechar la posibilidad
del modulo de expresiones regulares del lenguaje python, que permite recuperar
gurpos nombrados (en contraposición al enfoque ordinal tradicional).

La asociación url-vistas se define en el módulo bajo el nombre :term:`urlpatterns`. 
También es posible derivar el tratado de una parte de la expresión reuglar
a otro módulo de urls. Generalmente esto ocurre cuando se desea delegar el tratado
de las urls a una aplicación particular.

    Ej:
        Derivar el tratado de todo lo que comience con la cadena personas a 
        al módulo de urls de la aplicación personas.

        .. code-block:: python

            (r'^personas', include('mi_proyecto.personas.urls'))

Estructura de una aplicación Django
===================================

Una aplicación es un paquete python que consta de un módulo models y un módulo views.

    mi_proyecto/
        mi_aplicacion/
            __init__.py
            models.py
            views.py
        ...
 
Módulo models
-------------

Cada vez que se crea una aplicación, se genera un módulo models.py, en el cual
se le permite al programador definir modelos de objetos, que luego son
transformados en tablas relacionales [*]_.

Módulo views
------------

Cada aplicacion posee un módulo views, donde se definen las funcinoes que atienden
al cliente y son activadas gracias a el mapeo definido en el módulo urls del proyecto
o de la aplicación.

Las funciones que trabajan como vistas deben recibir como primer parámetro el request
y opcionalmente parámetros que pueden ser recuperados del mapeo de urls.

Dentro del módulo de urls

.. code-block:: python

    # Tras un mapeo como el sigunete
    (r'^persona/(?P<id_persona>\d)/$', mi_vista)
    # la vista se define como
    def mi_vista(request, id_persona):
        persona = Personas.objects.get(id = id_persona)
        datos = {'persona':persona, }
        return render_to_response('plantilla.html', datos)

.. [*] Mediante el comando syncdb del módulo manage del proyecto

El cliclo de una petición
=========================
 
Cada vez que un browser realiza una petición a un proyecto desarrollado en django, 
la petición HTTP pasa por varias capas.

Inicialmente atraviesa los Middlewares, en la cual, el middleware de Request, empaqueta
las variables del request en una instancia de la calse Request.

Luego de atravesar los middlewares de request, mediante las definciones de URLs, 
se selecciona la vista a ser ejecutada.

Una vista es una función que recibe como primer argumento el request y opcionalmente 
una serie de parámetros que puede recuperar de la propia URL.

Dentro de la vista se suelen hacer llamadas al ORM, para realizar consultas sobre
la base de datos. Una vez que la vista a completado la lógica, genera un mapeo que es
transferido a la capa de templates.

El template rellena sus comodines en función de los valores del mapeo que le entrega
la vista. Un template puede poseer lógica muy básica (bifurcaciones, bucles de repetición, 
formateo de datos, etc).

El template se entrega como un HttpResponse. La responsabilidad de la vista es entregar
una instancia de esta clase.

.. image:: ../_static/get_response.png
    :height: 200
    :width: 200

.. _django-orm:

Interactuar con una base de datos
=================================

Django incluye una manera fácil pero poderosa de realizar consultas a bases de
datos utilizando Python.

Una ves configurada la conexión a la base de datos en el módulo de configuración
:ref:`Módulo settings <django-proyecto-settings>` se esta condiciones de comenzar a
usar la capa del sistema de Mapeo Objeto-Relacional del framework.

Si bien existen pocas reglas estrictas sobre cómo desarrollar dentro de Django, 
existe un requisito respecto a la convención de la aplicación: "si se va a usar 
la capa de base de datos de Django (modelos), se debe crear una aplicación de 
Django. Los modelos deben vivir dentro de una aplicaciones". Para crear una
aplicación se debe proceder con el procedimiento ya mencionado en :ref:`Módulo
manage <django-proyecto-manage>`.

.. _django-orm-modelos:

Modelos
=======

Un modelo de Django es una descripción de los datos en la base de datos,
representada como código de Python.

Esta es la capa de datos -- lo equivalente a sentencias SQL -- excepto que están
en Python en vez de SQL, e incluye más que sólo definición de columnas de la
base de datos. Django usa un modelo para ejecutar código SQL detrás de las
escenas y retornar estructuras de datos convenientes en Python representando las
filas de las tablas base de datos. Django también usa modelos para representar
conceptos de alto nivel que no necesariamente pueden ser manejados por SQL.

Django define los modelos en Python por varias razones: 
    
    * La introspección requiere ***overhead*** y es imperfecta. Django necesita
        conocer la capa de la base de datos para porveer una buena API de
        consultas y hay dos formas de lograr esto. Una opción sería la 
        introspección de la base de datos en tiempo de ejecución, la segunda y
        adoptada por Django es describir explícitamente los datos en Python.
    
    * Escribir Python es divertido, y dejar todo en Python limita el número de
        veces que el cerebro tiene que realizar un "cambio de contexto".
    
    * El codigo que describe a los modelos se puede dejar fácilmente bajo un
        control de versiones.
    
    * SQL permite sólo un cierto nivel de metadatos y tipos de datos basicos, 
        mientras que un modelo puede contener tipos de datos especializado. La
        ventaja de un tipo de datos de alto nivel es la alta productividad 
        y la reusabilidad de código.
    
    * SQL es inconsistente a través de distintas plataformas.

Una contra de esta aproximación, sin embargo, es que es posible que el código
Python quede fuera de sincronía respecto a lo que hay actualmente en la base. Si
se hacen cambios en un modelo Django, se necesitara hacer los mismos cambios dentro
de la base de datos para mantenerla consistente con el modelo.

Finalmente, Django incluye una utilidad que puede generar modelos haciendo
introspección sobre una base de datos existente. Esto es útil para comenzar
a trabajar rápidamente sobre datos heredados.

Este modelo de ejemplo define una ``Persona`` que encapsula los datos
correspondientes al ``nombre`` y el ``apellido``.

.. code-block:: python

    from django.db import models

    class Persona(models.Model):
        nombre = models.CharField(max_length = 30)
        apellido = models.CharField(max_length = 30)

``nombre`` y ``apellido`` son atributos de clase

.. code-block:: sql

    CREATE TABLE miapp_persona (
        "id" serial NOT NULL PRIMARY KEY,
        "nombre" varchar(30) NOT NULL,
        "apellido" varchar(30) NOT NULL
    );

En el ejemplo presentado se observa que un modelo es una clase Python que hereda
de ``django.db.models.Model`` y cada atributo representa un campo requerido por
el módelo de datos de la aplicación.
Con esta informacion Django genera automaticamente la :term:`API` de acceso a
los datos en la base. 

Usando la API - Consultas
-------------------------

Luego de crear los modelos y sincronizar la base de datos :ref:`<django-comandos-syncdb>` 
generando de esta manera el SQL correspondiente se esta en condiciones de usar 
la API de alto nivel en Python que Django provee para accesar los datos::

    >>> from models import Persona
    >>> p1 = Persona(nombre='Pablo', apellido='Perez')
    >>> p1.save()
    >>> personas = Persona.objects.all()
    
En estas lineas se ven algunos detalles de la interaccion con los modelos:

    * Para crear un objeto, se importa la clase del modelo apropiada y se crea
        una instancia pasándole valores para cada campo.

    * Para guardar el objeto en la base de datos, se usa el método ``save()``.

    * Para recuperar objetos de la base de datos, se usa ``Persona.objects``.

Internamente Django traduce todas las invocaciones que afecten a los datos en
secuencias ``INSERT``, ``UPDATE``, ``DELETE`` de SQL

.. _django_managers:

Administradores de consultas
----------------------------

Estos objetos representan la interfase de comunicacion con la base de datos. Cada modelo tiene por lo menos un
administrador para acceder a los datos almacenados.

Cada entidad presente en el modelo de una aplicación django (de aquí en adelante, simplemente modelo), tiene al menos un *Manager*. Este *Manager* encapsula en una semántica de objetos las opreaciones de consulta (*query*) de la base de datos [*]_ . Un *Manager* consiste en una instancia de la clase *django.db.models.manager.Manager* donde se definen, entre otros métodos, *all()*, *filter()*, *exclude()* y *get()*.


Cada uno de éstos métodos genera como resultado una instancia de la calse *QuerySet*. Un *QuerySet* envuelve el "resultado" de una consulta a la base de datos. Se dice que envuelven el "resultado" porque la estrategia de acceso a la base de datos es *evaluación retardada* [*]_, es decir, que la consulta que representa el *QuerySet* no será evaluada hasta que no sea necesario acceder a los resultados.


.. [*] En el lenguaje SQL, las consultas se realizan miediante la sentecia SELECT.
.. [*] También conocida como *Lazy Evaluation*

El siguiente ejemplo utiliza el manager *objects* que agrega de manera automática el ORM al modelo Usuario. En este caso, se consulta por todas las instancias de la entidad usuario.

.. code-block:: python

    Usuario.objects.all()
    
El ORM se encarga de transformar la invocación al método *all()* por el SQL siguiente.

.. code-block:: sql

    SELECT * FROM aplicacion_usuarios

.. Esto es recursivo y dificil de explicar :S

Un *QuerySet*, además de presentar la posibilidad de ser iterado, para recuperar los datos, también posee una colección de métodos orientados a conuslta, como *all()*, *filter()*, *exclude()* y *get()*. Cada uno de estos métodos, al igual que en un mánager, devuelven instancias de *QuerySet* como resultado. Gracias a esta característica recursiva, se pueden generar consultas medinate encadenamiento.


.. code-block:: python
    
    # datetime.now() devuelve un objeto datetime con la fecha y hora actual
    r = Publicaciones.objects.filter( encabezado__stastswith = "Impuesto")
        .exclude( fecha_publicacion__lte = "2009/03/02" )
    print r
    
es equivalente a:
.. Esto no se si está bien

.. code-block:: sql
    
    SELECT * FROM aplicacion_publicaciones WHERE encabezado LIKE "Impuesto%" 
    AND NOT fecha_publicacion >= "2009/03/02"
    
    
.. Acá tenemos que hablar de la API de consutlas

API de consultas
=================

Dado la siguiente definición de modelo

.. code-block:: python

    class Persona(models.Model):
        nombre = models.CharField( max_length = 80 )
        apellido = models.CharField( max_length = 140 )
        fecha_de_nacimiento = models.DateField()
        
        
    class Automovil(models.Model):
        ''' Un automovil posee un propietario '''
        
        modelo = models.IntegerField()
        marca = models.ForeignKey( Marca )
        
        propietario = models.ForeignKey( Persona )
    
    class Marca(models.Model):
        nombre = models.CharField( max_length = 40 )
    
el ORM agrega a cada modelo la propiedad *objects*:

.. code-block:: python
    
    >>> Persona.objects
    <django.db.models.manager.Manager object at 0x9e5d44c>
    >>> Marca.objects
    <django.db.models.manager.Manager object at 0x7efc002>
    >>> Automovil.objects
    <django.db.models.manager.Manager object at 0xa0edb07>