.. _capitulos-protopy:

#######
Protopy
#######


.. note:: 

    Ver donde poner estos dos parrafos, que estan buenos pero creo que no van aca :)

    En apartados teóricos se menciono, entre otras cosas, que la creación de un
    framework generalmente surge de la identificación de objetos reusables en
    el desarrollo de software. Posteriormente los objetos identificadas decantan en
    componentes que forman parte de la arquitectura del framework y a los cuales se
    accede mediante la extención y la configuración.
    Esta forma de obtener un producto que permita arquitecturar proyectos de
    caracteristicas similares a los que lé dieron origen, implica pasar por varias
    etapas de maduración en el desarrollo, pero requieren de un punto de partida
    primordial y es justamente un proyecto que oriente la identificacion de las
    partes reusables. Nuestro caso se complica en este punto, ya que la intención
    panteada desde el principio es la de "desarrollar un framework" y la realidad
    del desarrollo es que muchas de las partes surguieron en paralelo y de la mano
    de aplicaciones de prueba.

El presente capítulo profundiza sobre el desarrollo de la librería de JavaScript
sobre la cual se implenta una versión desconectada de Django. Como se mencionó
en el capítulo anterior, si bien JavaScript en sus versiones 1.7 y 1.8 incorpora
muchos elementos que acercan su sintaxis a la de Python, fue 
necesario implementar una capa intermedia entre JavaScript y Django "desconectado".
Una de las razones mas relevantes es emular la API estándard de Python.

.. note::
    No quedaron más que ideas de prototype en protopy :P

La biblioteca se basó en el código fuente de Prototype, sobre la cual se fue agregando
y sustituyendo código. El resultado de esta modificación se bautizó en honor a 
sus dos "padres", por un lado *Portotype JavaScript Library* y el lenguaje de programación
*Python*:

    | **proto** type + **py** thon = **protopy**


Objetivos de la Librería
------------------------

* Modularización y ámbito de nombres.

    Un framework con funciones minimas, como una API de base de datos y un motor
    de plantillas, requiere una cantidad considreable de código. Django por ejemplo
    consta de cerca de 43000 líneas, sin contar las aplicaciones 
    contribuidas (administración, GIS, data, sesiones, autenticación, bitácora) [*]_.
    En particular, para migrar un framework implementado sobre Python, el sistema
    de paquetes es muy importante. En Python los módulos definien ámbitos de nombres
    de los cuales se pueden importar selectivamente sólo los símbolos usados, sin
    contaminar el ámbito local.

* Orietnación a Objetos "Pythonica"

    En JavaScript, cada prtotipo almacena la estrctura estática de la "clase"
    y en el constructor se inicializa la instancia. En Python, la creación 
    de la clase la realiza el método ``__new__`` y la inicialización, el 
    método ``__init__``. Python permite herencia múltiple y la definición
    dinámica de tipos a través de metaclases o mediante el builtin ``type`` 
    (que sirve como factory). Es necesario para adaptar el código
    Python a JavaScript, definir los tipos base ``object`` y ``type`` debido
    a que piezas claves de Django como el ORM y el sistema de formularios
    basan su funcionamiento en estos builtins.

    En Python también se pueden definir métodos especiales en las clases, que permiten
    sobrecarga de operadores (``+`` mediante ``__add__``,
    ``==`` mediante ``__eq__``,
    ``&`` y ``^`` medinate ``__and__`` y ``__or__``,
    los paréntesis de invocación ``()`` mediante ``__call__``, etc). Algunos de
    estos se pueden emular en JavaScript y Protopy brinda facilidades para esto.

* Tipos de datos y ``builtins``

    Existen ciertos tipos que no existen en JavaScript con la misma funcionalidad
    que en Python. Un caso puntual son los ``Object`` o arreglos asociativos 
    comparados con el tipo de datos ``dict``.

    En Python el conjunto de funciones, tipos disponibles en el ámbito de nombres global
    se conoce como ``builtins``. Forman parte de este conjunto,
    ``int``, ``bool``, ``str``, ``list``, ``tuple``, ``map``, ``filter``, 
    ``abs``, ``all``, etc. La mayoría de estos símbolos fueron portados a Protopy 
    y también publicados en el ámbito global.

* Selección de elementos mediante CSS

    DOM permite realizar búsqueda de elementos dentro de un documento de 
    tres maneras: mediante un identificados, mediante un nombre de tag, o
    el acceso gerárquico tipo árbol (estas técnicas se pueden combinar).

    Los selectores CSS simplifcan la tarea de seleccionar un conjunto de 
    elementos que cumple con cierta condición. Utilizan la sintaxis de
    las hojas de estilo en cascada para determinar los elementos que
    están siendo seleccionados.
    Por ejemplo
    con la API de DOM seleccionar todos los elementos del tipo link, que
    posean un atributo ``href`` se realiza de la siguiente manera:

    .. code-block:: javascript

        var links = document.getElementsByTagName('a').
            filter( function (e) { return e.getAttribute('href'); });

    Mientras que con selección CSS, esto se reduce a:
    
    .. code-block:: javascript
    
        var links = $$('a[href]');
       
    Las librerías YUI, Protype, jQuery, Dojo, Ext JS entre otras poseen este
    tipo de selector. Su utilización libra al desarrollador de incompatiblidades 
    o implementaciones pobres de DOM, a la hora de interacturar con los elementos
    del documento. 


.. [*] Métrica obtenida de el comando 
    ``wc -l $(find django -iname "*.py" | grep -v contrib | grep -v backends)``
    

Compatibilidad de Protopy
~~~~~~~~~~~~~~~~~~~~~~~~~

JavaScript 1.7 solo se encuentra disponible sobre la plataforma Mozilla
(Firefox 3.0+), de modo que se quitaron  
gran parte de los arreglos de compatibilidad presentes originalmente en Prototype
y se portó a la nueva sintaxis muchas partes del código original. 

.. _protopy-modulos:

Utilización de la Biblioteca
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

La librería Protopy consiste en un único recurso JavaScript llamado
``protopy.js``. Su inclusión debe realizarse en la cabcecera del documento.

.. code-block:: javascript

    <script type="text/javascript;version=1.7" src="/ruta/a/protopy/protopy.js">
    </script>

Dentro del atributo ``src`` se define lo que se denomina *ruta base* y consiste
en la gerarquía de directorios */ruta/a/protopy/* en el ejemplo expuesto.

Argumentos de Inicialización
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Dentro del atributo ``src`` de la etiqueta script de inclusión de Portopy, se pueden
pasar argumentos en la URL. Por ejemplo::
    
    src="/ruta/a/protopy/protopy.js?argumento=valor&argumento=valor"
    
Existen algunos argumentos utilizados por el framework desconectado que se 
analizaran en el capítulo siguiente.
    


Organización del Código
=======================

Como se mencionó en el apartado teórico dedicado a JavaScript, la inclusión
de código en un documento HTML se realiza mediante el tag ``script`` definiendo
en el atributo ``src`` la URL del recurso. 
Cuando el navegador encuentra estas
etiquetas en el análisis del documento (o *parsing*), descarga el recurso y lo
evalúa en el contexto de elemento``window`` (es decir, si en el código se define
una variable ``a`` fuera del bloque de una función, esta pasa a ser miembro
del objeto ``window``).
 
La cárga de JavaScript mediante tags de inclusión es práctico para proyectos pequeños
(donde se uitiliza JavaScript para validación, enriquecimeinto de formularios, accesibilidad) 
pero resulta limitado y poco mantenible cuando la cantidad de JavaScript crece.

En Protopy se buscó la forma de solucionar este problema analizando la forma
en la que se resuelve en el lenguaje Python, donde la modularidad y 
la creación de ámbitos de nombres están intimamente relacionados.

.. note::
    No, no la inclusion de js asincronica viene de la mano de dojo

En vez de cargar los recursos mediante la inclusión de tags, se tomó la idea 
de la carga asincrónica de código de Kris Kowal [KrisKowal09]_, también
presente en YUI [YahooYUILoader09]_, donde se utiliza una función de inclusión
que genera peticiones XmlHTTPRequest a los recursos y los evalua cuando se
completan.


.. [KrisKowal09] Kris Kowal,
                Proyecto module.js,
                útlimo acceso Septiembre 2009,
                http://modulesjs.com/

.. [YahooYUILoader09] YUI Team,
                Documentación del módulo YUI Loader,
                último acceso Septiembre 2009,
                http://developer.yahoo.com/yui/yuiloader/

Se agregó al ámbito global la función ``require( "nombre_modulo" )`` que recibe
como cadena el nombre del módulo que se desea cargar y lo descarga asincronicamente
para luego evaluarlo un contexto aislado.

.. http://www.gulic.org/almacen/diveintopython-5.4-es/html_processing/locals_and_globals.html

En Protopy, un módulo es un recurso JavaScript que publica explicitamente una interfase. 
De esta manera la funcionalidad se encuentra encapsulada. Para publicar un elmento
del módulo se utiliza la función ``publish({nombre: objeto, nombre: objeto})``.
 
Además de cargar el módulo, la función ``require()`` se encarga publicación en
el ámbito local a la invocación de los símbolos que sean publicados mediante ``publish()``.
Durante la evaluación se encuentra disponible la variable ``__name__`` que 
tiene como valor el nombre del módulo que se está evaluando.

Los módulos se pueden organizar geraquicamente en directorios, a las cual se
denomina paquetes. El comando ``require("a.b")`` carga el elemento ``b`` del
paquete ``a``, siendo ``a`` un directorio con un archivo ``b.js`` en el servidor.

Cuando se utilizan paquetes, a diferencia de Python, estos no incluye funcionalidad
per se [*]_ la única función de estos es la de establecer estructura.

.. [*] En Python, un paquete es un direcotrio que tiene un módulo llamado
    ``__init__.py``, donde se puede definir funcionalidad que es evaluada
    si se realiza la importación del paquete tal si fuese un módulo (Ej:
    ``import paquete``)

Carga de Módulos
----------------

Cuando se utiliza la función ``require`` la búsqueda de los módulos se realiza
en la *ruta base*. Esta se estableció como el subdirectorio ``packages``
a partir de la ruta desde la cual se cargó la librería Protopy.
Por ejemplo, si ``protopy.js`` se encuentra en ``http://dominio.com/media/js/protopy.js`` 
la invocación ``require("dom")`` cargará el archivo ``dom.js`` desde  
``http://dominio.com/media/js/packages/dom.js``.

La búsqueda de módulos se puede ampliar más allá de la ruta base. En el módulo
``sys`` existe la variable ``paths``, que consiste en una lista de rutas en
las cuales se realiza la búsqueda cuando el módulo no se encuentra en la ruta 
base. El programador puede añadir entradas a ``sys.path``.

La función ``require`` se puede usar para:

    * Obtener un modulo como un objeto,

        .. code-block:: javascript

            var mod = require('events');

        .. code-block:: javascript

            require('events');  // Events queda en el espacio global


    * Obtener un símbolo de un modulo

        .. code-block:: javascript

            require('events', 'Event');    

    * O se pueden importar todas las definiciones del módulo en el espacio de
      nombres del llamador.

      .. code-block:: javascript

            require('events', '*');

Una descrpición detallada se encuentra en el apendice dedicado a Protopy.

Publicación de Módulos
----------------------

En Python no es necesario declarar de manera expícita que símbolos se exponen
en un módulo, ya que todas las definiciones son públicas. Por ejemplo, si
se define un módulo ``utils.py`` con el siguiente código:

.. code-block:: javascript

    def promedio(lista_de_enteros):
        return sum(lita_de_enteros) / float(len(lista_de_enteros))
    
    def cantidad_palabras(linea):
        return len(linea.split())

el programador puede usar las sentencias ``from utils import promedio`` que
incorpora la función promedio al ámbito de nombres local, 
``from utils import *`` que incorpora todas las funciones de ``utils`` al ámbito
de nombres o simplemente ``import utils``, que incorpora el módulo, el cual
tiene como miembros en este caso a ``promedio`` y a ``cantidad_palabras``.

En cambio los módulos en Protopy se evaluan dentro de una clausura y los 
llamadores no podran acceder a sus funciones si no son publicadas. 

La funcion ``publish`` es la encargada de relizar la tarea de publicar el
contenido del modulo.

A continuación se presenta un fragmento de código que ejemplifica el uso de las 
dos funciones presentadas sobre un código simimlar al de listado en Python:

.. code-block:: javascript
    :linenos:

    function promedio(lista_de_enteros) {
        var suma = 0;
        for (int i = 0; i < lista_de_enteros.length; i++){
            suma += lista_de_enteros[i]
        }
        return suma / lista_de_enteros.length;
    }
    
    function contar_palabras(linea) {
        return linea.split(' ').length
    }
    
    publish({
        promedio: promedio,
        contar_palabras: contar_palabras
    });

Modulos Nativos
---------------

Como se introdujo al principio del capítulo anterior, es necesario que la 
implementación de Python que se utilize en el navegador como soporte para
Django, posea algunos módulos de la API standard de Python.
  
.. note:: 
    Describir de forma rápida los módulos principales

    * builtin

        Este módulo cuenta con los tipos y funciones disponibles en 
        el ámbito global ni bien se inicia el intérprete de Python.
        Está constuida por los tipos básicos, las funciones
        como ``filter``, ``sum``, ``map``, etc.

    * dom

        Funciones de envoltura de DOM.

    * sys

        Equivalente al módulo Python del mismo nombre. Maneja las rutas
        de cargas de módulos.

    * event

        Manejo de eventos, implementación de Listeners y Publisher/Subscriber.

    * ajax

        Envoltura de ``XMLHttpRequest``, facilidades de interpretación de tipos
        de respuesta.

    * exceptions

        Conjunto de excepciones.

    * timer

        Envoltura de ``window.setTimer()`` y ``window.setInterval()``. 



.. _protopy-tipos:

Orientación a Objetos Basado en Clases
--------------------------------------

En el capítulo dedicado a las tecnologías del cliente se introdujo en
el enfoque OO que posee JavaScript. Para lograr migrar muchos componentes
de Django a JavaScript, se requiere un sistema de objetos basado en clases.
Muchos autores cuestionan intentar imponer un sistema de clases sobre
un lenguaje que ya posee su técnica para crear objetos, argumentando que no 
tiene sentido emular un paradigma dentro de otro. Se llegó a la conclusión
que tanto para la presente tesina como para acercar a los programadores
que utilizan Django al lenguaje JavaScript/Protopy era neceario proveer 
un sistema de tipos similar al de Python. Prototype  hace lo propio con el 
lenguaje Ruby.

La forma de crear nuevos "tipos de objetos" en Protopy es a traves de la función
``type``. Esta funcion no fue parte de la biblioteca hasta que no se observó la
necesidad de otrogar mayor poder al constructor de clases que brindaba
Prototype. Su aparición posibilito nuevas formas de construir clases, 
similares a las  que brinda la funcion homónima en Python, a la cual debe su nombre.

A continuación se presenta un fragmento de código que ejemplifica la creación de
una clase en Protopy.

.. code-block:: javascript
    :linenos:

    // Creación de un diccionario, que hereda del tipo object
    var Dict = type('Dict', object, {
        ...
    });
    // Creación de una clase que hereda de Dict, observar que es una lista ya
    // se permite herencia múltiple.
    var SortedDict = type('SortedDict', [ Dict ], {
        __init__: function(object) {
            this.keyOrder = (object && isinstance(object, SortedDict))? \
                copy(object.keyOrder) : [];
            super(Dict, this).__init__(object);
        },
        // Iterador, retorna pares clave, valor
        __iter__: function() {
            for each (var key in this.keyOrder) {
                var value = this.get(key);
                var pair = [key, value];
                pair.key = key;
                pair.value = value;
                yield pair;
            }
        },
        // Método utilizado para la copia profunda
        __deepcopy__: function() {
            var obj = new SortedDict();
            for (var hash in this._key) {
                obj._key[hash] = deepcopy(this._key[hash]);
                obj._value[hash] = deepcopy(this._value[hash]);
            }
            obj.keyOrder = deepcopy(this.keyOrder); 
            return obj;
        },
        // Alias del método toString, sirve para representar en una cadena
        // a la instancia
        __str__: function() {
            var n = len(this.keyOrder);
            return "%s".times(n, ', ').subs(this.keyOrder);
        },
        // Setter
        set: function(key, value) {
            this.keyOrder.push(key);
            return super(Dict, this).set(key, value);
        },
        unset: function(key) {
            without(this.keyOrder, key);
            return super(Dict, this).unset(key);
        }
    });

Este ejemplo presenta la definición del tipo ``SortedDict`` o diccionario
ordenado, el cual es una especialización del tipo base ``Dict``.
Como se observa, la función constructora recibe como primer argumento el nombre
para el nuevo tipo, seguidamente un arreglo con los tipo base y por último 
un arreglo asociativo con los atributos y metodos para los objetos de ese tipo.

Con los constructores así definidos es posible instancias que se
comporten en función de sus respectivas definiciones.

.. code-block:: javascript

    >>> d = new SortedDict({'uno': 1})
    >>> d.set('dos', 2)
    >>> d.get('dos')
    2
    >>> d.items()
    [["uno", 1 ], ["dos", 2 ]]

Como se observa, para instanciar un nuevo tipo se utiliza el operador `new` de
JavaScript, este operador crea el nuevo objeto e invoca a la función `__init__`.

En los métodos la palabra reservada `this` tiene el comportamiento esperado,
presentado en la parte teorica, el cual es hacer referencia al objeto
instanciado con ``new``.

Internamente ``type`` utiliza el objeto ``prototype`` para la construcción, con lo
cual el operador ``instanceof`` presenta un comportamiento coherente, pese a esto
se recomienda usar la funcion ``isinstance`` disponible como builtin en Protopy,
ya que esta permite navegar por la cadena de herencia.

.. code-block:: javascript

    >>> d instanceof SortedDict
    true
    >>> d instanceof Dict
    false
    >>> isinstance(d, Dict)
    true

Inicialización
--------------

En el ejemplo se muestra la inicialización del tipo ``SorteDict`` usando una funcion
``__init__``. Este método es llamado por el operador ``new`` inmediatamente
despues de crear una instancia. Actua de una fomra simliar a un constructor del
lenguaje Java, pero Python y Protopy permiten también la personalización de la 
instanciación implementando el método ``__new__``. El constructor es el conjunto
``__new__`` e ``__init__``.

Los métodos ``__init__`` deben llamar explícitamente al método ``__init__`` de 
la(s) clase(s) padre(s) de ser necesario.

Métodos Especiales
------------------

Protopy prevee algunos métodos especiales para los objetos, estos en lugar de 
ser llamarlos directamente, se invocan por la biblioteca en circunstancias 
particulares o cuando se use una sintaxis específica.

    * ``__str__``

        Este metodo se llama cuando es necesario proveer de una reprecentacion
        en texto del objeto, JavaScript provee para este objetivo el metodo
        ``toString``, pero por compatiblidad con Python y consistencia con 
        la filosofía de Portopy de apegarse a la estrcutra de Python se recomeinda
        utilziar el nombre ``__str__``.

    * ``__iter__``

        Protopy se vale de versiones modernas de JavaScript para brindar 
        este método, la funcion debe retornar un objeto que implemente el metodo 
        ``next``, los bucles ``for`` hacen esto automáticamente, por ejemplo::
        
            for (var elem in objeto_iterable) {
                print (elem)
            }
        
        
    * ``__cmp__``

        Llamado al comparar dos instancias de tipo con las funciones ``equal`` o
        ``nequal``.

    * ``__len__``

        Se invoca con la llamada a la funcion `len`. La función incorporada len
        devuelve la longitud de un objeto. Funciona sobre cualquier objeto posea
        longitud (listas, diccionarios, etc.)::
            
            >>> len([1, 2, 4])
            3

    * ``__copy__`` y ``__deepcopy__``
    
        Se utiliza para copiar un objeto de manera superficial o profunda
        respectivamente.
        
    * ``__json__`` y ``__html__``
    
        Métodos para serialización (o *marshalling*) del objeto en HTML o 
        JSON respectivamente.

Protopy tiene otros métodos especiales, general todos estos orientados a emular
algun comportambiento de Python en JavaScript. 

Herencia
--------

Como ya se mencionó, el codigo de un framework no debe ser modificado.
El mecanismo de extensión en lenguajes OO es la especialización de componentes
mediante herencia. Por esta razón se consideró fundamental dotar el 
constructor de tipos ``type`` de la capacidad de herncia similar a la de Python,
ya lo que se intenta migrar es un framework OO escrito en Python.

Cuando el desrrollador implemente funcionalidad basada en las características
del framework desconectado, lo hará extendiendo alguna clase.

.. 
    herencia al constructor de tipos resulta un paso en la dirección correcta,
    eventualmente el desarrollador que requiera componentes especificos podra
    heredar de los tipos correspondientes e implementar solo lo que haga falta.

Protopy utiliza la herencia del tipo **Prototype chaining**, aunque lo hace de
una forma un poco más compleja con el objeto de soportar herencia múltiple.

.. note:: Hasta acá

Para implementar la herencia y en particular la herencia multiple, el contructor
de tipos recibe una lista de los tipos base e internamente crea un
objeto que agrega de derecha a izquierda todos los metodos de las bases,
posteriormente crea el tipo requerido tomando como base el objeto generado. Es
en este punto donde se pierde el poder del operador ``instanceof`` y es por eso
que Protopy provee una funcion para determinar la correspondencia entre
instancias y tipos llamada ``isinstance``.

Otra funcion importada de Python es ``issubclass``, bajo algunas
condiciones resulta util determinar si un tipo es una sub-clase de otro y para
ello esta funcion inspecciona la cadena de herencia.
.. 
    Bien, ya se tiene un mecanismo de herencia casi completo, solo falta ver como se
    accede a las funciones de tipos base cuando se esta redefiniendo un método, para
    esto existe la funcion ``super``, nuevamente y similar a Python esta función
    asocia un tipo con una instancia, con lo cual logra el objetivo de llamar a un
    método que se encuentre en un tipo base. Este comportamiento, es el equivalente,
    en JavaScript, al de llamar al metodo del tipo base con la funcion ``apply`` o ``call``.

Para acceder a las funciones de tipos base cuando se esta redefiniendo un método
 existe la funcion ``super``. De manera similar a Python, esta función
determina el tipo de la instancia, y mediante este accede al método buscado.
Este comportamiento es el equivalente en JavaScript al de llamar al metodo 
del tipo base con la funcion ``Function.apply`` o ``Function.call``.

Se debe destacar que de no especificar por lo menos un tipo base, 
Protopy establce por defecto a `object`, ecargado de
proveer los principales métodos (``__init__``, ``__str__``).

Metodos y Atributos de Clase
----------------------------

Protopy contempla la definción de métodos y atributos de clase. Esta tarea serealiza
agregando el conjunto de atributos y metodos de calse como un arreglo asociativo
opcional que se antepone al que define la estrcutra de los de instancia.

.. code-block:: javascript

    var Planeta = new type('Planeta', [ object ], {
        // Atributos y metodos de clase
        count: 0,
        reset: function() {
            this.count = 0;
        }
    }, {
        // Atributos y metodos de instancia
        __init__: function(name) {
            this.name = name;
            this.count = Planeta.count++;
            // Otra forma puede ser con this.__class__.count++
        }
    });

El ejemplo presentado define el tipo "Planeta", este tipo internamente lleva un
contador que las instancias utilizan para numerarse en la construccion y una
función de ``reset`` para reiniciar el contador. Dentro de los métodos de clase la
palabra reservada ``this``, hace referencia a la clase.

A continuacion se ve como usar el clase.

.. code-block:: javascript

    // Creamos una instancia
    >>> p = new Planeta('Tierra')
    window.Planeta name=Tierra count=0 __name__=Planeta
    // Volvemos a cero al conteador mediante el método de clase reset()
    >>> Planeta.reset()
    // Creamos la estrella Sol
    >>> sol = new Planeta('Sol')
    window.Planeta name=Sol count=0 __name__=Planeta __module__=window
    // Creamos el planeta Mercurio
    >>> mercurio = new Planeta('Mercurio')
    window.Planeta name=Mercurio count=1 __name__=Planeta
    // Creamos el planeta Venus
    >>> venus = new Planeta('Venus')
    window.Planeta name=Venus count=2 __name__=Planeta
    // Creamos el planeta Tierra
    >>> tierra = new Planeta('Tierra')
    window.Planeta name=Tierra count=3 __name__=Planeta



.. Existe una funcion muy importante que se puede definir para el tipo, buscando la
   emulacion de Python se adopto el metodo ``__new__``. Este metodo permite al
   desarrollador tomar parte en la constuccion del tipo, los parametros son de una
   forma similar a Python, el nombre del nuevo tipo, el arreglo con los tipos base
   y el objeto con atributos y metodos de instancia. 

Objetos Nativos
---------------

Los objetos nativos tienen como objetivo emular un tipo de datos de Python o
realizar una adaptación de sintaxis.  

    * Dict

        Si bien un arreglo asociativo nativo de JavaScript se comporta
        de manera similar a un diccionario de Python (``dict``),
        los diccionarios de Protopy permiten mejores formas de trabajar con la
        dupla clave-valor, posibilitando ademas el uso de objetos como claves en
        lugar de solo cadenas.

    * Set

        Los Sets son listas de objetos de los cuales existe una única instancia
        de cada elemento como máximo. Permiten realizar operaciones de 
        conjuntos como union, intersección, diferencia, etc.
        Este tipo es una adaptación del tipo ``set`` de Python.

    * Arguments

        Las funciones en JavaScript pueden recibir opcionalmente cualquier
        cantidad de argumentos, los objetos del tipo Arguments encapsulan y
        uniforman los argumentos pasados a una funcion y permiten establecer
        entre otras cosas valores por defecto. 

Extendiendo DOM y JavaScript
----------------------------

Si bien el :term:`DOM` ofrece ya una :term:`API` muy completa para acceder,
añadir y cambiar dinámicamente el contenido del documento HTML, existen
funciones muy utiles y comunes en los desarrollos que los programadores
incorporan al HTML y se intentaron englobar y mantener dentro del nucleo de
Protopy. Funciones para modificar e incorporar elementos al documento son muy
comunes y estan disponibles en Protopy, en conjunto con otras para el manejo de
formularios, como serializacion, obtencion de valores, etc.

Otra extension interesante de mencionar es la de los tipos de datos en
JavaScript, en manejo de cadenas incorpora nuevas funciones que simplifican
tareas comunes, los numeros y fechas tambien tiene su aporte.

Los eventos estan uniforamdos bajo un modulo de manejo de eventos, que permite
conectar eventos del :term:`DOM` con funciones en JavaScript, así tambien como
funciones entre si.

.. note:: 
    Poner los nombres de las funciones para destacar el laburo

Envolviendo a gears
-------------------

La biblioteca puede funcionar independiente de la instalación de Google Gears,
debido a que su principal funcionalidad como ya se menciono es la de extención
de
JavaScript y posterior soporte al framework, pese a esto Protopy provee
mecanismos para uniformar el acceso y extender los objetos de Gears cuando éste
se encuentra instalado en el navegador.

El acceso al `Factory` de Gears esta centralizado y controlado en el objeto
`gears` dentro del modulo `sys`, mediante este objeto es posible conocer el
estado de Gears y sus permisos. El objeto informa al desarrollador si Gears esta
instalado, la versión, si los permisos son corrector e incluso simplifica
el proceso de instalación de la extensión de no estar presente en el navegador
entre otras cosas.

El metodo `create` del objeto `sys.gears` es el encargado de crear y retornar
los objetos Gears. Esta función se ayuda de módulos presentes en el paquete
`gears` para asistir la creación de los objetos. El objeto que se retorne
dependera de la precencia del módulo con el mismo nombre en dicho paquete; de no
encontrar un modulo que asista la cración de un objeto Gears el objeto en sus
estado "puro" es retornado al llamador.

Si bien no es necesario que los módulos obtengan el acceso a Gears a traves de
Protopy, es recomendable que asi se haga; ya que la biblioteca provee los
mecanimos de extención para los objetos en `create`. Esto no fue así desde el
comienzo de del desarrollo y fue una idea que se maduro luego de observar que
resultaba complejo y costoso requerir los módulos que involucraban a Gears
desde distintos lugares.

El desarrollo del framework implico extender algunos objetos Gears,
concretamente
al paquete `gears` se incorporaron los siguientes módulos:

    * desktop

        El objeto `desktop` de Gears permite interactuar con el escritorio del
        cliente. Aquí se extendio la creacción de accesos directos para
        simplificar la generación de los mismos y agregar la posibilidad de
        manejar `Icon` y algunos `IconTheme`.

    * database

        Sobre el objeto `database` se agrego funcionalidad uniformar el acceso a
        la base de datos por los módulos de Protopy y encapsular los `ResulSet`
        en cursores a los que se incorporo iteradores, registro de funciones
        para tipos de datos, etc.

Auditando el codigo
-------------------

Una queja recurrente de los desarrolladores que trabajan con JavaScript es lo
complejo que resulta el lenguaje para depurar errores. Encontrar errores en
el código resulta molesto y mas todavía si la salida de los mismos no esta en un
formato adecuado y encausada en un lugar especifico.

Tradicionalmente lo que se hace para detectar errores es valerse de funciones
`alert` diseminadas por el código con textos del estilo "Paso por aquí", pero
luego de cerrar unas diez o quince ventanas de este estilo, generalmente se
pierde referencia de donde esta ocurriendo el error y se cae en la tentación de
comenzar a comentar alerts a mansalva esperando dar con el indicado. Este es un
claro ejemplo de que tanto la salida como el sistema de detección de errores es
molesto e infructifero.

Una clara ventaja sobre el sistema tradicional y poderosa herramienta de
desarrollo es el plug-in Firebug, que integra entre otras cosas una consola
JavaScript y un debuger al ambinete del navegador, permitiendo a los
desarrolladores depurar el código mediante puntos de corte, inspección de
variables, etc. En firebug la consola pasa a ser por defecto la principal salida
de errores, gracias a la funcion `console.log` los desarrolladores pueden
redirigir todos los "Paso por aquí" a una salida uniforme e incluso inspeccionar
el valor de las variables.

Protopy lleva la depuración y auditoria del código un paso más lejos, integrando
un sistema de logging propio altamente configurable y con posibilidades de
escribir en diferentes salidas y con diferentes formatos.

Similar a log4j el logger de Protopy trabaja con niveles de prioridad para los
mensajes, distintos manejadores o `Handlers` y salidas en varios formatos. Todo
esto configurable por el desarrollador.

Una vez configurado el sistema de logging, los módulos que requieran auditar el
codigo solo deben requerir un logger en su sespacio de nombre e invocar a sus
funciones.

.. code-block:: javascript

    var logging = require('logging.base');
    var logger = logging.get_logger(__name__);

    ...

    logger.debug('La query: %s\n Los parametros: %s', query, params, {});

En este ejemplo se requiere el módulo `logging` y posteriormente un logger para
el módulo con el nombre __name__, de no encontrar configuración para este módulo
se adopta la configuracion del modulo inmediato superior y asi consecutivamente
hasta tomar la configuración del root logger.

Suponiendo que el módulo del ejemplo se llama doff.db.models.sql el siguiente
archivo de configuracion perapraria este logger en modo DEBUG para auditar el
código en la consola de firebug y en una url con distintos formatos.

.. code-block:: javascript

    {
        'loggers': {
            'root': {
                'level': 'DEBUG',
                'handlers': 'firebug'
            },
            'doff.db.models.sql': {
                'level': 'DEBUG',
                'handlers': [ 'firebug', 'remote'],
                'propagate': true
            },
        },
        'handlers': {
            'firebug': {
                'class': 'FirebugHandler',
                'level': 'DEBUG',
                'formatter': '%(time)s %(name)s(%(levelname)s):\n%(message)s',
                'args': []
            },
            'remote': {
                'class': 'RemoteHandler',
                'level': 'DEBUG',
                'formatter': '%(levelname)s:\n%(message)s',
                'args': ['/loggers/audit']
            },
            'alert': {
                'class': 'AlertHandler',
                'level': 'DEBUG',
                'formatter': '%(levelname)s:\n%(message)s',
                'args': []
            }
        }
    }

.. note:: Poner referencia a firebug

Interactuando con el servidor
-----------------------------

Protopy permite al desarrollador trabajar con AJAX de forma simple y segura,
encapuslando en objetos la lógica de petición y los valores de retorno del
servidor.

Todo lo relacionado con AJAX se encuentra en el modulo `ajax`. El objeto de
transporte para ajax es `XMLHttpRequest` e internamente se salvan las
diferencias que existen entre los distintos navegadores. La forma de realizar
una peticion es creando una instancia del objeto ajax.Request.

.. code-block:: javascript

    new ajax.Request('una/url', {method: 'get'});

La primera opcion es la url de la solicitud, y el segundo parametro es el hash
de opciones, en este caso el metodo a utilizar es GET, si no se especifica, el
metodo por defecto es POST.

Por defecto la respuesta del servidor es asincrona, para este caso se debe
explicitar en el hash de opciones las funciones que manejaran los eventos
disparados.   

.. code-block:: javascript

    new ajax.Request('una/url', { 
        method:'get',
        onSuccess: function(transport){ 
            var response = transport.responseText || "sin texto";
            alert("Success! \n\n" + response); }, 
        onFailure: function(){ 
            alert('Algo esta mal...'); } 
    }); 

En el ejemplo se presentan dos funciones, onSuccess y onFailure, para manejar
los eventos correspondientes. A cada manejador se le pasa un objeto que
representa la respuesta obtenida y que esta en relación con el evento
capturando.

Otros manejadores que se pueden definir son:
    
    * onUninitialized
    * onLoading
    * onLoaded
    * onInteractive
    * onComplete
    * onException 

Todos estos dependen de un estado del objeto `XMLHttpRequest`.

De igual manera que el resto de las opciones es posible agregar parametros a la
peticion, estos pueden ser pasados como un objeto "hasheable" o como una cadena
clave-valor.

Soporte para json
-----------------

La idea detras del soporte para JSON en Protopy es la transimisión de datos
generados offline por el cliente, en el momento de recuperar la conexion con el
servidor el cliente debe serializar los datos y enviarlos al servidor; otro uso
para es el intercambio de mensajes de control.

La transferencia de datos involucra varios temas, uno de ellos y que compete
a este apartado, es el formato de los datos que se deben pasar por
la conexcion; este formato debe ser "comprendido" tanto por el cliente como
por el servidor. Desde un primer momento se penso en JSON como el formato
de datos a utilizar, es por esto que Protopy incluye un modulo para trabajar
con el mismo.

El soporte para JSON se encuentra en el modulo "json" entre los módulos
estandar de Protopy. Este brinda soporte al pasaje de estructuras de datos
JavaScript a JSON y viceversa.

Los tipos base del lenguje JavaScript estan soportados y tienen su
reprecentacion correspondiente, object, array, number, string, etc. pero este
modulo interpreta ademas de una forma particular a aquellos objetos que
implementen el metodo __json__, dejando de este modo en manos del
desarrollador la reprecentacion en JSON de determinado objetos.

Con el soporte de datos ya establecidos en la libreria, el framework solo
debe limitarse a hacer uso de él y asegurar la correcta sincronizacion de datos
entre el cliente y el servidor web, este tema se retomara en el capitulo de
sincronizacion.

XML
---

No existe una razon concreta por la cual se deja de lado el soporte en Protopy
para XML como formato de datos; aunque se puede mencionar la simplicidad de
implementacion de un parser JSON contra la implementacion de uno en XML.
Para el leector interesado agregar el sporte para XML en Protopy consta de
escribir un modulo que realize esa tarea y agregarlo al paquete base.

Ejecutando código remoto
------------------------


.. JSON-RPC http://json-rpc.org/ 
.. XML-RPC http://www.xmlrpc.com/

El RPC (del inglés Remote Procedure Call, Llamada a Procedimiento Remoto) es un
protocolo que permite a un programa de ordenador ejecutar código en otra máquina
remota sin tener que preocuparse por las comunicaciones entre ambos. El
protocolo
es un gran avance sobre los sockets usados hasta el momento. De esta manera el
programador no tenía que estar pendiente de las comunicaciones, estando éstas
encapsuladas dentro de las RPC.

Las RPC son muy utilizadas dentro del paradigma cliente-servidor. Siendo el
cliente el que inicia el proceso solicitando al servidor que ejecute cierto
procedimiento o función y enviando éste de vuelta el resultado de dicha
operación
al cliente.

Hay distintos tipos de RPC, muchos de ellos estandarizados como pueden ser el
RPC
de Sun denominado ONC RPC (RFC 1057), el RPC de OSF denominado DCE/RPC y el
Modelo de Objetos de Componentes Distribuidos de Microsoft DCOM, aunque ninguno
de estos es compatible entre sí. La mayoría de ellos utilizan un lenguaje de
descripción de interfaz (IDL) que define los métodos exportados por el servidor.

Hoy en día se está utilizando el XML como lenguaje para definir el IDL y el HTTP
como protocolo de red, dando lugar a lo que se conoce como servicios web.
Ejemplos de éstos pueden ser SOAP o XML-RPC. XML-RPC es un protocolo de llamada
a
procedimiento remoto que usa XML para codificar los datos y HTTP como protocolo
de transmisión de mensajes.[1]

Es un protocolo muy simple ya que sólo define unos cuantos tipos de datos y
comandos útiles, además de una descripción completa de corta extensión. La
simplicidad del XML-RPC está en contraste con la mayoría de protocolos RPC que
tiene una documentación extensa y requiere considerable soporte de software para
su uso.

Fue creado por Dave Winer de la empresa UserLand Software en asociación con
Microsoft en el año 1998. Al considerar Microsoft que era muy simple decidió
añadirle funcionalidades, tras las cuales, después de varias etapas de
desarrollo, el estándar dejó de ser sencillo y se convirtió en lo que es
actualmente conocido como SOAP. Una diferencia fundamental es que en los
procedimientos en SOAP los parámetros tienen nombre y no interesan su orden, no
siendo así en XML-RPC.[2

