.. _capitulos-protopy:

#######
Protopy
#######

Introducción
============

.. note:: 

    Ver donde poner estos dos parrafos, que estan buenos pero creo que no van aca :)

    En apartados teóricos se menciono, entre otras cosas, que la creación de un
    framework generalmente surge de la identificación de objetos reusables en
    el desarrollo de software. Posteriormente los objetos identificadas decantan en
    componentes que forman parte de la arquitectura del framework y a los cuales se
    accede mediante la extención y la configuración.
    Esta forma de obtener un producto que permita arquitecturar proyectos de
    caracteristicas similares a los que lé dieron origen, implica pasar por varias
    etapas de maduración en el desarrollo, pero requieren de un punto de partida
    primordial y es justamente un proyecto que oriente la identificacion de las
    partes reusables. Nuestro caso se complica en este punto, ya que la intención
    panteada desde el principio es la de "desarrollar un framework" y la realidad
    del desarrollo es que muchas de las partes surguieron en paralelo y de la mano
    de aplicaciones de prueba.

Si bien la intención primaria es la de brindar un prodcuto que permita ejecutar
"aplicaciones desconectadas" en los navegadores, existen aspectos complejos en
el ambiente de un navegador que dificultan el desarrollo y que requieren de una
capa soporte. Entre estas podemos mencionar:

* Organizar y obtener código.

    Un framework con funciones minimas, como una API de base de datos y un motor
    de plantillas, requiere de varias lineas de código para su implementación.
    Es por esto que resulta deseable que existan formas de organizar y obtener
    código en el cliente; liberando así al desarrollador de estas tareas
    tediosas y permitiendole enfocarse en la funcionalidad.

* Reuso y extensión.

    No es una buena practica modificar un framework y su utilizacion debe estar 
    basa en la extención y la configuración. JavaScript es el lenguaje para el
    framework y si se quiere promover el reuso y la extensión es conveniente
    proveer al lenguaje de objetos extensibles o contrucciones que fasilmente
    sean asimiladas por el desarrollador.

* Guerra de los navegadores.

    Si bien se han logrado muchos avanzes con la estandarizacion de APIs, en
    general existen muchas diferencias entre navegadores para trabajar con el
    DOM o con los objetos de JavaScript.
    Una capa uniforme de acceso al DOM, funciones y objetos que trabajen sobre
    APIs heterogeneas, entre otras cosas, resultan buenas herramientas para el
    desarrollo client-side.

* Interacción entre cliente servidor.

    
* La cara visible o vista debe ser fasilmente manipulable por la aplicacion de
usuario.
* Como los datos generados en el cliente son informados al servidor.
* El framework debe brindar soporte a la aplicacion de usuario de una forma
natural y transparente.
* Como se ponen en marcha los mecanimos o acciones que la aplicacion de usuario
define.

En este capitulo se introducen las ideas principales que motivaron la
creacion de una biblioteca en JavaScript, que brinde el soporte necesario al
framework y a buena parte de los items expuestos.

Biblioteca
----------

Protopy es una biblioteca JavaScript para el desarrollo de aplicaciones
web dinamicas. Aporta un enfoque modular para la inclusión de código,
orientación a objetos, manejo de AJAX, DOM y eventos.

Para una referencia completa de la API de Protopy remitase al apandice
:ref:`Protopy <apendices-protopy>`

Historia
--------

Si bien el desarrollo de la biblioteca se mantuvo en paralelo a la del
Framework, existen aspectos basicos a los que esta brinda soporte y permiten
presentarla en un apartado separado como "Una Biblioteca en JavaScript", esta
constituye la base para posteriores construcciones y auna herramientas que
simplifican el desarrollo client-side.

    | **proto** type + **py** thon = **protopy**

"La creación nace del caos", la libreria "Protopy" no escapa a esta
afirmacion e inicialmente nace de la integracion de Prototype con
las primeras funciones para lograr la modularizacion; con el correr de las
lineas de codigo [*]_ el desarrollo del framework torna el enfoque inicial poco
sustentable, requiriendo este de funciones más Python-compatibles se desecha la
libreria base y se continua con un enfoque "pythonico", persiguiendo de esta
forma acercar la semántica de JavaScript 1.7 a la del lenguaje de programacion
Python.

.. [*] Forma en que los informaticos miden el paso del tiempo.

No es arbitrario que el navegador sobre el cual corre Protopy sea Firefox y
mas particularmente sobre la version 1.7 de JavaScript. El proyecto mozilla
esta acercando, con cada nueva versiones del lenguaje, la semantica de
JavaScript a la de Python, incluyendo en esta version generadores e iteradores
los cuales son muy bien explotados por Protopy y el Framework.

.. _protopy-modulos:

Organizando el codigo
=====================

Como ya se vio en la sección dedicada a :ref:`JavaScript <cliente-javascript>`,
una de las formas tradicionales y recomendada de incluir funcionalidad en un
documento HTML es mediante el tag `script`, haciendo una referencia en el
atributo `src` a la url del archivo que contiene el codigo; en una instancia 
posterior, cuando el cliente accede al recurso, carga el archivo con las
sentencias JavaScript y las interpreta en el contexto del documento.

El enfoque tradicional resulta sustentable para pequeños proyectos, donde el
lenguaje brinda mayormente soporte a la interacción con el usuario (validacion,
accesibilidad, etc) y los fragmentos de código que se pasan al cliente son
bien conocidos por el desarrollador, pero en proyectos que implican mayor
cantidad
de funcionalidad JavaScript, con grandes cantidades de código, este enfoque
resulta complejo de mantener y evolucionar en el tiempo. Es por esto que para
Protopy se busco como primera medida una forma de organizar y obtener el código
del servidor que resulte sustentable y escalable.

Similar al concepto de :ref:`modulos en Python <servidor-lenguajes-python>`, el
desarrollo de Protopy se oriento en pequeñas unidades funcionales llamadas
**modulos**.

Además de la sanidad mental que implica organizar el código en distintos
archivos, los módulos representan un cambio muy importante en la obtención de
funcionalidad; ya no es el documento HTML el que dice al cliente que archivo
cargar del servidor, sino que el mismo código interpretado va obteniendo la
funcionalidad a medida que la requiere.

El enfoque modular no es nuevo en programación y basicamente, la implementación
de Protopy, implica llevar el concepto de "divide y vencerás" ó "análisis
descendente (Top-Down)" al hambito de JavaScript.

Un módulo resuelve un problema especifico y define una interfaz de comunicación
para accesar y utilizar la funcionalidad que contiene. Por más simple que
resulte de leer, esto implica que existe una manera de **obtener** un modulo y
una manera de **publicar** la funcionalidad de un modulo, logrando de esta forma
que interactuen entre ellos.

En su forma mas pedestre un módulo es un archivo que contiene definiciones y
sentencias de JavaScript. El nombre del archivo es el nombre del módulo con el
sufijo .js pegado y dentro de un módulo, el nombre del módulo está disponible
como el valor de la variable `__name__`.

Obtener un módulo
-----------------

La función `require` es la encargada de obtener un módulo del servidor e
incorporarlo al :ref:`espacio de nombres <servidor-lenguajes-python>` del
llamador. Por ejemplo, cuando un módulo llamado spam es requerido, Protopy busca
un archivo
llamado spam.js en la url base [*]_, de no encontrar el archivo el error
``LoadError`` es lanzado a la función que requirio el módulo.

.. [*] Ruta base desde la cual la biblioteca Protopy carga los módulos, por
    defecto esta es la url base del archivo protopy.js más el sufijo `packages`.

Otra forma de obtener módulos es usando nombres de **paquetes**. A diferencia de
Python un paquete no incluye funcionalidad en si mismo y su funcionalidad
principal es la de establecer las bases en la cual buscar modulos.
De forma similar a la anterior cuando un módulo llamado foo.spam es importado,
Protopy busca en el objeto sys.paths si existe una url asociada al paquete foo,
de encontrar la url base para foo el archivo spam.js es buscado en esa
ubicación, por otra parte si sys.paths no contiene una url asociada a foo el
archivo foo/spam.js es buscado en la url base. 

El uso del objeto sys.paths permite a los modulos de JavaScript que saben lo
que están haciendo modificar o reemplazar el camino de búsqueda para los
módulos.
Nótese que es importante que el script no tenga el mismo nombre que un
:ref:`módulo estandar <apendices-protopy-modulos>`.

Las formas en que el modulo obtenido es presentado al llamador difiere en
funcion de los parametros pasados a `require`. Estas formas son:

    * Un modulo puede ser obtenido como un objeto,

    * Se puede obtener solo determinada funcion de un modulo,

    * O se pueden importar todas las definiciones del módulo en el espacio de
    nombres del llamador.

Para ver más :ref:`Apendice Protopy <apendices-protopy>`.

Publicar un módulo
------------------

La acción de publicar un modulo implica exponer la funcionalidad que este
define.
En Python no es necesario explicitar que funcionalidad del módulo se expone a
los llamadores, ya que todo lo definido en él es público; pero los módulos en
Protopy se evaluan dentro de una clausura y los llamadores no podran acceder
a sus funciones si no son publicadas. 

La funcion `publish` es la encargada de relizar la tarea de publicar el
contenido del modulo en Protopy.

Un modulo puede contener sentencias ejecutables y definición de funciones,
generalmente las sentencias son para inicializar el módulo ya que estas se
evaluan solo la primera vez que el módulo es requerido a alguna parte y las
definiciones son las que efectivamente seran publicadas como funcionalidad.

A continuación se presenta un fragmento de código que ejemplifica el uso de las 
dos funciones presentadas.

.. code-block:: javascript
    :linenos:

     /* Obtengo la funcion copy y deepcopy del modulo copy
        estas funciones son para copia de objetos
        superficiales y en profundidad respectivamente. */
    require('copy', 'copy', 'deepcopy');

    /* Representa la cantidad maxima de caches */
    var MAX = 1000;

    /* Objeto para guardar las cache */
    var cache = {};

    ...

    /* Estructura de datos que representa a una cache */
    var Cache = type('Cache', [ Dict ], {
        ...
    });

    /* Funcion que retorna una cache */
    function get_cache(name) {
        if (len(cache) > 1000)
            throw new Exception('%s caches creadas'.subs(MAX));
        var c = cache[name];
        if (!isundefined(c)) {
            c = new Cache();
            cache[name] = c;
        }
        return d;
    }

    /* Publico la cantidad maxima de caches
       la funcion para obtener caches. */
    publish({
        MAX: MAX,
        get_cache: get_cache
    });

Asumiendo que el código presentado está en un archivo llamado `caches.js` en
la url base, éste representa un módulo en sí mismo y el acceso se obtiene
mediante la invocación de 'require('caches')'.

.. note:: describir de forma rápida los módulos principales

.. _protopy-tipos:

Creando tipos de objeto
=======================

En el apartado teórico se toco el tema de construcción de objetos en base a
"clases" y de la emulación de herencia en JavaScript. Aunque muchos autores
cuestionan estas practicas alegando, con justa razon, que no tiene sentido
emular un paradigma dentro de otro; en la practica tener una implementación de
objetos tipados en JavaScript ayuda al reuso de código y en gran medida a que
los programadores se acerquen al lenguaje.

La forma de crear nuevos "tipos de objetos" en Protopy es a traves de la función
`type`. Esta funcion no fue parte de la biblioteca hasta que no se observo la
necesidad de otrogar mayor "poder" al constructor de clases que brindaba
Prototype, y su aparcición posibilito nuevas formas de construir tipos, 
similares a las construcciones de tipos que brinda la funcion homónima en
Python, a la cual debe su nombre.

A continuación se presenta un fragmento de código que ejemplifica la creación de
tipos en Protopy.

.. code-block:: javascript
    :linenos:

    var Dict = type('Dict', object, {
        ...
    });

    var SortedDict = type('SortedDict', [ Dict ], {
        __init__: function(object) {
            this.keyOrder = (object && isinstance(object, SortedDict))? copy(object.keyOrder) : [];
            super(Dict, this).__init__(object);
        },
        __iter__: function() {
            for each (var key in this.keyOrder) {
                var value = this.get(key);
                var pair = [key, value];
                pair.key = key;
                pair.value = value;
                yield pair;
            }
        },
        __deepcopy__: function() {
            var obj = new SortedDict();
            for (var hash in this._key) {
                obj._key[hash] = deepcopy(this._key[hash]);
                obj._value[hash] = deepcopy(this._value[hash]);
            }
            obj.keyOrder = deepcopy(this.keyOrder); 
            return obj;
        },
        __str__: function() {
            var n = len(this.keyOrder);
            return "%s".times(n, ', ').subs(this.keyOrder);
        },
        set: function(key, value) {
            this.keyOrder.push(key);
            return super(Dict, this).set(key, value);
        },
        unset: function(key) {
            without(this.keyOrder, key);
            return super(Dict, this).unset(key);
        }
    });

Rapidamente, este ejemplo presenta la definición del tipo SortedDict, el cual es
una especialización del tipo base Dict. Como se observa la función constructora 
recibe, como primer argumento el nombre para el nuevo tipo, seguidamente un
arreglo con los tipo base y para terminar un objeto con los atributos y metodos
para los objetos de ese tipo.

Con estos dos nuevos constructores ya es posible crear "objetos tipados" que se
comporten en función de sus respectivas definiciones.

.. code-block:: javascript

    >>> d = new SortedDict({'uno': 1})
    >>> d.set('dos', 2)
    >>> d.get('dos')
    2
    >>> d.items()
    [["uno", 1 ], ["dos", 2 ]]

Como se observa, para instanciar un nuevo tipo se utiliza el operador `new` de
JavaScript, este operador crea el nuevo objeto e invoca a la funcion __init__.
    
En los métodos la palabra reservada `this` tiene el comportamiento esperado,
presentado en la parte teorica, el cual es hacer referencia al objeto
instanciado con `new`.

Internamente `type` utiliza el objeto `prototype` para la construcción, con lo
cual el operador `instanceof` presenta un comportamiento coherente, pese a esto
se recomienda usar la funcion `isinstance` que trae Protopy, ya que esta permite
navegar por la cadena de herencia.  

.. code-block:: javascript

    >>> d instanceof SortedDict
    true
    >>> d instanceof Dict
    false
    >>> isinstance(d, Dict)
    true

Inicialización
--------------

En el ejemplo se muestra la inicialización del tipo SorteDict usando una funcion
llamada __init__. Este método es llamado por el operador `new` inmediatamente
despues de crear una instancia. Sería tentador decir que es el “constructor”
de la clase. Si bien se parece un constructor de Java, actúa como si lo fuese ya
que el objeto ya esta instanciado cuando se llama a esta función.

Los métodos __init__ pueden tomar cualquier cantidad de argumentos, e igual que
las funciones en JavaScript estos son opcionales para quien invoca.

Los métodos __init__ son opcionales, pero cuando se define uno, se debe recordar
llamar explícitamente al método __init__ del ancestro.

Otros métodos
-------------

    * __str__

        Este metodo se llama cuando es necesario proveer de una reprecentacion
        en texto del objeto, JavaScript provee para este objetivo el metodo
        toString, pero por cuestiones de nombres se prefirio usar este metodo en
        su lugar y hacer internamente una relacion entre las funciones.

    * __iter__

        Protopy se vale de versiones modernas de JavaScript y brinda soporte a
        iteradores, este es el método que el desarrollador debe definir si
        quiere objetos iterable, la funcion debe retornar un objeto que
        implemente el metodo next (un iterador o un generado), los bucles
        for hacen esto automáticamente, pero también se puede hacer manualmente.

    * __deepcopy__
    * __copy__
    * __json__
    * __html__

Los primeros tipos que surgen para la organizacion de datos dentro de la
librerias con los "Sets" y los "Diccionarios", hambos aproximan su
estructura a las estructuras homonimas en python, brindando una funcionalidad
similar. Si bien la estructura "hasheable" nativa a JavaScript en un objeto,
los diccionarios de Protopy permiten el uso de objetos como claves en lugar de
solo cadenas.

Al igual que muchas partes de Protopy `type` cambio a lo largo del desarrollo,
sumando soporte para herencia multiple, metodos magicos e incluso "metatipos".


Arguments

isinstance

Herencia
--------

La función contrcuctora de tipos en la biblioteca surgue como herramienta para
proveer al Framework de mecanismos de extensión.

issubclass

super


Metodos y atributos de tipo
---------------------------


Extendiendo DOM y JavaScript
============================

Si bien el :term:`DOM` ofrece ya una :term:`API` muy completa para acceder,
añadir y cambiar dinámicamente el contenido del documento HTML, existen
funciones muy utiles y comunes en los desarrollos que los programadores
incorporan al HTML y se intentaron englobar y mantener dentro del nucleo de
Protopy. Funciones para modificar e incorporar elementos al documento son muy
comunes y estan disponibles en Protopy, en conjunto con otras para el manejo de
formularios, como serializacion, obtencion de valores, etc.

Otra extension interesante de mencionar es la de los tipos de datos en
JavaScript, en manejo de cadenas incorpora nuevas funciones que simplifican
tareas comunes, los numeros y fechas tambien tiene su aporte.

Los eventos estan uniforamdos bajo un modulo de manejo de eventos, que permite
conectar eventos del :term:DOM con funciones en JavaScript, así tambien como
funciones entre si.

.. note:: Poner los nombres de las funciones para destacar el laburo

Envolviendo a gears
===================

La biblioteca puede funcionar independiente de la instalación de Google Gears,
debido a que su principal funcionalidad como ya se menciono es la de extención
de
JavaScript y posterior soporte al framework, pese a esto Protopy provee
mecanismos para uniformar el acceso y extender los objetos de Gears cuando éste
se encuentra instalado en el navegador.

El acceso al `Factory` de Gears esta centralizado y controlado en el objeto
`gears` dentro del modulo `sys`, mediante este objeto es posible conocer el
estado de Gears y sus permisos. El objeto informa al desarrollador si Gears esta
instalado, la versión, si los permisos son corrector e incluso simplifica
el proceso de instalación de la extensión de no estar presente en el navegador
entre otras cosas.

El metodo `create` del objeto `sys.gears` es el encargado de crear y retornar
los objetos Gears. Esta función se ayuda de módulos presentes en el paquete
`gears` para asistir la creación de los objetos. El objeto que se retorne
dependera de la precencia del módulo con el mismo nombre en dicho paquete; de no
encontrar un modulo que asista la cración de un objeto Gears el objeto en sus
estado "puro" es retornado al llamador.

Si bien no es necesario que los módulos obtengan el acceso a Gears a traves de
Protopy, es recomendable que asi se haga; ya que la biblioteca provee los
mecanimos de extención para los objetos en `create`. Esto no fue así desde el
comienzo de del desarrollo y fue una idea que se maduro luego de observar que
resultaba complejo y costoso requerir los módulos que involucraban a Gears
desde distintos lugares.

El desarrollo del framework implico extender algunos objetos Gears,
concretamente
al paquete `gears` se incorporaron los siguientes módulos:

    * desktop

        El objeto `desktop` de Gears permite interactuar con el escritorio del
cliente. 
        Aquí se extendio la creacción de accesos directos para simplificar la
generación
        de los mismos y agregar la posibilidad de manejar `Icon` y algunos
`IconTheme`.

    * database

        Sobre el objeto `database` se agrego funcionalidad uniformar el acceso a
la base
        de datos por los módulos de Protopy y encapsular los `ResulSet` en
cursores a
        los que se incorporo iteradores, registro de funciones para tipos de
datos, etc.

Auditando el codigo
===================

Una queja recurrente de los desarrolladores que trabajan con JavaScript es lo
complejo que resulta el lenguaje para depurar errores. Encontrar errores en
el código resulta molesto y mas todavía si la salida de los mismos no esta en un
formato adecuado y encausada en un lugar especifico.

Tradicionalmente lo que se hace para detectar errores es valerse de funciones
`alert` diseminadas por el código con textos del estilo "Paso por aquí", pero
luego de cerrar unas diez o quince ventanas de este estilo, generalmente se
pierde referencia de donde esta ocurriendo el error y se cae en la tentación de
comenzar a comentar alerts a mansalva esperando dar con el indicado. Este es un
claro ejemplo de que tanto la salida como el sistema de detección de errores es
molesto e infructifero.

Una clara ventaja sobre el sistema tradicional y poderosa herramienta de
desarrollo es el plug-in Firebug, que integra entre otras cosas una consola
JavaScript y un debuger al ambinete del navegador, permitiendo a los
desarrolladores depurar el código mediante puntos de corte, inspección de
variables, etc. En firebug la consola pasa a ser por defecto la principal salida
de errores, gracias a la funcion `console.log` los desarrolladores pueden
redirigir todos los "Paso por aquí" a una salida uniforme e incluso inspeccionar
el valor de las variables.

Protopy lleva la depuración y auditoria del código un paso más lejos, integrando
un sistema de logging propio altamente configurable y con posibilidades de
escribir en diferentes salidas y con diferentes formatos.

Similar a log4j el logger de Protopy trabaja con niveles de prioridad para los
mensajes, distintos manejadores o `Handlers` y salidas en varios formatos. Todo
esto configurable por el desarrollador.

Una vez configurado el sistema de logging, los módulos que requieran auditar el
codigo solo deben requerir un logger en su sespacio de nombre e invocar a sus
funciones.

.. code-block:: javascript

    var logging = require('logging.base');
    var logger = logging.get_logger(__name__);

    ...

    logger.debug('La query: %s\n Los parametros: %s', query, params, {});

En este ejemplo se requiere el módulo `logging` y posteriormente un logger para
el módulo con el nombre __name__, de no encontrar configuración para este módulo
se adopta la configuracion del modulo inmediato superior y asi consecutivamente
hasta tomar la configuración del root logger.

Suponiendo que el módulo del ejemplo se llama doff.db.models.sql el siguiente
archivo de configuracion perapraria este logger en modo DEBUG para auditar el
código en la consola de firebug y en una url con distintos formatos.

.. code-block:: javascript

    {
        'loggers': {
            'root': {
                'level': 'DEBUG',
                'handlers': 'firebug'
            },
            'doff.db.models.sql': {
                'level': 'DEBUG',
                'handlers': [ 'firebug', 'remote'],
                'propagate': true
            },
        },
        'handlers': {
            'firebug': {
                'class': 'FirebugHandler',
                'level': 'DEBUG',
                'formatter': '%(time)s %(name)s(%(levelname)s):\n%(message)s',
                'args': []
            },
            'remote': {
                'class': 'RemoteHandler',
                'level': 'DEBUG',
                'formatter': '%(levelname)s:\n%(message)s',
                'args': ['/loggers/audit']
            },
            'alert': {
                'class': 'AlertHandler',
                'level': 'DEBUG',
                'formatter': '%(levelname)s:\n%(message)s',
                'args': []
            }
        }
    }

.. note:: Poner referencia a firebug

Interactuando con el servidor
=============================

Protopy permite al desarrollador trabajar con AJAX de forma simple y segura,
encapuslando en objetos la lógica de petición y los valores de retorno del
servidor.

Todo lo relacionado con AJAX se encuentra en el modulo `ajax`. El objeto de
transporte para ajax es `XMLHttpRequest` e internamente se salvan las
diferencias que existen entre los distintos navegadores. La forma de realizar
una peticion es creando una instancia del objeto ajax.Request.

.. code-block:: javascript

    new ajax.Request('una/url', {method: 'get'});

La primera opcion es la url de la solicitud, y el segundo parametro es el hash
de opciones, en este caso el metodo a utilizar es GET, si no se especifica, el
metodo por defecto es POST.

Por defecto la respuesta del servidor es asincrona, para este caso se debe
explicitar en el hash de opciones las funciones que manejaran los eventos
disparados.   

.. code-block:: javascript

    new ajax.Request('una/url', { 
        method:'get',
        onSuccess: function(transport){ 
            var response = transport.responseText || "sin texto";
            alert("Success! \n\n" + response); }, 
        onFailure: function(){ 
            alert('Algo esta mal...'); } 
    }); 

En el ejemplo se presentan dos funciones, onSuccess y onFailure, para manejar
los eventos correspondientes. A cada manejador se le pasa un objeto que
representa la respuesta obtenida y que esta en relación con el evento
capturando.

Otros manejadores que se pueden definir son:
    
    * onUninitialized
    * onLoading
    * onLoaded
    * onInteractive
    * onComplete
    * onException 

Todos estos dependen de un estado del objeto `XMLHttpRequest`.

De igual manera que el resto de las opciones es posible agregar parametros a la
peticion, estos pueden ser pasados como un objeto "hasheable" o como una cadena
clave-valor.

Soporte para json
=================

La idea detras del soporte para JSON en Protopy es la transimisión de datos
generados offline por el cliente, en el momento de recuperar la conexion con el
servidor el cliente debe serializar los datos y enviarlos al servidor; otro uso
para es el intercambio de mensajes de control.

La transferencia de datos involucra varios temas, uno de ellos y que compete
a este apartado, es el formato de los datos que se deben pasar por
la conexcion; este formato debe ser "comprendido" tanto por el cliente como
por el servidor. Desde un primer momento se penso en JSON como el formato
de datos a utilizar, es por esto que Protopy incluye un modulo para trabajar
con el mismo.

El soporte para JSON se encuentra en el modulo "json" entre los módulos
estandar de Protopy. Este brinda soporte al pasaje de estructuras de datos
JavaScript a JSON y viceversa.

Los tipos base del lenguje JavaScript estan soportados y tienen su
reprecentacion correspondiente, object, array, number, string, etc. pero este
modulo interpreta ademas de una forma particular a aquellos objetos que
implementen el metodo __json__, dejando de este modo en manos del
desarrollador la reprecentacion en JSON de determinado objetos.

Con el soporte de datos ya establecidos en la libreria, el framework solo
debe limitarse a hacer uso de él y asegurar la correcta sincronizacion de datos
entre el cliente y el servidor web, este tema se retomara en el capitulo de
sincronizacion.

XML
---

No existe una razon concreta por la cual se deja de lado el soporte en Protopy
para XML como formato de datos; aunque se puede mencionar la simplicidad de
implementacion de un parser JSON contra la implementacion de uno en XML.
Para el leector interesado agregar el sporte para XML en Protopy consta de
escribir un modulo que realize esa tarea y agregarlo al paquete base.

Ejecutando codigo remoto
========================
.. JSON-RPC http://json-rpc.org/ 
.. XML-RPC http://www.xmlrpc.com/
El RPC (del inglés Remote Procedure Call, Llamada a Procedimiento Remoto) es un
protocolo que permite a un programa de ordenador ejecutar código en otra máquina
remota sin tener que preocuparse por las comunicaciones entre ambos. El
protocolo
es un gran avance sobre los sockets usados hasta el momento. De esta manera el
programador no tenía que estar pendiente de las comunicaciones, estando éstas
encapsuladas dentro de las RPC.

Las RPC son muy utilizadas dentro del paradigma cliente-servidor. Siendo el
cliente el que inicia el proceso solicitando al servidor que ejecute cierto
procedimiento o función y enviando éste de vuelta el resultado de dicha
operación
al cliente.

Hay distintos tipos de RPC, muchos de ellos estandarizados como pueden ser el
RPC
de Sun denominado ONC RPC (RFC 1057), el RPC de OSF denominado DCE/RPC y el
Modelo de Objetos de Componentes Distribuidos de Microsoft DCOM, aunque ninguno
de estos es compatible entre sí. La mayoría de ellos utilizan un lenguaje de
descripción de interfaz (IDL) que define los métodos exportados por el servidor.

Hoy en día se está utilizando el XML como lenguaje para definir el IDL y el HTTP
como protocolo de red, dando lugar a lo que se conoce como servicios web.
Ejemplos de éstos pueden ser SOAP o XML-RPC. XML-RPC es un protocolo de llamada
a
procedimiento remoto que usa XML para codificar los datos y HTTP como protocolo
de transmisión de mensajes.[1]

Es un protocolo muy simple ya que sólo define unos cuantos tipos de datos y
comandos útiles, además de una descripción completa de corta extensión. La
simplicidad del XML-RPC está en contraste con la mayoría de protocolos RPC que
tiene una documentación extensa y requiere considerable soporte de software para
su uso.

Fue creado por Dave Winer de la empresa UserLand Software en asociación con
Microsoft en el año 1998. Al considerar Microsoft que era muy simple decidió
añadirle funcionalidades, tras las cuales, después de varias etapas de
desarrollo, el estándar dejó de ser sencillo y se convirtió en lo que es
actualmente conocido como SOAP. Una diferencia fundamental es que en los
procedimientos en SOAP los parámetros tienen nombre y no interesan su orden, no
siendo así en XML-RPC.[2

