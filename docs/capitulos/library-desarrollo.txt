.. _capitulos-protopy:

#######
Protopy
#######

Introducción
============

.. note:: 

    Ver donde poner estos dos parrafos, que estan buenos pero creo que no van aca :)

    En apartados teóricos se menciono, entre otras cosas, que la creación de un
    framework generalmente surge de la identificación de objetos reusables en
    el desarrollo de software. Posteriormente los objetos identificadas decantan en
    componentes que forman parte de la arquitectura del framework y a los cuales se
    accede mediante la extención y la configuración.
    Esta forma de obtener un producto que permita arquitecturar proyectos de
    caracteristicas similares a los que lé dieron origen, implica pasar por varias
    etapas de maduración en el desarrollo, pero requieren de un punto de partida
    primordial y es justamente un proyecto que oriente la identificacion de las
    partes reusables. Nuestro caso se complica en este punto, ya que la intención
    panteada desde el principio es la de "desarrollar un framework" y la realidad
    del desarrollo es que muchas de las partes surguieron en paralelo y de la mano
    de aplicaciones de prueba.

El presente capítulo profundiza sobre el desarrollo de la librería de JavaScript
sobre la cual se implenta una versión desconectada de Django. Como se mencionó
en el capítulo anterior, si bien JavaScript en sus versiones 1.7 y 1.8 incorpora
muchos elementos que acercan su sintaxis a la de Python, es 
necesario implementar una capa intermedia entre JavaScript y Django "desconectado".
Una de las razones mas relevantes es emular la API estándard de Python.

La biblioteca se basó en el código fuente de Prototype, sobre la cual se fue agregando
y sustituyendo código. El resultado de esta modificación se bautizó en honor a 
sus dos "padres", por un lado *Portotype JavaScript Library* y el lenguaje de programación
*Python*:

    | **proto** type + **py** thon = **protopy**


Objetivos de la Librería
------------------------

* Modularización y ámbito de nombres.

    Un framework con funciones minimas, como una API de base de datos y un motor
    de plantillas, requiere una cantidad considreable de código. Django por ejemplo
    consta de cerca de 43000 líneas, sin contar las aplicaciones 
    contribuidas (administración, GIS, data, sesiones, autenticación, bitácora) [*]_.
    En particular, para migrar un framework implementado sobre Python, el sistema
    de paquetes es muy importante. En Python los módulos definien ámbitos de nombres
    de los cuales se pueden importar selectivamente sólo los símbolos usados, sin
    contaminar el ámbito local.
    

* Orietnación a Objetos "Pythonica"

    En JavaScript, cada prtotipo almacena la estrctura estática de la "clase"
    y en el constructor se inicializa la instancia. En Python, la creación 
    de la clase la realiza el método ``__new__`` y la inicialización, el 
    método ``__init__``. Python permite herencia múltiple y la definición
    dinámica de tipos a través de metaclases o mediante el builtin ``type`` 
    (que sirve como factory). Es necesario para adaptar el código
    Python a JavaScript, definir los tipos base ``object`` y ``type`` debido
    a que piezas claves de Django como el ORM y el sistema de formularios
    basan su funcionamiento en estos builtins.
    
    En Python también se pueden definir métodos especiales en las clases, que permiten
    sobrecarga de operadores (``+`` mediante ``__add__``,
    ``==`` mediante ``__eq__``,
    ``&`` y ``^`` medinate ``__and__`` y ``__or__``,
    los paréntesis de invocación ``()`` mediante ``__call__``, etc). Algunos de
    estos se pueden emular en JavaScript y Protopy brinda facilidades para esto.
    
* Tipos de datos y ``builtins``
    
    Existen ciertos tipos que no existen en JavaScript con la misma funcionalidad
    que en Python. Un caso puntual son los ``Object`` o arreglos asociativos 
    comparados con el tipo de datos ``dict``.
    
    En Python el conjunto de funciones, tipos disponibles en el ámbito de nombres global
    se conoce como ``builtins``. Forman parte de este conjunto,
    ``int``, ``bool``, ``str``, ``list``, ``tuple``, ``map``, ``filter``, 
    ``abs``, ``all``, etc. La mayoría de estos símbolos fueron portados a Protopy 
    y también publicados en el ámbito global.
    
    
* Selección de elementos mediante CSS

    DOM permite realizar búsqueda de elementos dentro de un documento de 
    tres maneras: mediante un identificados, mediante un nombre de tag, o
    el acceso gerárquico tipo árbol (estas técnicas se pueden combinar).
    
    Los selectores CSS simplifcan la tarea de seleccionar un conjunto de 
    elementos que cumple con cierta condición. Utilizan la sintaxis de
    las hojas de estilo en cascada para determinar los elementos que
    están siendo seleccionados.
    Por ejemplo
    con la API de DOM seleccionar todos los elementos del tipo link, que
    posean un atributo ``href`` se realiza de la siguiente manera:
    
    .. code-block:: javascript
        
        var links = document.getElementsByTagName('a').
            filter( function (e) { return e.getAttribute('href'); });
    
    Mientras que con selección CSS, esto se reduce a:
    
    .. code-block:: javascript
    
        var links = $$('a[href]');
       
    Las librerías YUI, Protype, jQuery, Dojo, Ext JS entre otras poseen este
    tipo de selector. Su utilización libra al desarrollador de incompatiblidades 
    o implementaciones pobres de DOM, a la hora de interacturar con los elementos
    del documento. 


.. [*] Métrica obtenida de el comando 
    ``wc -l $(find django -iname "*.py" | grep -v contrib | grep -v backends)``
    

Compatibilidad de Protopy
~~~~~~~~~~~~~~~~~~~~~~~~~

JavaScript 1.7 solo se encuentra implementado sobre la plataforma Mozilla
(Firefox 3.0+). Dado que existe una sola plataforma compatible  se quitaron 
gran parte de los arreglos de compatibilidad presentes originalmente en Prototype
y se portó a nueva sintaxis muchas partes del código original. 

.. _protopy-modulos:

Organizando el codigo
=====================

Como se mencionó en el apartado teórico dedicado a JavaScript, la inclusión
de código en un documento HTML se realiza mediante el tag ``script`` definiendo
en el atributo ``src`` la URL del recurso. Cuando el navegador encuentra estos
tags durante el análisis del documento (o *parsing*), descarga el recurso y lo
evalúa en el contexto del documento (elemento DOM ``window``).
 
Este tipo de enfoque resulta práctico para proyectos pequeños (donde se uitiliza
JavaScript para validación, enriquecimeinto de formularios, accesibilidad) pero
resulta limitado y poco mantenible.

En Protopy se buscó la forma de solucionar este problema de la modularidad (
separación de código) con el del ámbito de nombres (que cáda módulo se evalue 
en un ámbito aislado, para lograr bajo acoplamiento). 

Se tomó la idea de la carga asincrónica de Kris Kowal [KrisKowal]_ y en cierta forma también
el equipo de YUI de cargar los módulos de manera asincrónica.

.. [KrisKowal] Kris Kowal,
                Proyecto module.js,
                útlimo acceso Septiembre 2009

El enfoque tradicional resulta sustentable para pequeños proyectos, donde el
lenguaje brinda mayormente soporte a la interacción con el usuario (validacion,
accesibilidad, etc) y los fragmentos de código que se pasan al cliente son
bien conocidos por el desarrollador, pero en proyectos que implican mayor
cantidad
de funcionalidad JavaScript, con grandes cantidades de código, este enfoque
resulta complejo de mantener y evolucionar en el tiempo. Es por esto que para
Protopy se busco como primera medida una forma de organizar y obtener el código
del servidor que resulte sustentable y escalable.

Similar al concepto de :ref:`modulos en Python <servidor-lenguajes-python>`, el
desarrollo de Protopy se oriento en pequeñas unidades funcionales llamadas
**modulos**.

Además de la sanidad mental que implica organizar el código en distintos
archivos, los módulos representan un cambio muy importante en la obtención de
funcionalidad; ya no es el documento HTML el que dice al cliente que archivo
cargar del servidor, sino que el mismo código interpretado obtiene la
funcionalidad a medida que la requiere.

    "Namespaces are one honking great idea -- let's do more of those!"

    -- import this

http://www.gulic.org/almacen/diveintopython-5.4-es/html_processing/locals_and_globals.html

El enfoque modular no es nuevo en programación y basicamente, la implementación
de Protopy, implica llevar el concepto de "divide y vencerás" ó "análisis
descendente (Top-Down)" al hambito de JavaScript.

Un módulo resuelve un problema especifico y define una interfaz de comunicación
para accesar y utilizar la funcionalidad que contiene. Por más simple que
resulte de leer, esto implica que existe una manera de **obtener** un modulo y
una manera de **publicar** la funcionalidad de un modulo, logrando de esta forma
que interactuen entre ellos.

En su forma mas pedestre un módulo es un archivo que contiene definiciones y
sentencias de JavaScript. El nombre del archivo es el nombre del módulo con el
sufijo .js pegado y dentro de un módulo, el nombre del módulo está disponible
como el valor de la variable `__name__`.

Obtener un módulo
-----------------

La función `require` es la encargada de obtener un módulo del servidor e
incorporarlo al :ref:`espacio de nombres <servidor-lenguajes-python>` del
llamador. Por ejemplo, cuando un módulo llamado spam es requerido, Protopy busca
un archivo
llamado spam.js en la url base [*]_, de no encontrar el archivo el error
``LoadError`` es lanzado a la función que requirio el módulo.

.. [*] Ruta base desde la cual la biblioteca Protopy carga los módulos, por
    defecto esta es la url base del archivo protopy.js más el sufijo `packages`.

Otra forma de obtener módulos es usando nombres de **paquetes**. A diferencia de
Python un paquete no incluye funcionalidad en si mismo y su funcionalidad
principal es la de establecer las bases en la cual buscar modulos.
De forma similar a la anterior cuando un módulo llamado foo.spam es importado,
Protopy busca en el objeto sys.paths si existe una url asociada al paquete foo,
de encontrar la url base para foo el archivo spam.js es buscado en esa
ubicación, por otra parte si sys.paths no contiene una url asociada a foo el
archivo foo/spam.js es buscado en la url base. 

El uso del objeto sys.paths permite a los modulos de JavaScript que saben lo
que están haciendo modificar o reemplazar el camino de búsqueda para los
módulos.
Nótese que es importante que el script no tenga el mismo nombre que un
:ref:`módulo estandar <apendices-protopy-modulos>`.

Las formas en que el modulo obtenido es presentado al llamador difiere en
funcion de los parametros pasados a `require`. Estas formas son:

    * Un modulo puede ser obtenido como un objeto,

    * Se puede obtener solo determinada funcion de un modulo,

    * O se pueden importar todas las definiciones del módulo en el espacio de
    nombres del llamador.

Para ver más :ref:`Apendice Protopy <apendices-protopy>`.

Publicar un módulo
------------------

La acción de publicar un modulo implica exponer la funcionalidad que este
define.
En Python no es necesario explicitar que funcionalidad del módulo se expone a
los llamadores, ya que todo lo definido en él es público; pero los módulos en
Protopy se evaluan dentro de una clausura y los llamadores no podran acceder
a sus funciones si no son publicadas. 

La funcion `publish` es la encargada de relizar la tarea de publicar el
contenido del modulo en Protopy.

Un modulo puede contener sentencias ejecutables y definición de funciones,
generalmente las sentencias son para inicializar el módulo ya que estas se
evaluan solo la primera vez que el módulo es requerido a alguna parte y las
definiciones son las que efectivamente seran publicadas como funcionalidad.

A continuación se presenta un fragmento de código que ejemplifica el uso de las 
dos funciones presentadas.

.. code-block:: javascript
    :linenos:

     /* Obtengo la funcion copy y deepcopy del modulo copy
        estas funciones son para copia de objetos
        superficiales y en profundidad respectivamente. */
    require('copy', 'copy', 'deepcopy');

    /* Representa la cantidad maxima de caches */
    var MAX = 1000;

    /* Objeto para guardar las cache */
    var cache = {};

    ...

    /* Estructura de datos que representa a una cache */
    var Cache = type('Cache', [ Dict ], {
        ...
    });

    /* Funcion que retorna una cache */
    function get_cache(name) {
        if (len(cache) > 1000)
            throw new Exception('%s caches creadas'.subs(MAX));
        var c = cache[name];
        if (!isundefined(c)) {
            c = new Cache();
            cache[name] = c;
        }
        return d;
    }

    /* Publico la cantidad maxima de caches
       la funcion para obtener caches. */
    publish({
        MAX: MAX,
        get_cache: get_cache
    });

Asumiendo que el código presentado está en un archivo llamado `caches.js` en
la url base, éste representa un módulo en sí mismo y el acceso se obtiene
mediante la invocación de 'require('caches')'.

.. note:: Poner algo de espacio de nombres antes de entrar de lleno con escribir modulos y leer modulos

Modulos nativos
---------------

.. note:: describir de forma rápida los módulos principales

    * builtin

    * dom

    * sys

    * event

    * ajax

    * exceptions

    * timer

.. _protopy-tipos:

Creando tipos de objeto
=======================

En el apartado teórico se toco el tema de construcción de objetos en base a
"clases" y de la emulación de herencia en JavaScript. Aunque muchos autores
cuestionan estas practicas alegando, con justa razon, que no tiene sentido
emular un paradigma dentro de otro; en la practica tener una implementación de
objetos tipados en JavaScript ayuda al reuso de código y en gran medida a que
los programadores se acerquen al lenguaje.

La forma de crear nuevos "tipos de objetos" en Protopy es a traves de la función
`type`. Esta funcion no fue parte de la biblioteca hasta que no se observo la
necesidad de otrogar mayor "poder" al constructor de clases que brindaba
Prototype, y su aparcición posibilito nuevas formas de construir tipos, 
similares a las construcciones de tipos que brinda la funcion homónima en
Python, a la cual debe su nombre.

A continuación se presenta un fragmento de código que ejemplifica la creación de
tipos en Protopy.

.. code-block:: javascript
    :linenos:

    var Dict = type('Dict', object, {
        ...
    });

    var SortedDict = type('SortedDict', [ Dict ], {
        __init__: function(object) {
            this.keyOrder = (object && isinstance(object, SortedDict))? copy(object.keyOrder) : [];
            super(Dict, this).__init__(object);
        },
        __iter__: function() {
            for each (var key in this.keyOrder) {
                var value = this.get(key);
                var pair = [key, value];
                pair.key = key;
                pair.value = value;
                yield pair;
            }
        },
        __deepcopy__: function() {
            var obj = new SortedDict();
            for (var hash in this._key) {
                obj._key[hash] = deepcopy(this._key[hash]);
                obj._value[hash] = deepcopy(this._value[hash]);
            }
            obj.keyOrder = deepcopy(this.keyOrder); 
            return obj;
        },
        __str__: function() {
            var n = len(this.keyOrder);
            return "%s".times(n, ', ').subs(this.keyOrder);
        },
        set: function(key, value) {
            this.keyOrder.push(key);
            return super(Dict, this).set(key, value);
        },
        unset: function(key) {
            without(this.keyOrder, key);
            return super(Dict, this).unset(key);
        }
    });

Rapidamente, este ejemplo presenta la definición del tipo SortedDict, el cual es
una especialización del tipo base Dict. Como se observa la función constructora 
recibe, como primer argumento el nombre para el nuevo tipo, seguidamente un
arreglo con los tipo base y para terminar un objeto con los atributos y metodos
para los objetos de ese tipo.

Con los constructores así definidos es posible crear "objetos tipados" que se
comporten en función de sus respectivas definiciones.

.. code-block:: javascript

    >>> d = new SortedDict({'uno': 1})
    >>> d.set('dos', 2)
    >>> d.get('dos')
    2
    >>> d.items()
    [["uno", 1 ], ["dos", 2 ]]

Como se observa, para instanciar un nuevo tipo se utiliza el operador `new` de
JavaScript, este operador crea el nuevo objeto e invoca a la función `__init__`.
    
En los métodos la palabra reservada `this` tiene el comportamiento esperado,
presentado en la parte teorica, el cual es hacer referencia al objeto
instanciado con `new`.

Internamente `type` utiliza el objeto `prototype` para la construcción, con lo
cual el operador `instanceof` presenta un comportamiento coherente, pese a esto
se recomienda usar la funcion `isinstance` que trae Protopy, ya que esta permite
navegar por la cadena de herencia.

.. code-block:: javascript

    >>> d instanceof SortedDict
    true
    >>> d instanceof Dict
    false
    >>> isinstance(d, Dict)
    true

Inicialización
--------------

En el ejemplo se muestra la inicialización del tipo SorteDict usando una funcion
llamada `__init__`. Este método es llamado por el operador `new` inmediatamente
despues de crear una instancia. Sería tentador decir que es el “constructor”
de la clase. Si bien se parece un constructor de Java, actúa como si lo fuese ya
que el objeto ya esta instanciado cuando se llama a esta función.

Los métodos `__init__` son opcionales, pero cuando se define uno, se debe recordar
llamar explícitamente al método `__init__` del ancestro.

Otros métodos
-------------

Además de los métodos normales, Protopy prevee algunos métodos especiales para
los objetos, estos en lugar de ser llamarlos directamente, se invocan por la
biblioteca en circunstancias particulares o cuando se use una sintaxis
específica. 

    * `__str__`

        Este metodo se llama cuando es necesario proveer de una reprecentacion
        en texto del objeto, JavaScript provee para este objetivo el metodo
        toString, pero por cuestiones de nombres se prefirio usar este metodo en
        su lugar y hacer internamente una relacion entre las funciones.

    * `__iter__`

        Protopy se vale de versiones modernas de JavaScript y brinda soporte a
        iteradores, este es el método que el desarrollador debe definir si
        quiere objetos iterable, la funcion debe retornar un objeto que
        implemente el metodo next (un iterador o un generado), los bucles
        for hacen esto automáticamente, pero también se puede hacer manualmente.

    * `__cmp__`
    
        Llamado al comparar dos instancias de tipo con las funciones `equal` o
        `nequal`.

    * `__len__`

        Se invoca con la llamada a la funcion `len`. La función incorporada len
        devuelve la longitud de un objeto. Funciona sobre cualquier objeto del
        que se pueda pensar razonablemente que tiene longitud.

    * `__copy__` y `__deepcopy__`
    * `__json__` y `__html__`

Protopy tiene otros métodos especiales, general todos estos apuntan a emular
algun comportambiento de Python en JavaScript. 

Herencia
--------

Como ya se menciono, el codigo de un Framework no debe ser modificado y su
utilizacion esta respaldada en algun mecanimos de extención, redefiniendo o 
especializando componentes. Es en este punto donde proveer de una forma de
herencia al constructor de tipos resulta un paso en la dirección correcta,
eventualmente el desarrollador que requiera componentes especificos podra
heredar de los tipos correspondientes e implementar solo lo que haga falta. 

Protopy utiliza la herencia del tipo **Prototype chaining**, aunque lo hace de
una forma un poco "rebuscada" con el objeto de dar soporte a una herencia
multiple. 

Para implementar la herencia y en particular la herencia multiple, el contructor
de tipos recibe una lista de los tipos base e internamente crea un
objeto que agrega de derecha a izquierda todos los metodos de las bases,
posteriormente crea el tipo requerido tomando como base el objeto generado. Es
en este punto donde se pierde el poder del operador `instanceof` y es por eso
que Protopy provee una funcion para determinar la correspondencia entre
instancias y tipos llamada `isinstance`.

Otra funcion interesante importada de Python es `issubclass`, bajo determinadas
condiciones resulta util determinar si un tipo es una sub-clase de otro y para
ello esta funcion inspecciona la cadena de herencia hacia adelante entre los
"hijos" de un tipo.

Bien, ya se tiene un mecanismo de herencia casi completo, solo falta ver como se
accede a las funciones de tipos base cuando se esta redefiniendo un método, para
esto existe la funcion `super`, nuevamente y similar a Python esta función
asocia un tipo con una instancia, con lo cual logra el objetivo de llamar a un
método que se encuentre en un tipo base. Este comportamiento, es el equivalente,
en JavaScript, al de llamar al metodo del tipo base con la funcion `apply` o `call`.

Para terminar con herencia se debe destacar que de no especificar por lo menos
un tipo base, Protopy establce por defecto como base al tipo `object`. Object
como provee de los principales metodos (`__init__`, `__str__`) a todos los
nuevos tipos.

Metodos y atributos de tipo
---------------------------

Hasta aqui se vio como crear nuevos tipos de objetos y la posterior construccion
de instancias de un determinado tipo, Protopy tambien prevee una forma de
definir metodos y atributos de tipo, estos pertenecen al tipo en si, y no a las
instancias.

La forma de agregar atributos y metodos de tipo es a traves de un objeto
opcional que se pasa a la función constructora antes del objeto de instancia.

.. code-block:: javascript

    var Planeta = new type('Planeta', [ object ], {
        // Atributos y metodos de tipo
        count: 0,
        reset: function() {
            this.count = 0;
        }
    }, {
        // Atributos y metodos de instancia
        __init__: function(name) {
            this.name = name;
            this.count = Planeta.count++;
            // Otra forma puede ser con this.__class__.count++
        }
    });

El ejemplo presentado define el tipo "Planeta", este tipo internamente lleva un
contador que las instancias utilizan para numerarse en la construccion y una
funcion de reset para reiniciar el contador. Dentro de las funciones de tipo la
palabra reservada `this`, como es de esperar, hace referencia al tipo.
A continuacion se ve como usar el tipo.

.. code-block:: javascript

    >>> p = new Planeta('Tierra')
    window.Planeta name=Tierra count=0 __name__=Planeta
    >>> Planeta.reset()
    >>> sol = new Planeta('Sol')
    window.Planeta name=Sol count=0 __name__=Planeta __module__=window
    >>> mercurio = new Planeta('Mercurio')
    window.Planeta name=Mercurio count=1 __name__=Planeta
    >>> venus = new Planeta('Venus')
    window.Planeta name=Venus count=2 __name__=Planeta
    >>> tierra = new Planeta('Tierra')
    window.Planeta name=Tierra count=3 __name__=Planeta

Existe una funcion muy importante que se puede definir para el tipo, buscando la
emulacion de Python se adopto el metodo `__new__`. Este metodo permite al
desarrollador tomar parte en la constuccion del tipo, los parametros son de una
forma similar a Python, el nombre del nuevo tipo, el arreglo con los tipos base
y el objeto con atributos y metodos de instancia. 

Objetos nativos
---------------

Algunos objetos que se encuentran el la biblioteca son:

    * Dict

        Si bien la estructura "hasheable" nativa de JavaScript en un objeto,
        los diccionarios de Protopy permiten mejores formas de trabajar con la
        dupla clave-valor, posibilitando ademas el uso de objetos como claves en
        lugar de solo cadenas.

    * Set
        
        Los sets o conjuntos tomados de las matematicas, permiten crear bolasa
        de objetos únicos y trabajar con las operaciones propias, union,
        intersección, diferencia, etc.

    * Arguments

        Las funciones en JavaScript pueden recibir opcionalmente cualquier
        cantidad de argumentos, los objetos del tipo Arguments encapsulan y
        uniforman los argumentos pasados a una funcion y permiten establecer
        entre otras cosas valores por defecto. 

Extendiendo DOM y JavaScript
============================

Si bien el :term:`DOM` ofrece ya una :term:`API` muy completa para acceder,
añadir y cambiar dinámicamente el contenido del documento HTML, existen
funciones muy utiles y comunes en los desarrollos que los programadores
incorporan al HTML y se intentaron englobar y mantener dentro del nucleo de
Protopy. Funciones para modificar e incorporar elementos al documento son muy
comunes y estan disponibles en Protopy, en conjunto con otras para el manejo de
formularios, como serializacion, obtencion de valores, etc.

Otra extension interesante de mencionar es la de los tipos de datos en
JavaScript, en manejo de cadenas incorpora nuevas funciones que simplifican
tareas comunes, los numeros y fechas tambien tiene su aporte.

Los eventos estan uniforamdos bajo un modulo de manejo de eventos, que permite
conectar eventos del :term:`DOM` con funciones en JavaScript, así tambien como
funciones entre si.

.. note:: Poner los nombres de las funciones para destacar el laburo

Envolviendo a gears
===================

La biblioteca puede funcionar independiente de la instalación de Google Gears,
debido a que su principal funcionalidad como ya se menciono es la de extención
de
JavaScript y posterior soporte al framework, pese a esto Protopy provee
mecanismos para uniformar el acceso y extender los objetos de Gears cuando éste
se encuentra instalado en el navegador.

El acceso al `Factory` de Gears esta centralizado y controlado en el objeto
`gears` dentro del modulo `sys`, mediante este objeto es posible conocer el
estado de Gears y sus permisos. El objeto informa al desarrollador si Gears esta
instalado, la versión, si los permisos son corrector e incluso simplifica
el proceso de instalación de la extensión de no estar presente en el navegador
entre otras cosas.

El metodo `create` del objeto `sys.gears` es el encargado de crear y retornar
los objetos Gears. Esta función se ayuda de módulos presentes en el paquete
`gears` para asistir la creación de los objetos. El objeto que se retorne
dependera de la precencia del módulo con el mismo nombre en dicho paquete; de no
encontrar un modulo que asista la cración de un objeto Gears el objeto en sus
estado "puro" es retornado al llamador.

Si bien no es necesario que los módulos obtengan el acceso a Gears a traves de
Protopy, es recomendable que asi se haga; ya que la biblioteca provee los
mecanimos de extención para los objetos en `create`. Esto no fue así desde el
comienzo de del desarrollo y fue una idea que se maduro luego de observar que
resultaba complejo y costoso requerir los módulos que involucraban a Gears
desde distintos lugares.

El desarrollo del framework implico extender algunos objetos Gears,
concretamente
al paquete `gears` se incorporaron los siguientes módulos:

    * desktop

        El objeto `desktop` de Gears permite interactuar con el escritorio del
        cliente. Aquí se extendio la creacción de accesos directos para
        simplificar la generación de los mismos y agregar la posibilidad de
        manejar `Icon` y algunos `IconTheme`.

    * database

        Sobre el objeto `database` se agrego funcionalidad uniformar el acceso a
        la base de datos por los módulos de Protopy y encapsular los `ResulSet`
        en cursores a los que se incorporo iteradores, registro de funciones
        para tipos de datos, etc.

Auditando el codigo
===================

Una queja recurrente de los desarrolladores que trabajan con JavaScript es lo
complejo que resulta el lenguaje para depurar errores. Encontrar errores en
el código resulta molesto y mas todavía si la salida de los mismos no esta en un
formato adecuado y encausada en un lugar especifico.

Tradicionalmente lo que se hace para detectar errores es valerse de funciones
`alert` diseminadas por el código con textos del estilo "Paso por aquí", pero
luego de cerrar unas diez o quince ventanas de este estilo, generalmente se
pierde referencia de donde esta ocurriendo el error y se cae en la tentación de
comenzar a comentar alerts a mansalva esperando dar con el indicado. Este es un
claro ejemplo de que tanto la salida como el sistema de detección de errores es
molesto e infructifero.

Una clara ventaja sobre el sistema tradicional y poderosa herramienta de
desarrollo es el plug-in Firebug, que integra entre otras cosas una consola
JavaScript y un debuger al ambinete del navegador, permitiendo a los
desarrolladores depurar el código mediante puntos de corte, inspección de
variables, etc. En firebug la consola pasa a ser por defecto la principal salida
de errores, gracias a la funcion `console.log` los desarrolladores pueden
redirigir todos los "Paso por aquí" a una salida uniforme e incluso inspeccionar
el valor de las variables.

Protopy lleva la depuración y auditoria del código un paso más lejos, integrando
un sistema de logging propio altamente configurable y con posibilidades de
escribir en diferentes salidas y con diferentes formatos.

Similar a log4j el logger de Protopy trabaja con niveles de prioridad para los
mensajes, distintos manejadores o `Handlers` y salidas en varios formatos. Todo
esto configurable por el desarrollador.

Una vez configurado el sistema de logging, los módulos que requieran auditar el
codigo solo deben requerir un logger en su sespacio de nombre e invocar a sus
funciones.

.. code-block:: javascript

    var logging = require('logging.base');
    var logger = logging.get_logger(__name__);

    ...

    logger.debug('La query: %s\n Los parametros: %s', query, params, {});

En este ejemplo se requiere el módulo `logging` y posteriormente un logger para
el módulo con el nombre __name__, de no encontrar configuración para este módulo
se adopta la configuracion del modulo inmediato superior y asi consecutivamente
hasta tomar la configuración del root logger.

Suponiendo que el módulo del ejemplo se llama doff.db.models.sql el siguiente
archivo de configuracion perapraria este logger en modo DEBUG para auditar el
código en la consola de firebug y en una url con distintos formatos.

.. code-block:: javascript

    {
        'loggers': {
            'root': {
                'level': 'DEBUG',
                'handlers': 'firebug'
            },
            'doff.db.models.sql': {
                'level': 'DEBUG',
                'handlers': [ 'firebug', 'remote'],
                'propagate': true
            },
        },
        'handlers': {
            'firebug': {
                'class': 'FirebugHandler',
                'level': 'DEBUG',
                'formatter': '%(time)s %(name)s(%(levelname)s):\n%(message)s',
                'args': []
            },
            'remote': {
                'class': 'RemoteHandler',
                'level': 'DEBUG',
                'formatter': '%(levelname)s:\n%(message)s',
                'args': ['/loggers/audit']
            },
            'alert': {
                'class': 'AlertHandler',
                'level': 'DEBUG',
                'formatter': '%(levelname)s:\n%(message)s',
                'args': []
            }
        }
    }

.. note:: Poner referencia a firebug

Interactuando con el servidor
=============================

Protopy permite al desarrollador trabajar con AJAX de forma simple y segura,
encapuslando en objetos la lógica de petición y los valores de retorno del
servidor.

Todo lo relacionado con AJAX se encuentra en el modulo `ajax`. El objeto de
transporte para ajax es `XMLHttpRequest` e internamente se salvan las
diferencias que existen entre los distintos navegadores. La forma de realizar
una peticion es creando una instancia del objeto ajax.Request.

.. code-block:: javascript

    new ajax.Request('una/url', {method: 'get'});

La primera opcion es la url de la solicitud, y el segundo parametro es el hash
de opciones, en este caso el metodo a utilizar es GET, si no se especifica, el
metodo por defecto es POST.

Por defecto la respuesta del servidor es asincrona, para este caso se debe
explicitar en el hash de opciones las funciones que manejaran los eventos
disparados.   

.. code-block:: javascript

    new ajax.Request('una/url', { 
        method:'get',
        onSuccess: function(transport){ 
            var response = transport.responseText || "sin texto";
            alert("Success! \n\n" + response); }, 
        onFailure: function(){ 
            alert('Algo esta mal...'); } 
    }); 

En el ejemplo se presentan dos funciones, onSuccess y onFailure, para manejar
los eventos correspondientes. A cada manejador se le pasa un objeto que
representa la respuesta obtenida y que esta en relación con el evento
capturando.

Otros manejadores que se pueden definir son:
    
    * onUninitialized
    * onLoading
    * onLoaded
    * onInteractive
    * onComplete
    * onException 

Todos estos dependen de un estado del objeto `XMLHttpRequest`.

De igual manera que el resto de las opciones es posible agregar parametros a la
peticion, estos pueden ser pasados como un objeto "hasheable" o como una cadena
clave-valor.

Soporte para json
=================

La idea detras del soporte para JSON en Protopy es la transimisión de datos
generados offline por el cliente, en el momento de recuperar la conexion con el
servidor el cliente debe serializar los datos y enviarlos al servidor; otro uso
para es el intercambio de mensajes de control.

La transferencia de datos involucra varios temas, uno de ellos y que compete
a este apartado, es el formato de los datos que se deben pasar por
la conexcion; este formato debe ser "comprendido" tanto por el cliente como
por el servidor. Desde un primer momento se penso en JSON como el formato
de datos a utilizar, es por esto que Protopy incluye un modulo para trabajar
con el mismo.

El soporte para JSON se encuentra en el modulo "json" entre los módulos
estandar de Protopy. Este brinda soporte al pasaje de estructuras de datos
JavaScript a JSON y viceversa.

Los tipos base del lenguje JavaScript estan soportados y tienen su
reprecentacion correspondiente, object, array, number, string, etc. pero este
modulo interpreta ademas de una forma particular a aquellos objetos que
implementen el metodo __json__, dejando de este modo en manos del
desarrollador la reprecentacion en JSON de determinado objetos.

Con el soporte de datos ya establecidos en la libreria, el framework solo
debe limitarse a hacer uso de él y asegurar la correcta sincronizacion de datos
entre el cliente y el servidor web, este tema se retomara en el capitulo de
sincronizacion.

XML
---

No existe una razon concreta por la cual se deja de lado el soporte en Protopy
para XML como formato de datos; aunque se puede mencionar la simplicidad de
implementacion de un parser JSON contra la implementacion de uno en XML.
Para el leector interesado agregar el sporte para XML en Protopy consta de
escribir un modulo que realize esa tarea y agregarlo al paquete base.

Ejecutando código remoto
========================
.. JSON-RPC http://json-rpc.org/ 
.. XML-RPC http://www.xmlrpc.com/
El RPC (del inglés Remote Procedure Call, Llamada a Procedimiento Remoto) es un
protocolo que permite a un programa de ordenador ejecutar código en otra máquina
remota sin tener que preocuparse por las comunicaciones entre ambos. El
protocolo
es un gran avance sobre los sockets usados hasta el momento. De esta manera el
programador no tenía que estar pendiente de las comunicaciones, estando éstas
encapsuladas dentro de las RPC.

Las RPC son muy utilizadas dentro del paradigma cliente-servidor. Siendo el
cliente el que inicia el proceso solicitando al servidor que ejecute cierto
procedimiento o función y enviando éste de vuelta el resultado de dicha
operación
al cliente.

Hay distintos tipos de RPC, muchos de ellos estandarizados como pueden ser el
RPC
de Sun denominado ONC RPC (RFC 1057), el RPC de OSF denominado DCE/RPC y el
Modelo de Objetos de Componentes Distribuidos de Microsoft DCOM, aunque ninguno
de estos es compatible entre sí. La mayoría de ellos utilizan un lenguaje de
descripción de interfaz (IDL) que define los métodos exportados por el servidor.

Hoy en día se está utilizando el XML como lenguaje para definir el IDL y el HTTP
como protocolo de red, dando lugar a lo que se conoce como servicios web.
Ejemplos de éstos pueden ser SOAP o XML-RPC. XML-RPC es un protocolo de llamada
a
procedimiento remoto que usa XML para codificar los datos y HTTP como protocolo
de transmisión de mensajes.[1]

Es un protocolo muy simple ya que sólo define unos cuantos tipos de datos y
comandos útiles, además de una descripción completa de corta extensión. La
simplicidad del XML-RPC está en contraste con la mayoría de protocolos RPC que
tiene una documentación extensa y requiere considerable soporte de software para
su uso.

Fue creado por Dave Winer de la empresa UserLand Software en asociación con
Microsoft en el año 1998. Al considerar Microsoft que era muy simple decidió
añadirle funcionalidades, tras las cuales, después de varias etapas de
desarrollo, el estándar dejó de ser sencillo y se convirtió en lo que es
actualmente conocido como SOAP. Una diferencia fundamental es que en los
procedimientos en SOAP los parámetros tienen nombre y no interesan su orden, no
siendo así en XML-RPC.[2

